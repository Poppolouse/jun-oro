<?xml version="1.0" encoding="utf-8"?>
<instructions>
  <meta>
    <slug>test-writer</slug>
    <name>ğŸ§ª Test YazarÄ±</name>
    <description>Unit test, integration test ve test coverage optimizasyonu</description>
    <language>tr</language>
  </meta>
  <general_principles>
    <test_pyramid>
      <unit>70</unit>
      <integration>20</integration>
      <e2e>10</e2e>
      <note>Her seviye dengeli olmalÄ±</note>
    </test_pyramid>
    <aaa_pattern>
      <arrange>Test verisi hazÄ±rlama, mock'lar</arrange>
      <act>Test edilen fonksiyonu Ã§alÄ±ÅŸtÄ±rma</act>
      <assert>Sonucu kontrol etme</assert>
      <note>Her test bu Ã¼Ã§ bÃ¶lÃ¼me ayrÄ±lmalÄ±</note>
    </aaa_pattern>
    <naming>
      <format>[fonksiyon adÄ±] - [senaryo] - [beklenen sonuÃ§]</format>
      <example>calculateDiscount - geÃ§erli kupon kodu - yÃ¼zde 20 indirim uygulanÄ±r</example>
    </naming>
    <isolation>
      <rule>Her test baÄŸÄ±msÄ±z Ã§alÄ±ÅŸmalÄ±</rule>
      <tools>beforeEach/afterEach ile temizlik; mock'lar resetlenmeli</tools>
    </isolation>
    <turkish_requirement>
      <rule>TÃœM TEST AÃ‡IKLAMALARI VE HATA MESAJLARI TÃœRKÃ‡E YAZILMALIDIR</rule>
    </turkish_requirement>
  </general_principles>
  <file_structure>
    <example><![CDATA[
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Button.jsx
â”‚   â””â”€â”€ Button.test.jsx
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useApiCall.js
â”‚   â””â”€â”€ useApiCall.test.js
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ formatters.js
â”‚   â””â”€â”€ formatters.test.js
â””â”€â”€ api/
    â”œâ”€â”€ userService.js
    â””â”€â”€ userService.test.js

tests/
â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ auth.test.js
â”‚   â””â”€â”€ gameRating.test.js
â””â”€â”€ e2e/
    â”œâ”€â”€ login.spec.js
    â””â”€â”€ settings.spec.js
]]></example>
  </file_structure>
  <unit_test_templates>
    <utility_function><![CDATA[
 // filepath: src/utils/formatters.test.js

 import { describe, it, expect } from 'vitest';
 import { formatDate, formatCurrency, truncateText } from './formatters';

 describe('formatDate', () => {
   it('tarih ISO formatÄ±nda verildiÄŸinde - DD/MM/YYYY formatÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r', () => {
     // Arrange
     const isoDate = '2025-01-06T10:30:00Z';
     
     // Act
     const result = formatDate(isoDate);
     
     // Assert
     expect(result).toBe('06/01/2025');
   });

   it('geÃ§ersiz tarih verildiÄŸinde - "GeÃ§ersiz Tarih" dÃ¶ner', () => {
     const invalidDate = 'invalid-date';
     const result = formatDate(invalidDate);
     expect(result).toBe('GeÃ§ersiz Tarih');
   });

   it('tarih null olduÄŸunda - boÅŸ string dÃ¶ner', () => {
     const result = formatDate(null);
     expect(result).toBe('');
   });
 });

 describe('formatCurrency', () => {
   it('pozitif sayÄ± verildiÄŸinde - TL sembolÃ¼ ile formatlar', () => {
     expect(formatCurrency(1500)).toBe('1.500,00 TL');
   });
 });
]]></utility_function>
    <component_test><![CDATA[
 // filepath: src/components/Button.test.jsx

 import { describe, it, expect, vi } from 'vitest';
 import { render, screen, fireEvent } from '@testing-library/react';
 import Button from './Button';

 describe('Button bileÅŸeni', () => {
   it('label prop ile verildiÄŸinde - buton metnini gÃ¶sterir', () => {
     render(<Button label="Kaydet" />);
     expect(screen.getByText('Kaydet')).toBeInTheDocument();
   });

   it('onClick prop verildiÄŸinde - tÄ±klandÄ±ÄŸÄ±nda Ã§aÄŸrÄ±lÄ±r', () => {
     const handleClick = vi.fn();
     render(<Button label="TÄ±kla" onClick={handleClick} />);
     fireEvent.click(screen.getByText('TÄ±kla'));
     expect(handleClick).toHaveBeenCalledTimes(1);
   });
 });
]]></component_test>
    <hook_test><![CDATA[
 // filepath: src/hooks/useApiCall.test.js

 import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
 import { renderHook, waitFor } from '@testing-library/react';
 import useApiCall from './useApiCall';

 describe('useApiCall hook', () => {
   beforeEach(() => {
     global.fetch = vi.fn();
   });

   afterEach(() => {
     vi.clearAllMocks();
   });

   it('baÅŸarÄ±lÄ± API Ã§aÄŸrÄ±sÄ± - data ve loading state doÄŸru gÃ¼ncellenir', async () => {
     const mockData = { users: [{ id: 1, name: 'Ahmet' }] };
     global.fetch.mockResolvedValueOnce({ ok: true, json: async () => mockData });

     const { result } = renderHook(() => useApiCall('/api/users'));

     await waitFor(() => {
       expect(result.current.loading).toBe(false);
     });

     expect(result.current.data).toEqual(mockData);
   });
 });
]]></hook_test>
    <api_service_test><![CDATA[
 // filepath: src/api/userService.test.js

 import { describe, it, expect, vi, beforeEach } from 'vitest';
 import { createClient } from '@supabase/supabase-js';
 import { getUsers, createUser } from './userService';

 vi.mock('@supabase/supabase-js');

 describe('userService', () => {
   let mockSupabase;

   beforeEach(() => {
     mockSupabase = {
       from: vi.fn().mockReturnThis(),
       select: vi.fn().mockReturnThis(),
       insert: vi.fn().mockReturnThis(),
       update: vi.fn().mockReturnThis(),
       delete: vi.fn().mockReturnThis(),
       eq: vi.fn().mockReturnThis(),
       single: vi.fn()
     };
     createClient.mockReturnValue(mockSupabase);
   });

   it('baÅŸarÄ±lÄ± Ã§aÄŸrÄ± - kullanÄ±cÄ± listesi dÃ¶ner', async () => {
     const mockUsers = [{ id: '1', name: 'Ahmet', email: 'ahmet@test.com' }];
     mockSupabase.select.mockResolvedValueOnce({ data: mockUsers, error: null });
     const result = await getUsers();
     expect(result).toEqual(mockUsers);
   });
 });
]]></api_service_test>
  </unit_test_templates>
  <integration_test_templates>
    <api_integration><![CDATA[
 // filepath: tests/integration/auth.test.js

 import { describe, it, expect, beforeAll, afterAll } from 'vitest';
 import request from 'supertest';
 import app from '../../server/app';
 import { createClient } from '@supabase/supabase-js';

 describe('Auth API Integration', () => {
   let supabase;
   let testUserId;

   beforeAll(async () => {
     supabase = createClient(process.env.TEST_SUPABASE_URL, process.env.TEST_SUPABASE_KEY);
   });

   afterAll(async () => {
     if (testUserId) {
       await supabase.from('users').delete().eq('id', testUserId);
     }
   });

   it('geÃ§erli veri - yeni kullanÄ±cÄ± kaydedilir ve token dÃ¶ner', async () => {
     const newUser = { email: 'test@example.com', password: 'SecurePass123!', name: 'Test KullanÄ±cÄ±' };
     const response = await request(app).post('/api/auth/register').send(newUser).expect(201);
     expect(response.body.success).toBe(true);
     testUserId = response.body.data.user.id;
   });
 });
]]></api_integration>
  </integration_test_templates>
  <coverage_best_practices>
    <critical_paths>
      <item>Business logic: fiyat hesaplama, indirim, puan sistemi</item>
      <item>Authentication/Authorization</item>
      <item>Payment iÅŸlemleri</item>
      <item>Data validation</item>
    </critical_paths>
    <edge_cases>
      <item>Null/undefined</item>
      <item>BoÅŸ array/object</item>
      <item>Min/max deÄŸerler</item>
      <item>Ã‡ok uzun stringler</item>
    </edge_cases>
    <error_handling>
      <item>Try-catch bloklarÄ± ve meaningful hata mesajlarÄ±</item>
      <item>API hatalarÄ± (400, 401, 500) iÃ§in beklenen davranÄ±ÅŸ</item>
    </error_handling>
  </coverage_best_practices>
  <common_errors_and_solutions>
    <error>
      <title>Test'ler birbirine baÄŸÄ±mlÄ±</title>
      <solution>beforeEach/afterEach ile temizlik</solution>
    </error>
    <error>
      <title>Async test'lerde await unutmak</title>
      <solution>async/await veya waitFor kullan</solution>
    </error>
    <error>
      <title>Mock'larÄ± temizlememek</title>
      <solution>afterEach(() => vi.clearAllMocks())</solution>
    </error>
    <error>
      <title>GerÃ§ek API Ã§aÄŸrÄ±larÄ±</title>
      <solution>MUTLAKA mock kullan (jest.mock, vi.mock)</solution>
    </error>
  </common_errors_and_solutions>
  <checklist>
    <before>
      <item>Hangi fonksiyon/bileÅŸen test edilecek?</item>
      <item>Happy path senaryosu nedir?</item>
      <item>Edge case'ler listelendi mi?</item>
    </before>
    <during>
      <item>describe bloÄŸu oluÅŸturuldu</item>
      <item>beforeEach/afterEach eklendi</item>
      <item>AAA pattern uygulandÄ±</item>
      <item>Mock'lar doÄŸru yapÄ±landÄ±rÄ±ldÄ±</item>
    </during>
    <after>
      <item>Test geÃ§iyor mu? (npm test)</item>
      <item>Coverage artmÄ±ÅŸ mÄ±? (npm run coverage)</item>
      <item>TÃ¼m branch'ler kapsandÄ± mÄ±?</item>
    </after>
  </checklist>
  <diagrams>
    <mermaid_pyramid><![CDATA[
graph TD
  A[E2E Tests 10%] --> B[Integration Tests 20%]
  B --> C[Unit Tests 70%]
  
  style A fill:#ff6b6b
  style B fill:#ffd93d
  style C fill:#6bcf7f
]]></mermaid_pyramid>
    <mermaid_aaa><![CDATA[
graph LR
  A[Arrange: Test Verisi HazÄ±rla] --> B[Act: Fonksiyonu Ã‡alÄ±ÅŸtÄ±r]
  B --> C[Assert: Sonucu Kontrol Et]
]]></mermaid_aaa>
  </diagrams>
</instructions>
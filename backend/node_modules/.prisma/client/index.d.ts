
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model Game
 * 
 */
export type Game = $Result.DefaultSelection<Prisma.$GamePayload>
/**
 * Model LibraryEntry
 * 
 */
export type LibraryEntry = $Result.DefaultSelection<Prisma.$LibraryEntryPayload>
/**
 * Model UserPreferences
 * 
 */
export type UserPreferences = $Result.DefaultSelection<Prisma.$UserPreferencesPayload>
/**
 * Model GameSession
 * 
 */
export type GameSession = $Result.DefaultSelection<Prisma.$GameSessionPayload>
/**
 * Model UserStats
 * 
 */
export type UserStats = $Result.DefaultSelection<Prisma.$UserStatsPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model PageVisit
 * 
 */
export type PageVisit = $Result.DefaultSelection<Prisma.$PageVisitPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model SystemUpdate
 * 
 */
export type SystemUpdate = $Result.DefaultSelection<Prisma.$SystemUpdatePayload>
/**
 * Model SystemUpdateStep
 * 
 */
export type SystemUpdateStep = $Result.DefaultSelection<Prisma.$SystemUpdateStepPayload>
/**
 * Model Platform
 * 
 */
export type Platform = $Result.DefaultSelection<Prisma.$PlatformPayload>
/**
 * Model Changelog
 * 
 */
export type Changelog = $Result.DefaultSelection<Prisma.$ChangelogPayload>
/**
 * Model AdminAuditLog
 * 
 */
export type AdminAuditLog = $Result.DefaultSelection<Prisma.$AdminAuditLogPayload>
/**
 * Model session_history
 * 
 */
export type session_history = $Result.DefaultSelection<Prisma.$session_historyPayload>
/**
 * Model user_libraries
 * 
 */
export type user_libraries = $Result.DefaultSelection<Prisma.$user_librariesPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.libraryEntry`: Exposes CRUD operations for the **LibraryEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryEntries
    * const libraryEntries = await prisma.libraryEntry.findMany()
    * ```
    */
  get libraryEntry(): Prisma.LibraryEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPreferences`: Exposes CRUD operations for the **UserPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferences
    * const userPreferences = await prisma.userPreferences.findMany()
    * ```
    */
  get userPreferences(): Prisma.UserPreferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameSession`: Exposes CRUD operations for the **GameSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameSessions
    * const gameSessions = await prisma.gameSession.findMany()
    * ```
    */
  get gameSession(): Prisma.GameSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userStats`: Exposes CRUD operations for the **UserStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserStats
    * const userStats = await prisma.userStats.findMany()
    * ```
    */
  get userStats(): Prisma.UserStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pageVisit`: Exposes CRUD operations for the **PageVisit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PageVisits
    * const pageVisits = await prisma.pageVisit.findMany()
    * ```
    */
  get pageVisit(): Prisma.PageVisitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemUpdate`: Exposes CRUD operations for the **SystemUpdate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemUpdates
    * const systemUpdates = await prisma.systemUpdate.findMany()
    * ```
    */
  get systemUpdate(): Prisma.SystemUpdateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemUpdateStep`: Exposes CRUD operations for the **SystemUpdateStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemUpdateSteps
    * const systemUpdateSteps = await prisma.systemUpdateStep.findMany()
    * ```
    */
  get systemUpdateStep(): Prisma.SystemUpdateStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.platform`: Exposes CRUD operations for the **Platform** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Platforms
    * const platforms = await prisma.platform.findMany()
    * ```
    */
  get platform(): Prisma.PlatformDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.changelog`: Exposes CRUD operations for the **Changelog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Changelogs
    * const changelogs = await prisma.changelog.findMany()
    * ```
    */
  get changelog(): Prisma.ChangelogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminAuditLog`: Exposes CRUD operations for the **AdminAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAuditLogs
    * const adminAuditLogs = await prisma.adminAuditLog.findMany()
    * ```
    */
  get adminAuditLog(): Prisma.AdminAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session_history`: Exposes CRUD operations for the **session_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Session_histories
    * const session_histories = await prisma.session_history.findMany()
    * ```
    */
  get session_history(): Prisma.session_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_libraries`: Exposes CRUD operations for the **user_libraries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_libraries
    * const user_libraries = await prisma.user_libraries.findMany()
    * ```
    */
  get user_libraries(): Prisma.user_librariesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ApiKey: 'ApiKey',
    Game: 'Game',
    LibraryEntry: 'LibraryEntry',
    UserPreferences: 'UserPreferences',
    GameSession: 'GameSession',
    UserStats: 'UserStats',
    Campaign: 'Campaign',
    PageVisit: 'PageVisit',
    Notification: 'Notification',
    SystemUpdate: 'SystemUpdate',
    SystemUpdateStep: 'SystemUpdateStep',
    Platform: 'Platform',
    Changelog: 'Changelog',
    AdminAuditLog: 'AdminAuditLog',
    session_history: 'session_history',
    user_libraries: 'user_libraries'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "apiKey" | "game" | "libraryEntry" | "userPreferences" | "gameSession" | "userStats" | "campaign" | "pageVisit" | "notification" | "systemUpdate" | "systemUpdateStep" | "platform" | "changelog" | "adminAuditLog" | "session_history" | "user_libraries"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      Game: {
        payload: Prisma.$GamePayload<ExtArgs>
        fields: Prisma.GameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findFirst: {
            args: Prisma.GameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findMany: {
            args: Prisma.GameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          create: {
            args: Prisma.GameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          createMany: {
            args: Prisma.GameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          delete: {
            args: Prisma.GameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          update: {
            args: Prisma.GameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          deleteMany: {
            args: Prisma.GameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          upsert: {
            args: Prisma.GameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.GameGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCountArgs<ExtArgs>
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      LibraryEntry: {
        payload: Prisma.$LibraryEntryPayload<ExtArgs>
        fields: Prisma.LibraryEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LibraryEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LibraryEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>
          }
          findFirst: {
            args: Prisma.LibraryEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LibraryEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>
          }
          findMany: {
            args: Prisma.LibraryEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>[]
          }
          create: {
            args: Prisma.LibraryEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>
          }
          createMany: {
            args: Prisma.LibraryEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LibraryEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>[]
          }
          delete: {
            args: Prisma.LibraryEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>
          }
          update: {
            args: Prisma.LibraryEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>
          }
          deleteMany: {
            args: Prisma.LibraryEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LibraryEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LibraryEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>[]
          }
          upsert: {
            args: Prisma.LibraryEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>
          }
          aggregate: {
            args: Prisma.LibraryEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLibraryEntry>
          }
          groupBy: {
            args: Prisma.LibraryEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LibraryEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LibraryEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LibraryEntryCountAggregateOutputType> | number
          }
        }
      }
      UserPreferences: {
        payload: Prisma.$UserPreferencesPayload<ExtArgs>
        fields: Prisma.UserPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findFirst: {
            args: Prisma.UserPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findMany: {
            args: Prisma.UserPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          create: {
            args: Prisma.UserPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          createMany: {
            args: Prisma.UserPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          delete: {
            args: Prisma.UserPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          update: {
            args: Prisma.UserPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.UserPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPreferencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          upsert: {
            args: Prisma.UserPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          aggregate: {
            args: Prisma.UserPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPreferences>
          }
          groupBy: {
            args: Prisma.UserPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesCountAggregateOutputType> | number
          }
        }
      }
      GameSession: {
        payload: Prisma.$GameSessionPayload<ExtArgs>
        fields: Prisma.GameSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          findFirst: {
            args: Prisma.GameSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          findMany: {
            args: Prisma.GameSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>[]
          }
          create: {
            args: Prisma.GameSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          createMany: {
            args: Prisma.GameSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>[]
          }
          delete: {
            args: Prisma.GameSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          update: {
            args: Prisma.GameSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          deleteMany: {
            args: Prisma.GameSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>[]
          }
          upsert: {
            args: Prisma.GameSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          aggregate: {
            args: Prisma.GameSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameSession>
          }
          groupBy: {
            args: Prisma.GameSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameSessionCountArgs<ExtArgs>
            result: $Utils.Optional<GameSessionCountAggregateOutputType> | number
          }
        }
      }
      UserStats: {
        payload: Prisma.$UserStatsPayload<ExtArgs>
        fields: Prisma.UserStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          findFirst: {
            args: Prisma.UserStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          findMany: {
            args: Prisma.UserStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>[]
          }
          create: {
            args: Prisma.UserStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          createMany: {
            args: Prisma.UserStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>[]
          }
          delete: {
            args: Prisma.UserStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          update: {
            args: Prisma.UserStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          deleteMany: {
            args: Prisma.UserStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>[]
          }
          upsert: {
            args: Prisma.UserStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          aggregate: {
            args: Prisma.UserStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserStats>
          }
          groupBy: {
            args: Prisma.UserStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserStatsCountArgs<ExtArgs>
            result: $Utils.Optional<UserStatsCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      PageVisit: {
        payload: Prisma.$PageVisitPayload<ExtArgs>
        fields: Prisma.PageVisitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageVisitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageVisitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageVisitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageVisitPayload>
          }
          findFirst: {
            args: Prisma.PageVisitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageVisitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageVisitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageVisitPayload>
          }
          findMany: {
            args: Prisma.PageVisitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageVisitPayload>[]
          }
          create: {
            args: Prisma.PageVisitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageVisitPayload>
          }
          createMany: {
            args: Prisma.PageVisitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageVisitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageVisitPayload>[]
          }
          delete: {
            args: Prisma.PageVisitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageVisitPayload>
          }
          update: {
            args: Prisma.PageVisitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageVisitPayload>
          }
          deleteMany: {
            args: Prisma.PageVisitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageVisitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PageVisitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageVisitPayload>[]
          }
          upsert: {
            args: Prisma.PageVisitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageVisitPayload>
          }
          aggregate: {
            args: Prisma.PageVisitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePageVisit>
          }
          groupBy: {
            args: Prisma.PageVisitGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageVisitGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageVisitCountArgs<ExtArgs>
            result: $Utils.Optional<PageVisitCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      SystemUpdate: {
        payload: Prisma.$SystemUpdatePayload<ExtArgs>
        fields: Prisma.SystemUpdateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemUpdateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemUpdateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload>
          }
          findFirst: {
            args: Prisma.SystemUpdateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemUpdateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload>
          }
          findMany: {
            args: Prisma.SystemUpdateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload>[]
          }
          create: {
            args: Prisma.SystemUpdateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload>
          }
          createMany: {
            args: Prisma.SystemUpdateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemUpdateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload>[]
          }
          delete: {
            args: Prisma.SystemUpdateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload>
          }
          update: {
            args: Prisma.SystemUpdateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload>
          }
          deleteMany: {
            args: Prisma.SystemUpdateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemUpdateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemUpdateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload>[]
          }
          upsert: {
            args: Prisma.SystemUpdateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload>
          }
          aggregate: {
            args: Prisma.SystemUpdateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemUpdate>
          }
          groupBy: {
            args: Prisma.SystemUpdateGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemUpdateGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemUpdateCountArgs<ExtArgs>
            result: $Utils.Optional<SystemUpdateCountAggregateOutputType> | number
          }
        }
      }
      SystemUpdateStep: {
        payload: Prisma.$SystemUpdateStepPayload<ExtArgs>
        fields: Prisma.SystemUpdateStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemUpdateStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdateStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemUpdateStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdateStepPayload>
          }
          findFirst: {
            args: Prisma.SystemUpdateStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdateStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemUpdateStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdateStepPayload>
          }
          findMany: {
            args: Prisma.SystemUpdateStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdateStepPayload>[]
          }
          create: {
            args: Prisma.SystemUpdateStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdateStepPayload>
          }
          createMany: {
            args: Prisma.SystemUpdateStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemUpdateStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdateStepPayload>[]
          }
          delete: {
            args: Prisma.SystemUpdateStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdateStepPayload>
          }
          update: {
            args: Prisma.SystemUpdateStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdateStepPayload>
          }
          deleteMany: {
            args: Prisma.SystemUpdateStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemUpdateStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemUpdateStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdateStepPayload>[]
          }
          upsert: {
            args: Prisma.SystemUpdateStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdateStepPayload>
          }
          aggregate: {
            args: Prisma.SystemUpdateStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemUpdateStep>
          }
          groupBy: {
            args: Prisma.SystemUpdateStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemUpdateStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemUpdateStepCountArgs<ExtArgs>
            result: $Utils.Optional<SystemUpdateStepCountAggregateOutputType> | number
          }
        }
      }
      Platform: {
        payload: Prisma.$PlatformPayload<ExtArgs>
        fields: Prisma.PlatformFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          findFirst: {
            args: Prisma.PlatformFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          findMany: {
            args: Prisma.PlatformFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>[]
          }
          create: {
            args: Prisma.PlatformCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          createMany: {
            args: Prisma.PlatformCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlatformCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>[]
          }
          delete: {
            args: Prisma.PlatformDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          update: {
            args: Prisma.PlatformUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          deleteMany: {
            args: Prisma.PlatformDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlatformUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>[]
          }
          upsert: {
            args: Prisma.PlatformUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          aggregate: {
            args: Prisma.PlatformAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatform>
          }
          groupBy: {
            args: Prisma.PlatformGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformCountAggregateOutputType> | number
          }
        }
      }
      Changelog: {
        payload: Prisma.$ChangelogPayload<ExtArgs>
        fields: Prisma.ChangelogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChangelogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangelogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChangelogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangelogPayload>
          }
          findFirst: {
            args: Prisma.ChangelogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangelogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChangelogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangelogPayload>
          }
          findMany: {
            args: Prisma.ChangelogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangelogPayload>[]
          }
          create: {
            args: Prisma.ChangelogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangelogPayload>
          }
          createMany: {
            args: Prisma.ChangelogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChangelogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangelogPayload>[]
          }
          delete: {
            args: Prisma.ChangelogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangelogPayload>
          }
          update: {
            args: Prisma.ChangelogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangelogPayload>
          }
          deleteMany: {
            args: Prisma.ChangelogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChangelogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChangelogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangelogPayload>[]
          }
          upsert: {
            args: Prisma.ChangelogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangelogPayload>
          }
          aggregate: {
            args: Prisma.ChangelogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChangelog>
          }
          groupBy: {
            args: Prisma.ChangelogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChangelogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChangelogCountArgs<ExtArgs>
            result: $Utils.Optional<ChangelogCountAggregateOutputType> | number
          }
        }
      }
      AdminAuditLog: {
        payload: Prisma.$AdminAuditLogPayload<ExtArgs>
        fields: Prisma.AdminAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          findFirst: {
            args: Prisma.AdminAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          findMany: {
            args: Prisma.AdminAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          create: {
            args: Prisma.AdminAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          createMany: {
            args: Prisma.AdminAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          delete: {
            args: Prisma.AdminAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          update: {
            args: Prisma.AdminAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AdminAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AdminAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          aggregate: {
            args: Prisma.AdminAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAuditLog>
          }
          groupBy: {
            args: Prisma.AdminAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditLogCountAggregateOutputType> | number
          }
        }
      }
      session_history: {
        payload: Prisma.$session_historyPayload<ExtArgs>
        fields: Prisma.session_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.session_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.session_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_historyPayload>
          }
          findFirst: {
            args: Prisma.session_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.session_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_historyPayload>
          }
          findMany: {
            args: Prisma.session_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_historyPayload>[]
          }
          create: {
            args: Prisma.session_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_historyPayload>
          }
          createMany: {
            args: Prisma.session_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.session_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_historyPayload>[]
          }
          delete: {
            args: Prisma.session_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_historyPayload>
          }
          update: {
            args: Prisma.session_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_historyPayload>
          }
          deleteMany: {
            args: Prisma.session_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.session_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.session_historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_historyPayload>[]
          }
          upsert: {
            args: Prisma.session_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_historyPayload>
          }
          aggregate: {
            args: Prisma.Session_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession_history>
          }
          groupBy: {
            args: Prisma.session_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Session_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.session_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Session_historyCountAggregateOutputType> | number
          }
        }
      }
      user_libraries: {
        payload: Prisma.$user_librariesPayload<ExtArgs>
        fields: Prisma.user_librariesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_librariesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_librariesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_librariesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_librariesPayload>
          }
          findFirst: {
            args: Prisma.user_librariesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_librariesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_librariesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_librariesPayload>
          }
          findMany: {
            args: Prisma.user_librariesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_librariesPayload>[]
          }
          create: {
            args: Prisma.user_librariesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_librariesPayload>
          }
          createMany: {
            args: Prisma.user_librariesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_librariesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_librariesPayload>[]
          }
          delete: {
            args: Prisma.user_librariesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_librariesPayload>
          }
          update: {
            args: Prisma.user_librariesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_librariesPayload>
          }
          deleteMany: {
            args: Prisma.user_librariesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_librariesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_librariesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_librariesPayload>[]
          }
          upsert: {
            args: Prisma.user_librariesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_librariesPayload>
          }
          aggregate: {
            args: Prisma.User_librariesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_libraries>
          }
          groupBy: {
            args: Prisma.user_librariesGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_librariesGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_librariesCountArgs<ExtArgs>
            result: $Utils.Optional<User_librariesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    apiKey?: ApiKeyOmit
    game?: GameOmit
    libraryEntry?: LibraryEntryOmit
    userPreferences?: UserPreferencesOmit
    gameSession?: GameSessionOmit
    userStats?: UserStatsOmit
    campaign?: CampaignOmit
    pageVisit?: PageVisitOmit
    notification?: NotificationOmit
    systemUpdate?: SystemUpdateOmit
    systemUpdateStep?: SystemUpdateStepOmit
    platform?: PlatformOmit
    changelog?: ChangelogOmit
    adminAuditLog?: AdminAuditLogOmit
    session_history?: session_historyOmit
    user_libraries?: user_librariesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    adminAuditLogs: number
    apiKeys: number
    changelogs: number
    sessions: number
    libraryEntries: number
    notifications: number
    pageVisits: number
    session_history: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminAuditLogs?: boolean | UserCountOutputTypeCountAdminAuditLogsArgs
    apiKeys?: boolean | UserCountOutputTypeCountApiKeysArgs
    changelogs?: boolean | UserCountOutputTypeCountChangelogsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    libraryEntries?: boolean | UserCountOutputTypeCountLibraryEntriesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    pageVisits?: boolean | UserCountOutputTypeCountPageVisitsArgs
    session_history?: boolean | UserCountOutputTypeCountSession_historyArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChangelogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangelogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLibraryEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LibraryEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPageVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageVisitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSession_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_historyWhereInput
  }


  /**
   * Count Type GameCountOutputType
   */

  export type GameCountOutputType = {
    campaigns: number
    sessions: number
    libraryEntries: number
    session_history: number
  }

  export type GameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | GameCountOutputTypeCountCampaignsArgs
    sessions?: boolean | GameCountOutputTypeCountSessionsArgs
    libraryEntries?: boolean | GameCountOutputTypeCountLibraryEntriesArgs
    session_history?: boolean | GameCountOutputTypeCountSession_historyArgs
  }

  // Custom InputTypes
  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     */
    select?: GameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameSessionWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountLibraryEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LibraryEntryWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountSession_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_historyWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    children: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CampaignCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type SystemUpdateCountOutputType
   */

  export type SystemUpdateCountOutputType = {
    substeps: number
  }

  export type SystemUpdateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    substeps?: boolean | SystemUpdateCountOutputTypeCountSubstepsArgs
  }

  // Custom InputTypes
  /**
   * SystemUpdateCountOutputType without action
   */
  export type SystemUpdateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdateCountOutputType
     */
    select?: SystemUpdateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SystemUpdateCountOutputType without action
   */
  export type SystemUpdateCountOutputTypeCountSubstepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemUpdateStepWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    username: string | null
    createdAt: Date | null
    lastActive: Date | null
    role: string | null
    updatedAt: Date | null
    password: string | null
    profileImage: string | null
    profileImageKey: string | null
    status: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    username: string | null
    createdAt: Date | null
    lastActive: Date | null
    role: string | null
    updatedAt: Date | null
    password: string | null
    profileImage: string | null
    profileImageKey: string | null
    status: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    username: number
    createdAt: number
    lastActive: number
    role: number
    updatedAt: number
    password: number
    profileImage: number
    profileImageKey: number
    status: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    username?: true
    createdAt?: true
    lastActive?: true
    role?: true
    updatedAt?: true
    password?: true
    profileImage?: true
    profileImageKey?: true
    status?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    username?: true
    createdAt?: true
    lastActive?: true
    role?: true
    updatedAt?: true
    password?: true
    profileImage?: true
    profileImageKey?: true
    status?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    username?: true
    createdAt?: true
    lastActive?: true
    role?: true
    updatedAt?: true
    password?: true
    profileImage?: true
    profileImageKey?: true
    status?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string | null
    username: string | null
    createdAt: Date
    lastActive: Date
    role: string
    updatedAt: Date
    password: string | null
    profileImage: string | null
    profileImageKey: string | null
    status: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    username?: boolean
    createdAt?: boolean
    lastActive?: boolean
    role?: boolean
    updatedAt?: boolean
    password?: boolean
    profileImage?: boolean
    profileImageKey?: boolean
    status?: boolean
    adminAuditLogs?: boolean | User$adminAuditLogsArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    changelogs?: boolean | User$changelogsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    libraryEntries?: boolean | User$libraryEntriesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    pageVisits?: boolean | User$pageVisitsArgs<ExtArgs>
    session_history?: boolean | User$session_historyArgs<ExtArgs>
    user_libraries?: boolean | User$user_librariesArgs<ExtArgs>
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    userStats?: boolean | User$userStatsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    username?: boolean
    createdAt?: boolean
    lastActive?: boolean
    role?: boolean
    updatedAt?: boolean
    password?: boolean
    profileImage?: boolean
    profileImageKey?: boolean
    status?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    username?: boolean
    createdAt?: boolean
    lastActive?: boolean
    role?: boolean
    updatedAt?: boolean
    password?: boolean
    profileImage?: boolean
    profileImageKey?: boolean
    status?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    username?: boolean
    createdAt?: boolean
    lastActive?: boolean
    role?: boolean
    updatedAt?: boolean
    password?: boolean
    profileImage?: boolean
    profileImageKey?: boolean
    status?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "username" | "createdAt" | "lastActive" | "role" | "updatedAt" | "password" | "profileImage" | "profileImageKey" | "status", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminAuditLogs?: boolean | User$adminAuditLogsArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    changelogs?: boolean | User$changelogsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    libraryEntries?: boolean | User$libraryEntriesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    pageVisits?: boolean | User$pageVisitsArgs<ExtArgs>
    session_history?: boolean | User$session_historyArgs<ExtArgs>
    user_libraries?: boolean | User$user_librariesArgs<ExtArgs>
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    userStats?: boolean | User$userStatsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      adminAuditLogs: Prisma.$AdminAuditLogPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
      changelogs: Prisma.$ChangelogPayload<ExtArgs>[]
      sessions: Prisma.$GameSessionPayload<ExtArgs>[]
      libraryEntries: Prisma.$LibraryEntryPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      pageVisits: Prisma.$PageVisitPayload<ExtArgs>[]
      session_history: Prisma.$session_historyPayload<ExtArgs>[]
      user_libraries: Prisma.$user_librariesPayload<ExtArgs> | null
      preferences: Prisma.$UserPreferencesPayload<ExtArgs> | null
      userStats: Prisma.$UserStatsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      username: string | null
      createdAt: Date
      lastActive: Date
      role: string
      updatedAt: Date
      password: string | null
      profileImage: string | null
      profileImageKey: string | null
      status: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adminAuditLogs<T extends User$adminAuditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$adminAuditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    apiKeys<T extends User$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, User$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    changelogs<T extends User$changelogsArgs<ExtArgs> = {}>(args?: Subset<T, User$changelogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangelogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    libraryEntries<T extends User$libraryEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$libraryEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pageVisits<T extends User$pageVisitsArgs<ExtArgs> = {}>(args?: Subset<T, User$pageVisitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageVisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    session_history<T extends User$session_historyArgs<ExtArgs> = {}>(args?: Subset<T, User$session_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_libraries<T extends User$user_librariesArgs<ExtArgs> = {}>(args?: Subset<T, User$user_librariesArgs<ExtArgs>>): Prisma__user_librariesClient<$Result.GetResult<Prisma.$user_librariesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    preferences<T extends User$preferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$preferencesArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userStats<T extends User$userStatsArgs<ExtArgs> = {}>(args?: Subset<T, User$userStatsArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly lastActive: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'String'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly password: FieldRef<"User", 'String'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly profileImageKey: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.adminAuditLogs
   */
  export type User$adminAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    where?: AdminAuditLogWhereInput
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    cursor?: AdminAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * User.apiKeys
   */
  export type User$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * User.changelogs
   */
  export type User$changelogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changelog
     */
    select?: ChangelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Changelog
     */
    omit?: ChangelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangelogInclude<ExtArgs> | null
    where?: ChangelogWhereInput
    orderBy?: ChangelogOrderByWithRelationInput | ChangelogOrderByWithRelationInput[]
    cursor?: ChangelogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangelogScalarFieldEnum | ChangelogScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    where?: GameSessionWhereInput
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    cursor?: GameSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * User.libraryEntries
   */
  export type User$libraryEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryEntryInclude<ExtArgs> | null
    where?: LibraryEntryWhereInput
    orderBy?: LibraryEntryOrderByWithRelationInput | LibraryEntryOrderByWithRelationInput[]
    cursor?: LibraryEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LibraryEntryScalarFieldEnum | LibraryEntryScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.pageVisits
   */
  export type User$pageVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageVisit
     */
    select?: PageVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageVisit
     */
    omit?: PageVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageVisitInclude<ExtArgs> | null
    where?: PageVisitWhereInput
    orderBy?: PageVisitOrderByWithRelationInput | PageVisitOrderByWithRelationInput[]
    cursor?: PageVisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageVisitScalarFieldEnum | PageVisitScalarFieldEnum[]
  }

  /**
   * User.session_history
   */
  export type User$session_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_history
     */
    select?: session_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_history
     */
    omit?: session_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_historyInclude<ExtArgs> | null
    where?: session_historyWhereInput
    orderBy?: session_historyOrderByWithRelationInput | session_historyOrderByWithRelationInput[]
    cursor?: session_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Session_historyScalarFieldEnum | Session_historyScalarFieldEnum[]
  }

  /**
   * User.user_libraries
   */
  export type User$user_librariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_libraries
     */
    select?: user_librariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_libraries
     */
    omit?: user_librariesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_librariesInclude<ExtArgs> | null
    where?: user_librariesWhereInput
  }

  /**
   * User.preferences
   */
  export type User$preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    where?: UserPreferencesWhereInput
  }

  /**
   * User.userStats
   */
  export type User$userStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    where?: UserStatsWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceName: string | null
    keyName: string | null
    keyValue: string | null
    isActive: boolean | null
    isGlobal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsed: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceName: string | null
    keyName: string | null
    keyValue: string | null
    isActive: boolean | null
    isGlobal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsed: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    userId: number
    serviceName: number
    keyName: number
    keyValue: number
    isActive: number
    isGlobal: number
    metadata: number
    createdAt: number
    updatedAt: number
    lastUsed: number
    _all: number
  }


  export type ApiKeyMinAggregateInputType = {
    id?: true
    userId?: true
    serviceName?: true
    keyName?: true
    keyValue?: true
    isActive?: true
    isGlobal?: true
    createdAt?: true
    updatedAt?: true
    lastUsed?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    userId?: true
    serviceName?: true
    keyName?: true
    keyValue?: true
    isActive?: true
    isGlobal?: true
    createdAt?: true
    updatedAt?: true
    lastUsed?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    userId?: true
    serviceName?: true
    keyName?: true
    keyValue?: true
    isActive?: true
    isGlobal?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    lastUsed?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    userId: string | null
    serviceName: string
    keyName: string
    keyValue: string
    isActive: boolean
    isGlobal: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    lastUsed: Date | null
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceName?: boolean
    keyName?: boolean
    keyValue?: boolean
    isActive?: boolean
    isGlobal?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsed?: boolean
    user?: boolean | ApiKey$userArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceName?: boolean
    keyName?: boolean
    keyValue?: boolean
    isActive?: boolean
    isGlobal?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsed?: boolean
    user?: boolean | ApiKey$userArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceName?: boolean
    keyName?: boolean
    keyValue?: boolean
    isActive?: boolean
    isGlobal?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsed?: boolean
    user?: boolean | ApiKey$userArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    userId?: boolean
    serviceName?: boolean
    keyName?: boolean
    keyValue?: boolean
    isActive?: boolean
    isGlobal?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsed?: boolean
  }

  export type ApiKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "serviceName" | "keyName" | "keyValue" | "isActive" | "isGlobal" | "metadata" | "createdAt" | "updatedAt" | "lastUsed", ExtArgs["result"]["apiKey"]>
  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ApiKey$userArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ApiKey$userArgs<ExtArgs>
  }
  export type ApiKeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ApiKey$userArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      serviceName: string
      keyName: string
      keyValue: string
      isActive: boolean
      isGlobal: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      lastUsed: Date | null
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys and returns the data updated in the database.
     * @param {ApiKeyUpdateManyAndReturnArgs} args - Arguments to update many ApiKeys.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ApiKey$userArgs<ExtArgs> = {}>(args?: Subset<T, ApiKey$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly userId: FieldRef<"ApiKey", 'String'>
    readonly serviceName: FieldRef<"ApiKey", 'String'>
    readonly keyName: FieldRef<"ApiKey", 'String'>
    readonly keyValue: FieldRef<"ApiKey", 'String'>
    readonly isActive: FieldRef<"ApiKey", 'Boolean'>
    readonly isGlobal: FieldRef<"ApiKey", 'Boolean'>
    readonly metadata: FieldRef<"ApiKey", 'Json'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly lastUsed: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number
  }

  /**
   * ApiKey updateManyAndReturn
   */
  export type ApiKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to delete.
     */
    limit?: number
  }

  /**
   * ApiKey.user
   */
  export type ApiKey$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model Game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameAvgAggregateOutputType = {
    rating: number | null
    accessCount: number | null
  }

  export type GameSumAggregateOutputType = {
    rating: number | null
    accessCount: number | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    name: string | null
    cover: string | null
    firstReleaseDate: Date | null
    summary: string | null
    rating: number | null
    developer: string | null
    publisher: string | null
    cachedAt: Date | null
    lastAccessed: Date | null
    accessCount: number | null
    coverKey: string | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    name: string | null
    cover: string | null
    firstReleaseDate: Date | null
    summary: string | null
    rating: number | null
    developer: string | null
    publisher: string | null
    cachedAt: Date | null
    lastAccessed: Date | null
    accessCount: number | null
    coverKey: string | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    name: number
    cover: number
    firstReleaseDate: number
    genres: number
    platforms: number
    summary: number
    rating: number
    developer: number
    developers: number
    publisher: number
    publishers: number
    steamData: number
    igdbData: number
    hltbData: number
    metacriticData: number
    cachedAt: number
    lastAccessed: number
    accessCount: number
    coverKey: number
    _all: number
  }


  export type GameAvgAggregateInputType = {
    rating?: true
    accessCount?: true
  }

  export type GameSumAggregateInputType = {
    rating?: true
    accessCount?: true
  }

  export type GameMinAggregateInputType = {
    id?: true
    name?: true
    cover?: true
    firstReleaseDate?: true
    summary?: true
    rating?: true
    developer?: true
    publisher?: true
    cachedAt?: true
    lastAccessed?: true
    accessCount?: true
    coverKey?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    name?: true
    cover?: true
    firstReleaseDate?: true
    summary?: true
    rating?: true
    developer?: true
    publisher?: true
    cachedAt?: true
    lastAccessed?: true
    accessCount?: true
    coverKey?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    name?: true
    cover?: true
    firstReleaseDate?: true
    genres?: true
    platforms?: true
    summary?: true
    rating?: true
    developer?: true
    developers?: true
    publisher?: true
    publishers?: true
    steamData?: true
    igdbData?: true
    hltbData?: true
    metacriticData?: true
    cachedAt?: true
    lastAccessed?: true
    accessCount?: true
    coverKey?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
    orderBy?: GameOrderByWithAggregationInput | GameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _avg?: GameAvgAggregateInputType
    _sum?: GameSumAggregateInputType
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: string
    name: string
    cover: string | null
    firstReleaseDate: Date | null
    genres: JsonValue | null
    platforms: JsonValue | null
    summary: string | null
    rating: number | null
    developer: string | null
    developers: JsonValue | null
    publisher: string | null
    publishers: JsonValue | null
    steamData: JsonValue | null
    igdbData: JsonValue | null
    hltbData: JsonValue | null
    metacriticData: JsonValue | null
    cachedAt: Date
    lastAccessed: Date
    accessCount: number
    coverKey: string | null
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cover?: boolean
    firstReleaseDate?: boolean
    genres?: boolean
    platforms?: boolean
    summary?: boolean
    rating?: boolean
    developer?: boolean
    developers?: boolean
    publisher?: boolean
    publishers?: boolean
    steamData?: boolean
    igdbData?: boolean
    hltbData?: boolean
    metacriticData?: boolean
    cachedAt?: boolean
    lastAccessed?: boolean
    accessCount?: boolean
    coverKey?: boolean
    campaigns?: boolean | Game$campaignsArgs<ExtArgs>
    sessions?: boolean | Game$sessionsArgs<ExtArgs>
    libraryEntries?: boolean | Game$libraryEntriesArgs<ExtArgs>
    session_history?: boolean | Game$session_historyArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cover?: boolean
    firstReleaseDate?: boolean
    genres?: boolean
    platforms?: boolean
    summary?: boolean
    rating?: boolean
    developer?: boolean
    developers?: boolean
    publisher?: boolean
    publishers?: boolean
    steamData?: boolean
    igdbData?: boolean
    hltbData?: boolean
    metacriticData?: boolean
    cachedAt?: boolean
    lastAccessed?: boolean
    accessCount?: boolean
    coverKey?: boolean
  }, ExtArgs["result"]["game"]>

  export type GameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cover?: boolean
    firstReleaseDate?: boolean
    genres?: boolean
    platforms?: boolean
    summary?: boolean
    rating?: boolean
    developer?: boolean
    developers?: boolean
    publisher?: boolean
    publishers?: boolean
    steamData?: boolean
    igdbData?: boolean
    hltbData?: boolean
    metacriticData?: boolean
    cachedAt?: boolean
    lastAccessed?: boolean
    accessCount?: boolean
    coverKey?: boolean
  }, ExtArgs["result"]["game"]>

  export type GameSelectScalar = {
    id?: boolean
    name?: boolean
    cover?: boolean
    firstReleaseDate?: boolean
    genres?: boolean
    platforms?: boolean
    summary?: boolean
    rating?: boolean
    developer?: boolean
    developers?: boolean
    publisher?: boolean
    publishers?: boolean
    steamData?: boolean
    igdbData?: boolean
    hltbData?: boolean
    metacriticData?: boolean
    cachedAt?: boolean
    lastAccessed?: boolean
    accessCount?: boolean
    coverKey?: boolean
  }

  export type GameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "cover" | "firstReleaseDate" | "genres" | "platforms" | "summary" | "rating" | "developer" | "developers" | "publisher" | "publishers" | "steamData" | "igdbData" | "hltbData" | "metacriticData" | "cachedAt" | "lastAccessed" | "accessCount" | "coverKey", ExtArgs["result"]["game"]>
  export type GameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | Game$campaignsArgs<ExtArgs>
    sessions?: boolean | Game$sessionsArgs<ExtArgs>
    libraryEntries?: boolean | Game$libraryEntriesArgs<ExtArgs>
    session_history?: boolean | Game$session_historyArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Game"
    objects: {
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      sessions: Prisma.$GameSessionPayload<ExtArgs>[]
      libraryEntries: Prisma.$LibraryEntryPayload<ExtArgs>[]
      session_history: Prisma.$session_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      cover: string | null
      firstReleaseDate: Date | null
      genres: Prisma.JsonValue | null
      platforms: Prisma.JsonValue | null
      summary: string | null
      rating: number | null
      developer: string | null
      developers: Prisma.JsonValue | null
      publisher: string | null
      publishers: Prisma.JsonValue | null
      steamData: Prisma.JsonValue | null
      igdbData: Prisma.JsonValue | null
      hltbData: Prisma.JsonValue | null
      metacriticData: Prisma.JsonValue | null
      cachedAt: Date
      lastAccessed: Date
      accessCount: number
      coverKey: string | null
    }, ExtArgs["result"]["game"]>
    composites: {}
  }

  type GameGetPayload<S extends boolean | null | undefined | GameDefaultArgs> = $Result.GetResult<Prisma.$GamePayload, S>

  type GameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface GameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Game'], meta: { name: 'Game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameFindUniqueArgs>(args: SelectSubset<T, GameFindUniqueArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs>(args: SelectSubset<T, GameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameFindFirstArgs>(args?: SelectSubset<T, GameFindFirstArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs>(args?: SelectSubset<T, GameFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameFindManyArgs>(args?: SelectSubset<T, GameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
     */
    create<T extends GameCreateArgs>(args: SelectSubset<T, GameCreateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Games.
     * @param {GameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCreateManyArgs>(args?: SelectSubset<T, GameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Games and returns the data saved in the database.
     * @param {GameCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
     */
    delete<T extends GameDeleteArgs>(args: SelectSubset<T, GameDeleteArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameUpdateArgs>(args: SelectSubset<T, GameUpdateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameDeleteManyArgs>(args?: SelectSubset<T, GameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameUpdateManyArgs>(args: SelectSubset<T, GameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games and returns the data updated in the database.
     * @param {GameUpdateManyAndReturnArgs} args - Arguments to update many Games.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameUpdateManyAndReturnArgs>(args: SelectSubset<T, GameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends GameUpsertArgs>(args: SelectSubset<T, GameUpsertArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Game model
   */
  readonly fields: GameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends Game$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Game$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends Game$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Game$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    libraryEntries<T extends Game$libraryEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Game$libraryEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    session_history<T extends Game$session_historyArgs<ExtArgs> = {}>(args?: Subset<T, Game$session_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Game model
   */
  interface GameFieldRefs {
    readonly id: FieldRef<"Game", 'String'>
    readonly name: FieldRef<"Game", 'String'>
    readonly cover: FieldRef<"Game", 'String'>
    readonly firstReleaseDate: FieldRef<"Game", 'DateTime'>
    readonly genres: FieldRef<"Game", 'Json'>
    readonly platforms: FieldRef<"Game", 'Json'>
    readonly summary: FieldRef<"Game", 'String'>
    readonly rating: FieldRef<"Game", 'Float'>
    readonly developer: FieldRef<"Game", 'String'>
    readonly developers: FieldRef<"Game", 'Json'>
    readonly publisher: FieldRef<"Game", 'String'>
    readonly publishers: FieldRef<"Game", 'Json'>
    readonly steamData: FieldRef<"Game", 'Json'>
    readonly igdbData: FieldRef<"Game", 'Json'>
    readonly hltbData: FieldRef<"Game", 'Json'>
    readonly metacriticData: FieldRef<"Game", 'Json'>
    readonly cachedAt: FieldRef<"Game", 'DateTime'>
    readonly lastAccessed: FieldRef<"Game", 'DateTime'>
    readonly accessCount: FieldRef<"Game", 'Int'>
    readonly coverKey: FieldRef<"Game", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findFirst
   */
  export type GameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findMany
   */
  export type GameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game create
   */
  export type GameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }

  /**
   * Game createMany
   */
  export type GameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game createManyAndReturn
   */
  export type GameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game update
   */
  export type GameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
  }

  /**
   * Game updateManyAndReturn
   */
  export type GameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
  }

  /**
   * Game upsert
   */
  export type GameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }

  /**
   * Game delete
   */
  export type GameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to delete.
     */
    limit?: number
  }

  /**
   * Game.campaigns
   */
  export type Game$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Game.sessions
   */
  export type Game$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    where?: GameSessionWhereInput
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    cursor?: GameSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * Game.libraryEntries
   */
  export type Game$libraryEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryEntryInclude<ExtArgs> | null
    where?: LibraryEntryWhereInput
    orderBy?: LibraryEntryOrderByWithRelationInput | LibraryEntryOrderByWithRelationInput[]
    cursor?: LibraryEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LibraryEntryScalarFieldEnum | LibraryEntryScalarFieldEnum[]
  }

  /**
   * Game.session_history
   */
  export type Game$session_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_history
     */
    select?: session_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_history
     */
    omit?: session_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_historyInclude<ExtArgs> | null
    where?: session_historyWhereInput
    orderBy?: session_historyOrderByWithRelationInput | session_historyOrderByWithRelationInput[]
    cursor?: session_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Session_historyScalarFieldEnum | Session_historyScalarFieldEnum[]
  }

  /**
   * Game without action
   */
  export type GameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
  }


  /**
   * Model LibraryEntry
   */

  export type AggregateLibraryEntry = {
    _count: LibraryEntryCountAggregateOutputType | null
    _avg: LibraryEntryAvgAggregateOutputType | null
    _sum: LibraryEntrySumAggregateOutputType | null
    _min: LibraryEntryMinAggregateOutputType | null
    _max: LibraryEntryMaxAggregateOutputType | null
  }

  export type LibraryEntryAvgAggregateOutputType = {
    playtime: number | null
    rating: number | null
    progress: number | null
    priority: number | null
  }

  export type LibraryEntrySumAggregateOutputType = {
    playtime: number | null
    rating: number | null
    progress: number | null
    priority: number | null
  }

  export type LibraryEntryMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    category: string | null
    playtime: number | null
    rating: number | null
    notes: string | null
    lastPlayed: Date | null
    progress: number | null
    addedAt: Date | null
    isPublic: boolean | null
    updatedAt: Date | null
    userId: string | null
    priority: number | null
  }

  export type LibraryEntryMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    category: string | null
    playtime: number | null
    rating: number | null
    notes: string | null
    lastPlayed: Date | null
    progress: number | null
    addedAt: Date | null
    isPublic: boolean | null
    updatedAt: Date | null
    userId: string | null
    priority: number | null
  }

  export type LibraryEntryCountAggregateOutputType = {
    id: number
    gameId: number
    category: number
    playtime: number
    rating: number
    notes: number
    lastPlayed: number
    progress: number
    addedAt: number
    isPublic: number
    tags: number
    updatedAt: number
    userId: number
    priority: number
    _all: number
  }


  export type LibraryEntryAvgAggregateInputType = {
    playtime?: true
    rating?: true
    progress?: true
    priority?: true
  }

  export type LibraryEntrySumAggregateInputType = {
    playtime?: true
    rating?: true
    progress?: true
    priority?: true
  }

  export type LibraryEntryMinAggregateInputType = {
    id?: true
    gameId?: true
    category?: true
    playtime?: true
    rating?: true
    notes?: true
    lastPlayed?: true
    progress?: true
    addedAt?: true
    isPublic?: true
    updatedAt?: true
    userId?: true
    priority?: true
  }

  export type LibraryEntryMaxAggregateInputType = {
    id?: true
    gameId?: true
    category?: true
    playtime?: true
    rating?: true
    notes?: true
    lastPlayed?: true
    progress?: true
    addedAt?: true
    isPublic?: true
    updatedAt?: true
    userId?: true
    priority?: true
  }

  export type LibraryEntryCountAggregateInputType = {
    id?: true
    gameId?: true
    category?: true
    playtime?: true
    rating?: true
    notes?: true
    lastPlayed?: true
    progress?: true
    addedAt?: true
    isPublic?: true
    tags?: true
    updatedAt?: true
    userId?: true
    priority?: true
    _all?: true
  }

  export type LibraryEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LibraryEntry to aggregate.
     */
    where?: LibraryEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryEntries to fetch.
     */
    orderBy?: LibraryEntryOrderByWithRelationInput | LibraryEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryEntries
    **/
    _count?: true | LibraryEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryEntryMaxAggregateInputType
  }

  export type GetLibraryEntryAggregateType<T extends LibraryEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryEntry[P]>
      : GetScalarType<T[P], AggregateLibraryEntry[P]>
  }




  export type LibraryEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LibraryEntryWhereInput
    orderBy?: LibraryEntryOrderByWithAggregationInput | LibraryEntryOrderByWithAggregationInput[]
    by: LibraryEntryScalarFieldEnum[] | LibraryEntryScalarFieldEnum
    having?: LibraryEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryEntryCountAggregateInputType | true
    _avg?: LibraryEntryAvgAggregateInputType
    _sum?: LibraryEntrySumAggregateInputType
    _min?: LibraryEntryMinAggregateInputType
    _max?: LibraryEntryMaxAggregateInputType
  }

  export type LibraryEntryGroupByOutputType = {
    id: string
    gameId: string
    category: string
    playtime: number
    rating: number | null
    notes: string | null
    lastPlayed: Date | null
    progress: number
    addedAt: Date
    isPublic: boolean
    tags: JsonValue | null
    updatedAt: Date
    userId: string
    priority: number
    _count: LibraryEntryCountAggregateOutputType | null
    _avg: LibraryEntryAvgAggregateOutputType | null
    _sum: LibraryEntrySumAggregateOutputType | null
    _min: LibraryEntryMinAggregateOutputType | null
    _max: LibraryEntryMaxAggregateOutputType | null
  }

  type GetLibraryEntryGroupByPayload<T extends LibraryEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LibraryEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryEntryGroupByOutputType[P]>
        }
      >
    >


  export type LibraryEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    category?: boolean
    playtime?: boolean
    rating?: boolean
    notes?: boolean
    lastPlayed?: boolean
    progress?: boolean
    addedAt?: boolean
    isPublic?: boolean
    tags?: boolean
    updatedAt?: boolean
    userId?: boolean
    priority?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["libraryEntry"]>

  export type LibraryEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    category?: boolean
    playtime?: boolean
    rating?: boolean
    notes?: boolean
    lastPlayed?: boolean
    progress?: boolean
    addedAt?: boolean
    isPublic?: boolean
    tags?: boolean
    updatedAt?: boolean
    userId?: boolean
    priority?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["libraryEntry"]>

  export type LibraryEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    category?: boolean
    playtime?: boolean
    rating?: boolean
    notes?: boolean
    lastPlayed?: boolean
    progress?: boolean
    addedAt?: boolean
    isPublic?: boolean
    tags?: boolean
    updatedAt?: boolean
    userId?: boolean
    priority?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["libraryEntry"]>

  export type LibraryEntrySelectScalar = {
    id?: boolean
    gameId?: boolean
    category?: boolean
    playtime?: boolean
    rating?: boolean
    notes?: boolean
    lastPlayed?: boolean
    progress?: boolean
    addedAt?: boolean
    isPublic?: boolean
    tags?: boolean
    updatedAt?: boolean
    userId?: boolean
    priority?: boolean
  }

  export type LibraryEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameId" | "category" | "playtime" | "rating" | "notes" | "lastPlayed" | "progress" | "addedAt" | "isPublic" | "tags" | "updatedAt" | "userId" | "priority", ExtArgs["result"]["libraryEntry"]>
  export type LibraryEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LibraryEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LibraryEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LibraryEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LibraryEntry"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      category: string
      playtime: number
      rating: number | null
      notes: string | null
      lastPlayed: Date | null
      progress: number
      addedAt: Date
      isPublic: boolean
      tags: Prisma.JsonValue | null
      updatedAt: Date
      userId: string
      priority: number
    }, ExtArgs["result"]["libraryEntry"]>
    composites: {}
  }

  type LibraryEntryGetPayload<S extends boolean | null | undefined | LibraryEntryDefaultArgs> = $Result.GetResult<Prisma.$LibraryEntryPayload, S>

  type LibraryEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LibraryEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LibraryEntryCountAggregateInputType | true
    }

  export interface LibraryEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LibraryEntry'], meta: { name: 'LibraryEntry' } }
    /**
     * Find zero or one LibraryEntry that matches the filter.
     * @param {LibraryEntryFindUniqueArgs} args - Arguments to find a LibraryEntry
     * @example
     * // Get one LibraryEntry
     * const libraryEntry = await prisma.libraryEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LibraryEntryFindUniqueArgs>(args: SelectSubset<T, LibraryEntryFindUniqueArgs<ExtArgs>>): Prisma__LibraryEntryClient<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LibraryEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LibraryEntryFindUniqueOrThrowArgs} args - Arguments to find a LibraryEntry
     * @example
     * // Get one LibraryEntry
     * const libraryEntry = await prisma.libraryEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LibraryEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LibraryEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LibraryEntryClient<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LibraryEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryEntryFindFirstArgs} args - Arguments to find a LibraryEntry
     * @example
     * // Get one LibraryEntry
     * const libraryEntry = await prisma.libraryEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LibraryEntryFindFirstArgs>(args?: SelectSubset<T, LibraryEntryFindFirstArgs<ExtArgs>>): Prisma__LibraryEntryClient<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LibraryEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryEntryFindFirstOrThrowArgs} args - Arguments to find a LibraryEntry
     * @example
     * // Get one LibraryEntry
     * const libraryEntry = await prisma.libraryEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LibraryEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LibraryEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LibraryEntryClient<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LibraryEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryEntries
     * const libraryEntries = await prisma.libraryEntry.findMany()
     * 
     * // Get first 10 LibraryEntries
     * const libraryEntries = await prisma.libraryEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryEntryWithIdOnly = await prisma.libraryEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LibraryEntryFindManyArgs>(args?: SelectSubset<T, LibraryEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LibraryEntry.
     * @param {LibraryEntryCreateArgs} args - Arguments to create a LibraryEntry.
     * @example
     * // Create one LibraryEntry
     * const LibraryEntry = await prisma.libraryEntry.create({
     *   data: {
     *     // ... data to create a LibraryEntry
     *   }
     * })
     * 
     */
    create<T extends LibraryEntryCreateArgs>(args: SelectSubset<T, LibraryEntryCreateArgs<ExtArgs>>): Prisma__LibraryEntryClient<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LibraryEntries.
     * @param {LibraryEntryCreateManyArgs} args - Arguments to create many LibraryEntries.
     * @example
     * // Create many LibraryEntries
     * const libraryEntry = await prisma.libraryEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LibraryEntryCreateManyArgs>(args?: SelectSubset<T, LibraryEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LibraryEntries and returns the data saved in the database.
     * @param {LibraryEntryCreateManyAndReturnArgs} args - Arguments to create many LibraryEntries.
     * @example
     * // Create many LibraryEntries
     * const libraryEntry = await prisma.libraryEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LibraryEntries and only return the `id`
     * const libraryEntryWithIdOnly = await prisma.libraryEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LibraryEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LibraryEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LibraryEntry.
     * @param {LibraryEntryDeleteArgs} args - Arguments to delete one LibraryEntry.
     * @example
     * // Delete one LibraryEntry
     * const LibraryEntry = await prisma.libraryEntry.delete({
     *   where: {
     *     // ... filter to delete one LibraryEntry
     *   }
     * })
     * 
     */
    delete<T extends LibraryEntryDeleteArgs>(args: SelectSubset<T, LibraryEntryDeleteArgs<ExtArgs>>): Prisma__LibraryEntryClient<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LibraryEntry.
     * @param {LibraryEntryUpdateArgs} args - Arguments to update one LibraryEntry.
     * @example
     * // Update one LibraryEntry
     * const libraryEntry = await prisma.libraryEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LibraryEntryUpdateArgs>(args: SelectSubset<T, LibraryEntryUpdateArgs<ExtArgs>>): Prisma__LibraryEntryClient<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LibraryEntries.
     * @param {LibraryEntryDeleteManyArgs} args - Arguments to filter LibraryEntries to delete.
     * @example
     * // Delete a few LibraryEntries
     * const { count } = await prisma.libraryEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LibraryEntryDeleteManyArgs>(args?: SelectSubset<T, LibraryEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryEntries
     * const libraryEntry = await prisma.libraryEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LibraryEntryUpdateManyArgs>(args: SelectSubset<T, LibraryEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryEntries and returns the data updated in the database.
     * @param {LibraryEntryUpdateManyAndReturnArgs} args - Arguments to update many LibraryEntries.
     * @example
     * // Update many LibraryEntries
     * const libraryEntry = await prisma.libraryEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LibraryEntries and only return the `id`
     * const libraryEntryWithIdOnly = await prisma.libraryEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LibraryEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, LibraryEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LibraryEntry.
     * @param {LibraryEntryUpsertArgs} args - Arguments to update or create a LibraryEntry.
     * @example
     * // Update or create a LibraryEntry
     * const libraryEntry = await prisma.libraryEntry.upsert({
     *   create: {
     *     // ... data to create a LibraryEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryEntry we want to update
     *   }
     * })
     */
    upsert<T extends LibraryEntryUpsertArgs>(args: SelectSubset<T, LibraryEntryUpsertArgs<ExtArgs>>): Prisma__LibraryEntryClient<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LibraryEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryEntryCountArgs} args - Arguments to filter LibraryEntries to count.
     * @example
     * // Count the number of LibraryEntries
     * const count = await prisma.libraryEntry.count({
     *   where: {
     *     // ... the filter for the LibraryEntries we want to count
     *   }
     * })
    **/
    count<T extends LibraryEntryCountArgs>(
      args?: Subset<T, LibraryEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryEntryAggregateArgs>(args: Subset<T, LibraryEntryAggregateArgs>): Prisma.PrismaPromise<GetLibraryEntryAggregateType<T>>

    /**
     * Group by LibraryEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryEntryGroupByArgs['orderBy'] }
        : { orderBy?: LibraryEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LibraryEntry model
   */
  readonly fields: LibraryEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LibraryEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LibraryEntry model
   */
  interface LibraryEntryFieldRefs {
    readonly id: FieldRef<"LibraryEntry", 'String'>
    readonly gameId: FieldRef<"LibraryEntry", 'String'>
    readonly category: FieldRef<"LibraryEntry", 'String'>
    readonly playtime: FieldRef<"LibraryEntry", 'Int'>
    readonly rating: FieldRef<"LibraryEntry", 'Float'>
    readonly notes: FieldRef<"LibraryEntry", 'String'>
    readonly lastPlayed: FieldRef<"LibraryEntry", 'DateTime'>
    readonly progress: FieldRef<"LibraryEntry", 'Int'>
    readonly addedAt: FieldRef<"LibraryEntry", 'DateTime'>
    readonly isPublic: FieldRef<"LibraryEntry", 'Boolean'>
    readonly tags: FieldRef<"LibraryEntry", 'Json'>
    readonly updatedAt: FieldRef<"LibraryEntry", 'DateTime'>
    readonly userId: FieldRef<"LibraryEntry", 'String'>
    readonly priority: FieldRef<"LibraryEntry", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LibraryEntry findUnique
   */
  export type LibraryEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryEntryInclude<ExtArgs> | null
    /**
     * Filter, which LibraryEntry to fetch.
     */
    where: LibraryEntryWhereUniqueInput
  }

  /**
   * LibraryEntry findUniqueOrThrow
   */
  export type LibraryEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryEntryInclude<ExtArgs> | null
    /**
     * Filter, which LibraryEntry to fetch.
     */
    where: LibraryEntryWhereUniqueInput
  }

  /**
   * LibraryEntry findFirst
   */
  export type LibraryEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryEntryInclude<ExtArgs> | null
    /**
     * Filter, which LibraryEntry to fetch.
     */
    where?: LibraryEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryEntries to fetch.
     */
    orderBy?: LibraryEntryOrderByWithRelationInput | LibraryEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryEntries.
     */
    cursor?: LibraryEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryEntries.
     */
    distinct?: LibraryEntryScalarFieldEnum | LibraryEntryScalarFieldEnum[]
  }

  /**
   * LibraryEntry findFirstOrThrow
   */
  export type LibraryEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryEntryInclude<ExtArgs> | null
    /**
     * Filter, which LibraryEntry to fetch.
     */
    where?: LibraryEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryEntries to fetch.
     */
    orderBy?: LibraryEntryOrderByWithRelationInput | LibraryEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryEntries.
     */
    cursor?: LibraryEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryEntries.
     */
    distinct?: LibraryEntryScalarFieldEnum | LibraryEntryScalarFieldEnum[]
  }

  /**
   * LibraryEntry findMany
   */
  export type LibraryEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryEntryInclude<ExtArgs> | null
    /**
     * Filter, which LibraryEntries to fetch.
     */
    where?: LibraryEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryEntries to fetch.
     */
    orderBy?: LibraryEntryOrderByWithRelationInput | LibraryEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryEntries.
     */
    cursor?: LibraryEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryEntries.
     */
    skip?: number
    distinct?: LibraryEntryScalarFieldEnum | LibraryEntryScalarFieldEnum[]
  }

  /**
   * LibraryEntry create
   */
  export type LibraryEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LibraryEntry.
     */
    data: XOR<LibraryEntryCreateInput, LibraryEntryUncheckedCreateInput>
  }

  /**
   * LibraryEntry createMany
   */
  export type LibraryEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LibraryEntries.
     */
    data: LibraryEntryCreateManyInput | LibraryEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LibraryEntry createManyAndReturn
   */
  export type LibraryEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * The data used to create many LibraryEntries.
     */
    data: LibraryEntryCreateManyInput | LibraryEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LibraryEntry update
   */
  export type LibraryEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LibraryEntry.
     */
    data: XOR<LibraryEntryUpdateInput, LibraryEntryUncheckedUpdateInput>
    /**
     * Choose, which LibraryEntry to update.
     */
    where: LibraryEntryWhereUniqueInput
  }

  /**
   * LibraryEntry updateMany
   */
  export type LibraryEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LibraryEntries.
     */
    data: XOR<LibraryEntryUpdateManyMutationInput, LibraryEntryUncheckedUpdateManyInput>
    /**
     * Filter which LibraryEntries to update
     */
    where?: LibraryEntryWhereInput
    /**
     * Limit how many LibraryEntries to update.
     */
    limit?: number
  }

  /**
   * LibraryEntry updateManyAndReturn
   */
  export type LibraryEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * The data used to update LibraryEntries.
     */
    data: XOR<LibraryEntryUpdateManyMutationInput, LibraryEntryUncheckedUpdateManyInput>
    /**
     * Filter which LibraryEntries to update
     */
    where?: LibraryEntryWhereInput
    /**
     * Limit how many LibraryEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LibraryEntry upsert
   */
  export type LibraryEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LibraryEntry to update in case it exists.
     */
    where: LibraryEntryWhereUniqueInput
    /**
     * In case the LibraryEntry found by the `where` argument doesn't exist, create a new LibraryEntry with this data.
     */
    create: XOR<LibraryEntryCreateInput, LibraryEntryUncheckedCreateInput>
    /**
     * In case the LibraryEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryEntryUpdateInput, LibraryEntryUncheckedUpdateInput>
  }

  /**
   * LibraryEntry delete
   */
  export type LibraryEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryEntryInclude<ExtArgs> | null
    /**
     * Filter which LibraryEntry to delete.
     */
    where: LibraryEntryWhereUniqueInput
  }

  /**
   * LibraryEntry deleteMany
   */
  export type LibraryEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LibraryEntries to delete
     */
    where?: LibraryEntryWhereInput
    /**
     * Limit how many LibraryEntries to delete.
     */
    limit?: number
  }

  /**
   * LibraryEntry without action
   */
  export type LibraryEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryEntryInclude<ExtArgs> | null
  }


  /**
   * Model UserPreferences
   */

  export type AggregateUserPreferences = {
    _count: UserPreferencesCountAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  export type UserPreferencesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    preferredPlatform: string | null
    preferredStatus: string | null
    includeDLCs: boolean | null
    preferredVersion: string | null
    autoLoadHLTB: boolean | null
    autoLoadMetacritic: boolean | null
    autoGenerateCampaigns: boolean | null
  }

  export type UserPreferencesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    preferredPlatform: string | null
    preferredStatus: string | null
    includeDLCs: boolean | null
    preferredVersion: string | null
    autoLoadHLTB: boolean | null
    autoLoadMetacritic: boolean | null
    autoGenerateCampaigns: boolean | null
  }

  export type UserPreferencesCountAggregateOutputType = {
    id: number
    userId: number
    preferredPlatform: number
    preferredStatus: number
    includeDLCs: number
    selectedDLCs: number
    selectedCampaigns: number
    preferredVersion: number
    gameSpecificPrefs: number
    autoLoadHLTB: number
    autoLoadMetacritic: number
    autoGenerateCampaigns: number
    _all: number
  }


  export type UserPreferencesMinAggregateInputType = {
    id?: true
    userId?: true
    preferredPlatform?: true
    preferredStatus?: true
    includeDLCs?: true
    preferredVersion?: true
    autoLoadHLTB?: true
    autoLoadMetacritic?: true
    autoGenerateCampaigns?: true
  }

  export type UserPreferencesMaxAggregateInputType = {
    id?: true
    userId?: true
    preferredPlatform?: true
    preferredStatus?: true
    includeDLCs?: true
    preferredVersion?: true
    autoLoadHLTB?: true
    autoLoadMetacritic?: true
    autoGenerateCampaigns?: true
  }

  export type UserPreferencesCountAggregateInputType = {
    id?: true
    userId?: true
    preferredPlatform?: true
    preferredStatus?: true
    includeDLCs?: true
    selectedDLCs?: true
    selectedCampaigns?: true
    preferredVersion?: true
    gameSpecificPrefs?: true
    autoLoadHLTB?: true
    autoLoadMetacritic?: true
    autoGenerateCampaigns?: true
    _all?: true
  }

  export type UserPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to aggregate.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferences
    **/
    _count?: true | UserPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type GetUserPreferencesAggregateType<T extends UserPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreferences[P]>
      : GetScalarType<T[P], AggregateUserPreferences[P]>
  }




  export type UserPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferencesWhereInput
    orderBy?: UserPreferencesOrderByWithAggregationInput | UserPreferencesOrderByWithAggregationInput[]
    by: UserPreferencesScalarFieldEnum[] | UserPreferencesScalarFieldEnum
    having?: UserPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPreferencesCountAggregateInputType | true
    _min?: UserPreferencesMinAggregateInputType
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type UserPreferencesGroupByOutputType = {
    id: string
    userId: string
    preferredPlatform: string | null
    preferredStatus: string
    includeDLCs: boolean
    selectedDLCs: JsonValue | null
    selectedCampaigns: JsonValue | null
    preferredVersion: string | null
    gameSpecificPrefs: JsonValue | null
    autoLoadHLTB: boolean
    autoLoadMetacritic: boolean
    autoGenerateCampaigns: boolean
    _count: UserPreferencesCountAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  type GetUserPreferencesGroupByPayload<T extends UserPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    preferredPlatform?: boolean
    preferredStatus?: boolean
    includeDLCs?: boolean
    selectedDLCs?: boolean
    selectedCampaigns?: boolean
    preferredVersion?: boolean
    gameSpecificPrefs?: boolean
    autoLoadHLTB?: boolean
    autoLoadMetacritic?: boolean
    autoGenerateCampaigns?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    preferredPlatform?: boolean
    preferredStatus?: boolean
    includeDLCs?: boolean
    selectedDLCs?: boolean
    selectedCampaigns?: boolean
    preferredVersion?: boolean
    gameSpecificPrefs?: boolean
    autoLoadHLTB?: boolean
    autoLoadMetacritic?: boolean
    autoGenerateCampaigns?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    preferredPlatform?: boolean
    preferredStatus?: boolean
    includeDLCs?: boolean
    selectedDLCs?: boolean
    selectedCampaigns?: boolean
    preferredVersion?: boolean
    gameSpecificPrefs?: boolean
    autoLoadHLTB?: boolean
    autoLoadMetacritic?: boolean
    autoGenerateCampaigns?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectScalar = {
    id?: boolean
    userId?: boolean
    preferredPlatform?: boolean
    preferredStatus?: boolean
    includeDLCs?: boolean
    selectedDLCs?: boolean
    selectedCampaigns?: boolean
    preferredVersion?: boolean
    gameSpecificPrefs?: boolean
    autoLoadHLTB?: boolean
    autoLoadMetacritic?: boolean
    autoGenerateCampaigns?: boolean
  }

  export type UserPreferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "preferredPlatform" | "preferredStatus" | "includeDLCs" | "selectedDLCs" | "selectedCampaigns" | "preferredVersion" | "gameSpecificPrefs" | "autoLoadHLTB" | "autoLoadMetacritic" | "autoGenerateCampaigns", ExtArgs["result"]["userPreferences"]>
  export type UserPreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPreferences"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      preferredPlatform: string | null
      preferredStatus: string
      includeDLCs: boolean
      selectedDLCs: Prisma.JsonValue | null
      selectedCampaigns: Prisma.JsonValue | null
      preferredVersion: string | null
      gameSpecificPrefs: Prisma.JsonValue | null
      autoLoadHLTB: boolean
      autoLoadMetacritic: boolean
      autoGenerateCampaigns: boolean
    }, ExtArgs["result"]["userPreferences"]>
    composites: {}
  }

  type UserPreferencesGetPayload<S extends boolean | null | undefined | UserPreferencesDefaultArgs> = $Result.GetResult<Prisma.$UserPreferencesPayload, S>

  type UserPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPreferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPreferencesCountAggregateInputType | true
    }

  export interface UserPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreferences'], meta: { name: 'UserPreferences' } }
    /**
     * Find zero or one UserPreferences that matches the filter.
     * @param {UserPreferencesFindUniqueArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPreferencesFindUniqueArgs>(args: SelectSubset<T, UserPreferencesFindUniqueArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPreferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPreferencesFindUniqueOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPreferencesFindFirstArgs>(args?: SelectSubset<T, UserPreferencesFindFirstArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany()
     * 
     * // Get first 10 UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPreferencesFindManyArgs>(args?: SelectSubset<T, UserPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPreferences.
     * @param {UserPreferencesCreateArgs} args - Arguments to create a UserPreferences.
     * @example
     * // Create one UserPreferences
     * const UserPreferences = await prisma.userPreferences.create({
     *   data: {
     *     // ... data to create a UserPreferences
     *   }
     * })
     * 
     */
    create<T extends UserPreferencesCreateArgs>(args: SelectSubset<T, UserPreferencesCreateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPreferences.
     * @param {UserPreferencesCreateManyArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPreferencesCreateManyArgs>(args?: SelectSubset<T, UserPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPreferences and returns the data saved in the database.
     * @param {UserPreferencesCreateManyAndReturnArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPreferences.
     * @param {UserPreferencesDeleteArgs} args - Arguments to delete one UserPreferences.
     * @example
     * // Delete one UserPreferences
     * const UserPreferences = await prisma.userPreferences.delete({
     *   where: {
     *     // ... filter to delete one UserPreferences
     *   }
     * })
     * 
     */
    delete<T extends UserPreferencesDeleteArgs>(args: SelectSubset<T, UserPreferencesDeleteArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPreferences.
     * @param {UserPreferencesUpdateArgs} args - Arguments to update one UserPreferences.
     * @example
     * // Update one UserPreferences
     * const userPreferences = await prisma.userPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPreferencesUpdateArgs>(args: SelectSubset<T, UserPreferencesUpdateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPreferences.
     * @param {UserPreferencesDeleteManyArgs} args - Arguments to filter UserPreferences to delete.
     * @example
     * // Delete a few UserPreferences
     * const { count } = await prisma.userPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPreferencesDeleteManyArgs>(args?: SelectSubset<T, UserPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPreferencesUpdateManyArgs>(args: SelectSubset<T, UserPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences and returns the data updated in the database.
     * @param {UserPreferencesUpdateManyAndReturnArgs} args - Arguments to update many UserPreferences.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPreferencesUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPreferencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPreferences.
     * @param {UserPreferencesUpsertArgs} args - Arguments to update or create a UserPreferences.
     * @example
     * // Update or create a UserPreferences
     * const userPreferences = await prisma.userPreferences.upsert({
     *   create: {
     *     // ... data to create a UserPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreferences we want to update
     *   }
     * })
     */
    upsert<T extends UserPreferencesUpsertArgs>(args: SelectSubset<T, UserPreferencesUpsertArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesCountArgs} args - Arguments to filter UserPreferences to count.
     * @example
     * // Count the number of UserPreferences
     * const count = await prisma.userPreferences.count({
     *   where: {
     *     // ... the filter for the UserPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserPreferencesCountArgs>(
      args?: Subset<T, UserPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferencesAggregateArgs>(args: Subset<T, UserPreferencesAggregateArgs>): Prisma.PrismaPromise<GetUserPreferencesAggregateType<T>>

    /**
     * Group by UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreferences model
   */
  readonly fields: UserPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPreferences model
   */
  interface UserPreferencesFieldRefs {
    readonly id: FieldRef<"UserPreferences", 'String'>
    readonly userId: FieldRef<"UserPreferences", 'String'>
    readonly preferredPlatform: FieldRef<"UserPreferences", 'String'>
    readonly preferredStatus: FieldRef<"UserPreferences", 'String'>
    readonly includeDLCs: FieldRef<"UserPreferences", 'Boolean'>
    readonly selectedDLCs: FieldRef<"UserPreferences", 'Json'>
    readonly selectedCampaigns: FieldRef<"UserPreferences", 'Json'>
    readonly preferredVersion: FieldRef<"UserPreferences", 'String'>
    readonly gameSpecificPrefs: FieldRef<"UserPreferences", 'Json'>
    readonly autoLoadHLTB: FieldRef<"UserPreferences", 'Boolean'>
    readonly autoLoadMetacritic: FieldRef<"UserPreferences", 'Boolean'>
    readonly autoGenerateCampaigns: FieldRef<"UserPreferences", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UserPreferences findUnique
   */
  export type UserPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findUniqueOrThrow
   */
  export type UserPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findFirst
   */
  export type UserPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findFirstOrThrow
   */
  export type UserPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findMany
   */
  export type UserPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences create
   */
  export type UserPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreferences.
     */
    data: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
  }

  /**
   * UserPreferences createMany
   */
  export type UserPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPreferences createManyAndReturn
   */
  export type UserPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences update
   */
  export type UserPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreferences.
     */
    data: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
    /**
     * Choose, which UserPreferences to update.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences updateMany
   */
  export type UserPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
  }

  /**
   * UserPreferences updateManyAndReturn
   */
  export type UserPreferencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences upsert
   */
  export type UserPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreferences to update in case it exists.
     */
    where: UserPreferencesWhereUniqueInput
    /**
     * In case the UserPreferences found by the `where` argument doesn't exist, create a new UserPreferences with this data.
     */
    create: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
    /**
     * In case the UserPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
  }

  /**
   * UserPreferences delete
   */
  export type UserPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter which UserPreferences to delete.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences deleteMany
   */
  export type UserPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to delete
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to delete.
     */
    limit?: number
  }

  /**
   * UserPreferences without action
   */
  export type UserPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
  }


  /**
   * Model GameSession
   */

  export type AggregateGameSession = {
    _count: GameSessionCountAggregateOutputType | null
    _avg: GameSessionAvgAggregateOutputType | null
    _sum: GameSessionSumAggregateOutputType | null
    _min: GameSessionMinAggregateOutputType | null
    _max: GameSessionMaxAggregateOutputType | null
  }

  export type GameSessionAvgAggregateOutputType = {
    playtime: number | null
  }

  export type GameSessionSumAggregateOutputType = {
    playtime: number | null
  }

  export type GameSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    gameId: string | null
    gameName: string | null
    startTime: Date | null
    endTime: Date | null
    playtime: number | null
    isActive: boolean | null
    platform: string | null
    status: string | null
  }

  export type GameSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    gameId: string | null
    gameName: string | null
    startTime: Date | null
    endTime: Date | null
    playtime: number | null
    isActive: boolean | null
    platform: string | null
    status: string | null
  }

  export type GameSessionCountAggregateOutputType = {
    id: number
    userId: number
    gameId: number
    gameName: number
    startTime: number
    endTime: number
    playtime: number
    isActive: number
    campaigns: number
    platform: number
    status: number
    _all: number
  }


  export type GameSessionAvgAggregateInputType = {
    playtime?: true
  }

  export type GameSessionSumAggregateInputType = {
    playtime?: true
  }

  export type GameSessionMinAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    gameName?: true
    startTime?: true
    endTime?: true
    playtime?: true
    isActive?: true
    platform?: true
    status?: true
  }

  export type GameSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    gameName?: true
    startTime?: true
    endTime?: true
    playtime?: true
    isActive?: true
    platform?: true
    status?: true
  }

  export type GameSessionCountAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    gameName?: true
    startTime?: true
    endTime?: true
    playtime?: true
    isActive?: true
    campaigns?: true
    platform?: true
    status?: true
    _all?: true
  }

  export type GameSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameSession to aggregate.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameSessions
    **/
    _count?: true | GameSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameSessionMaxAggregateInputType
  }

  export type GetGameSessionAggregateType<T extends GameSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateGameSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameSession[P]>
      : GetScalarType<T[P], AggregateGameSession[P]>
  }




  export type GameSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameSessionWhereInput
    orderBy?: GameSessionOrderByWithAggregationInput | GameSessionOrderByWithAggregationInput[]
    by: GameSessionScalarFieldEnum[] | GameSessionScalarFieldEnum
    having?: GameSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameSessionCountAggregateInputType | true
    _avg?: GameSessionAvgAggregateInputType
    _sum?: GameSessionSumAggregateInputType
    _min?: GameSessionMinAggregateInputType
    _max?: GameSessionMaxAggregateInputType
  }

  export type GameSessionGroupByOutputType = {
    id: string
    userId: string
    gameId: string
    gameName: string
    startTime: Date
    endTime: Date | null
    playtime: number
    isActive: boolean
    campaigns: JsonValue | null
    platform: string | null
    status: string | null
    _count: GameSessionCountAggregateOutputType | null
    _avg: GameSessionAvgAggregateOutputType | null
    _sum: GameSessionSumAggregateOutputType | null
    _min: GameSessionMinAggregateOutputType | null
    _max: GameSessionMaxAggregateOutputType | null
  }

  type GetGameSessionGroupByPayload<T extends GameSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameSessionGroupByOutputType[P]>
            : GetScalarType<T[P], GameSessionGroupByOutputType[P]>
        }
      >
    >


  export type GameSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    gameName?: boolean
    startTime?: boolean
    endTime?: boolean
    playtime?: boolean
    isActive?: boolean
    campaigns?: boolean
    platform?: boolean
    status?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameSession"]>

  export type GameSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    gameName?: boolean
    startTime?: boolean
    endTime?: boolean
    playtime?: boolean
    isActive?: boolean
    campaigns?: boolean
    platform?: boolean
    status?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameSession"]>

  export type GameSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    gameName?: boolean
    startTime?: boolean
    endTime?: boolean
    playtime?: boolean
    isActive?: boolean
    campaigns?: boolean
    platform?: boolean
    status?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameSession"]>

  export type GameSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    gameId?: boolean
    gameName?: boolean
    startTime?: boolean
    endTime?: boolean
    playtime?: boolean
    isActive?: boolean
    campaigns?: boolean
    platform?: boolean
    status?: boolean
  }

  export type GameSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "gameId" | "gameName" | "startTime" | "endTime" | "playtime" | "isActive" | "campaigns" | "platform" | "status", ExtArgs["result"]["gameSession"]>
  export type GameSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GameSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GameSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GameSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameSession"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      gameId: string
      gameName: string
      startTime: Date
      endTime: Date | null
      playtime: number
      isActive: boolean
      campaigns: Prisma.JsonValue | null
      platform: string | null
      status: string | null
    }, ExtArgs["result"]["gameSession"]>
    composites: {}
  }

  type GameSessionGetPayload<S extends boolean | null | undefined | GameSessionDefaultArgs> = $Result.GetResult<Prisma.$GameSessionPayload, S>

  type GameSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameSessionCountAggregateInputType | true
    }

  export interface GameSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameSession'], meta: { name: 'GameSession' } }
    /**
     * Find zero or one GameSession that matches the filter.
     * @param {GameSessionFindUniqueArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameSessionFindUniqueArgs>(args: SelectSubset<T, GameSessionFindUniqueArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameSessionFindUniqueOrThrowArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, GameSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionFindFirstArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameSessionFindFirstArgs>(args?: SelectSubset<T, GameSessionFindFirstArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionFindFirstOrThrowArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, GameSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameSessions
     * const gameSessions = await prisma.gameSession.findMany()
     * 
     * // Get first 10 GameSessions
     * const gameSessions = await prisma.gameSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameSessionWithIdOnly = await prisma.gameSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameSessionFindManyArgs>(args?: SelectSubset<T, GameSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameSession.
     * @param {GameSessionCreateArgs} args - Arguments to create a GameSession.
     * @example
     * // Create one GameSession
     * const GameSession = await prisma.gameSession.create({
     *   data: {
     *     // ... data to create a GameSession
     *   }
     * })
     * 
     */
    create<T extends GameSessionCreateArgs>(args: SelectSubset<T, GameSessionCreateArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameSessions.
     * @param {GameSessionCreateManyArgs} args - Arguments to create many GameSessions.
     * @example
     * // Create many GameSessions
     * const gameSession = await prisma.gameSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameSessionCreateManyArgs>(args?: SelectSubset<T, GameSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameSessions and returns the data saved in the database.
     * @param {GameSessionCreateManyAndReturnArgs} args - Arguments to create many GameSessions.
     * @example
     * // Create many GameSessions
     * const gameSession = await prisma.gameSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameSessions and only return the `id`
     * const gameSessionWithIdOnly = await prisma.gameSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, GameSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameSession.
     * @param {GameSessionDeleteArgs} args - Arguments to delete one GameSession.
     * @example
     * // Delete one GameSession
     * const GameSession = await prisma.gameSession.delete({
     *   where: {
     *     // ... filter to delete one GameSession
     *   }
     * })
     * 
     */
    delete<T extends GameSessionDeleteArgs>(args: SelectSubset<T, GameSessionDeleteArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameSession.
     * @param {GameSessionUpdateArgs} args - Arguments to update one GameSession.
     * @example
     * // Update one GameSession
     * const gameSession = await prisma.gameSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameSessionUpdateArgs>(args: SelectSubset<T, GameSessionUpdateArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameSessions.
     * @param {GameSessionDeleteManyArgs} args - Arguments to filter GameSessions to delete.
     * @example
     * // Delete a few GameSessions
     * const { count } = await prisma.gameSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameSessionDeleteManyArgs>(args?: SelectSubset<T, GameSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameSessions
     * const gameSession = await prisma.gameSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameSessionUpdateManyArgs>(args: SelectSubset<T, GameSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameSessions and returns the data updated in the database.
     * @param {GameSessionUpdateManyAndReturnArgs} args - Arguments to update many GameSessions.
     * @example
     * // Update many GameSessions
     * const gameSession = await prisma.gameSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameSessions and only return the `id`
     * const gameSessionWithIdOnly = await prisma.gameSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, GameSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameSession.
     * @param {GameSessionUpsertArgs} args - Arguments to update or create a GameSession.
     * @example
     * // Update or create a GameSession
     * const gameSession = await prisma.gameSession.upsert({
     *   create: {
     *     // ... data to create a GameSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameSession we want to update
     *   }
     * })
     */
    upsert<T extends GameSessionUpsertArgs>(args: SelectSubset<T, GameSessionUpsertArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionCountArgs} args - Arguments to filter GameSessions to count.
     * @example
     * // Count the number of GameSessions
     * const count = await prisma.gameSession.count({
     *   where: {
     *     // ... the filter for the GameSessions we want to count
     *   }
     * })
    **/
    count<T extends GameSessionCountArgs>(
      args?: Subset<T, GameSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameSessionAggregateArgs>(args: Subset<T, GameSessionAggregateArgs>): Prisma.PrismaPromise<GetGameSessionAggregateType<T>>

    /**
     * Group by GameSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameSessionGroupByArgs['orderBy'] }
        : { orderBy?: GameSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameSession model
   */
  readonly fields: GameSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameSession model
   */
  interface GameSessionFieldRefs {
    readonly id: FieldRef<"GameSession", 'String'>
    readonly userId: FieldRef<"GameSession", 'String'>
    readonly gameId: FieldRef<"GameSession", 'String'>
    readonly gameName: FieldRef<"GameSession", 'String'>
    readonly startTime: FieldRef<"GameSession", 'DateTime'>
    readonly endTime: FieldRef<"GameSession", 'DateTime'>
    readonly playtime: FieldRef<"GameSession", 'Int'>
    readonly isActive: FieldRef<"GameSession", 'Boolean'>
    readonly campaigns: FieldRef<"GameSession", 'Json'>
    readonly platform: FieldRef<"GameSession", 'String'>
    readonly status: FieldRef<"GameSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GameSession findUnique
   */
  export type GameSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession findUniqueOrThrow
   */
  export type GameSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession findFirst
   */
  export type GameSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameSessions.
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameSessions.
     */
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * GameSession findFirstOrThrow
   */
  export type GameSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameSessions.
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameSessions.
     */
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * GameSession findMany
   */
  export type GameSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSessions to fetch.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameSessions.
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * GameSession create
   */
  export type GameSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a GameSession.
     */
    data: XOR<GameSessionCreateInput, GameSessionUncheckedCreateInput>
  }

  /**
   * GameSession createMany
   */
  export type GameSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameSessions.
     */
    data: GameSessionCreateManyInput | GameSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameSession createManyAndReturn
   */
  export type GameSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * The data used to create many GameSessions.
     */
    data: GameSessionCreateManyInput | GameSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameSession update
   */
  export type GameSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a GameSession.
     */
    data: XOR<GameSessionUpdateInput, GameSessionUncheckedUpdateInput>
    /**
     * Choose, which GameSession to update.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession updateMany
   */
  export type GameSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameSessions.
     */
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyInput>
    /**
     * Filter which GameSessions to update
     */
    where?: GameSessionWhereInput
    /**
     * Limit how many GameSessions to update.
     */
    limit?: number
  }

  /**
   * GameSession updateManyAndReturn
   */
  export type GameSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * The data used to update GameSessions.
     */
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyInput>
    /**
     * Filter which GameSessions to update
     */
    where?: GameSessionWhereInput
    /**
     * Limit how many GameSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameSession upsert
   */
  export type GameSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the GameSession to update in case it exists.
     */
    where: GameSessionWhereUniqueInput
    /**
     * In case the GameSession found by the `where` argument doesn't exist, create a new GameSession with this data.
     */
    create: XOR<GameSessionCreateInput, GameSessionUncheckedCreateInput>
    /**
     * In case the GameSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameSessionUpdateInput, GameSessionUncheckedUpdateInput>
  }

  /**
   * GameSession delete
   */
  export type GameSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter which GameSession to delete.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession deleteMany
   */
  export type GameSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameSessions to delete
     */
    where?: GameSessionWhereInput
    /**
     * Limit how many GameSessions to delete.
     */
    limit?: number
  }

  /**
   * GameSession without action
   */
  export type GameSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
  }


  /**
   * Model UserStats
   */

  export type AggregateUserStats = {
    _count: UserStatsCountAggregateOutputType | null
    _avg: UserStatsAvgAggregateOutputType | null
    _sum: UserStatsSumAggregateOutputType | null
    _min: UserStatsMinAggregateOutputType | null
    _max: UserStatsMaxAggregateOutputType | null
  }

  export type UserStatsAvgAggregateOutputType = {
    totalPlayTime: number | null
    totalSessions: number | null
    gamesPlayed: number | null
    gamesCompleted: number | null
  }

  export type UserStatsSumAggregateOutputType = {
    totalPlayTime: number | null
    totalSessions: number | null
    gamesPlayed: number | null
    gamesCompleted: number | null
  }

  export type UserStatsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    totalPlayTime: number | null
    totalSessions: number | null
    gamesPlayed: number | null
    gamesCompleted: number | null
    lastPlayedGame: string | null
    lastPlayedAt: Date | null
  }

  export type UserStatsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    totalPlayTime: number | null
    totalSessions: number | null
    gamesPlayed: number | null
    gamesCompleted: number | null
    lastPlayedGame: string | null
    lastPlayedAt: Date | null
  }

  export type UserStatsCountAggregateOutputType = {
    id: number
    userId: number
    totalPlayTime: number
    totalSessions: number
    gamesPlayed: number
    gamesCompleted: number
    lastPlayedGame: number
    lastPlayedAt: number
    weeklyStats: number
    monthlyStats: number
    achievements: number
    _all: number
  }


  export type UserStatsAvgAggregateInputType = {
    totalPlayTime?: true
    totalSessions?: true
    gamesPlayed?: true
    gamesCompleted?: true
  }

  export type UserStatsSumAggregateInputType = {
    totalPlayTime?: true
    totalSessions?: true
    gamesPlayed?: true
    gamesCompleted?: true
  }

  export type UserStatsMinAggregateInputType = {
    id?: true
    userId?: true
    totalPlayTime?: true
    totalSessions?: true
    gamesPlayed?: true
    gamesCompleted?: true
    lastPlayedGame?: true
    lastPlayedAt?: true
  }

  export type UserStatsMaxAggregateInputType = {
    id?: true
    userId?: true
    totalPlayTime?: true
    totalSessions?: true
    gamesPlayed?: true
    gamesCompleted?: true
    lastPlayedGame?: true
    lastPlayedAt?: true
  }

  export type UserStatsCountAggregateInputType = {
    id?: true
    userId?: true
    totalPlayTime?: true
    totalSessions?: true
    gamesPlayed?: true
    gamesCompleted?: true
    lastPlayedGame?: true
    lastPlayedAt?: true
    weeklyStats?: true
    monthlyStats?: true
    achievements?: true
    _all?: true
  }

  export type UserStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStats to aggregate.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserStats
    **/
    _count?: true | UserStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserStatsMaxAggregateInputType
  }

  export type GetUserStatsAggregateType<T extends UserStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserStats[P]>
      : GetScalarType<T[P], AggregateUserStats[P]>
  }




  export type UserStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStatsWhereInput
    orderBy?: UserStatsOrderByWithAggregationInput | UserStatsOrderByWithAggregationInput[]
    by: UserStatsScalarFieldEnum[] | UserStatsScalarFieldEnum
    having?: UserStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserStatsCountAggregateInputType | true
    _avg?: UserStatsAvgAggregateInputType
    _sum?: UserStatsSumAggregateInputType
    _min?: UserStatsMinAggregateInputType
    _max?: UserStatsMaxAggregateInputType
  }

  export type UserStatsGroupByOutputType = {
    id: string
    userId: string
    totalPlayTime: number
    totalSessions: number
    gamesPlayed: number
    gamesCompleted: number
    lastPlayedGame: string | null
    lastPlayedAt: Date | null
    weeklyStats: JsonValue | null
    monthlyStats: JsonValue | null
    achievements: JsonValue | null
    _count: UserStatsCountAggregateOutputType | null
    _avg: UserStatsAvgAggregateOutputType | null
    _sum: UserStatsSumAggregateOutputType | null
    _min: UserStatsMinAggregateOutputType | null
    _max: UserStatsMaxAggregateOutputType | null
  }

  type GetUserStatsGroupByPayload<T extends UserStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserStatsGroupByOutputType[P]>
            : GetScalarType<T[P], UserStatsGroupByOutputType[P]>
        }
      >
    >


  export type UserStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalPlayTime?: boolean
    totalSessions?: boolean
    gamesPlayed?: boolean
    gamesCompleted?: boolean
    lastPlayedGame?: boolean
    lastPlayedAt?: boolean
    weeklyStats?: boolean
    monthlyStats?: boolean
    achievements?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStats"]>

  export type UserStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalPlayTime?: boolean
    totalSessions?: boolean
    gamesPlayed?: boolean
    gamesCompleted?: boolean
    lastPlayedGame?: boolean
    lastPlayedAt?: boolean
    weeklyStats?: boolean
    monthlyStats?: boolean
    achievements?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStats"]>

  export type UserStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalPlayTime?: boolean
    totalSessions?: boolean
    gamesPlayed?: boolean
    gamesCompleted?: boolean
    lastPlayedGame?: boolean
    lastPlayedAt?: boolean
    weeklyStats?: boolean
    monthlyStats?: boolean
    achievements?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStats"]>

  export type UserStatsSelectScalar = {
    id?: boolean
    userId?: boolean
    totalPlayTime?: boolean
    totalSessions?: boolean
    gamesPlayed?: boolean
    gamesCompleted?: boolean
    lastPlayedGame?: boolean
    lastPlayedAt?: boolean
    weeklyStats?: boolean
    monthlyStats?: boolean
    achievements?: boolean
  }

  export type UserStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "totalPlayTime" | "totalSessions" | "gamesPlayed" | "gamesCompleted" | "lastPlayedGame" | "lastPlayedAt" | "weeklyStats" | "monthlyStats" | "achievements", ExtArgs["result"]["userStats"]>
  export type UserStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserStats"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      totalPlayTime: number
      totalSessions: number
      gamesPlayed: number
      gamesCompleted: number
      lastPlayedGame: string | null
      lastPlayedAt: Date | null
      weeklyStats: Prisma.JsonValue | null
      monthlyStats: Prisma.JsonValue | null
      achievements: Prisma.JsonValue | null
    }, ExtArgs["result"]["userStats"]>
    composites: {}
  }

  type UserStatsGetPayload<S extends boolean | null | undefined | UserStatsDefaultArgs> = $Result.GetResult<Prisma.$UserStatsPayload, S>

  type UserStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserStatsCountAggregateInputType | true
    }

  export interface UserStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserStats'], meta: { name: 'UserStats' } }
    /**
     * Find zero or one UserStats that matches the filter.
     * @param {UserStatsFindUniqueArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserStatsFindUniqueArgs>(args: SelectSubset<T, UserStatsFindUniqueArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserStatsFindUniqueOrThrowArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindFirstArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserStatsFindFirstArgs>(args?: SelectSubset<T, UserStatsFindFirstArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindFirstOrThrowArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserStats
     * const userStats = await prisma.userStats.findMany()
     * 
     * // Get first 10 UserStats
     * const userStats = await prisma.userStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userStatsWithIdOnly = await prisma.userStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserStatsFindManyArgs>(args?: SelectSubset<T, UserStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserStats.
     * @param {UserStatsCreateArgs} args - Arguments to create a UserStats.
     * @example
     * // Create one UserStats
     * const UserStats = await prisma.userStats.create({
     *   data: {
     *     // ... data to create a UserStats
     *   }
     * })
     * 
     */
    create<T extends UserStatsCreateArgs>(args: SelectSubset<T, UserStatsCreateArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserStats.
     * @param {UserStatsCreateManyArgs} args - Arguments to create many UserStats.
     * @example
     * // Create many UserStats
     * const userStats = await prisma.userStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserStatsCreateManyArgs>(args?: SelectSubset<T, UserStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserStats and returns the data saved in the database.
     * @param {UserStatsCreateManyAndReturnArgs} args - Arguments to create many UserStats.
     * @example
     * // Create many UserStats
     * const userStats = await prisma.userStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserStats and only return the `id`
     * const userStatsWithIdOnly = await prisma.userStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserStats.
     * @param {UserStatsDeleteArgs} args - Arguments to delete one UserStats.
     * @example
     * // Delete one UserStats
     * const UserStats = await prisma.userStats.delete({
     *   where: {
     *     // ... filter to delete one UserStats
     *   }
     * })
     * 
     */
    delete<T extends UserStatsDeleteArgs>(args: SelectSubset<T, UserStatsDeleteArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserStats.
     * @param {UserStatsUpdateArgs} args - Arguments to update one UserStats.
     * @example
     * // Update one UserStats
     * const userStats = await prisma.userStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserStatsUpdateArgs>(args: SelectSubset<T, UserStatsUpdateArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserStats.
     * @param {UserStatsDeleteManyArgs} args - Arguments to filter UserStats to delete.
     * @example
     * // Delete a few UserStats
     * const { count } = await prisma.userStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserStatsDeleteManyArgs>(args?: SelectSubset<T, UserStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserStats
     * const userStats = await prisma.userStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserStatsUpdateManyArgs>(args: SelectSubset<T, UserStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStats and returns the data updated in the database.
     * @param {UserStatsUpdateManyAndReturnArgs} args - Arguments to update many UserStats.
     * @example
     * // Update many UserStats
     * const userStats = await prisma.userStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserStats and only return the `id`
     * const userStatsWithIdOnly = await prisma.userStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserStats.
     * @param {UserStatsUpsertArgs} args - Arguments to update or create a UserStats.
     * @example
     * // Update or create a UserStats
     * const userStats = await prisma.userStats.upsert({
     *   create: {
     *     // ... data to create a UserStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserStats we want to update
     *   }
     * })
     */
    upsert<T extends UserStatsUpsertArgs>(args: SelectSubset<T, UserStatsUpsertArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsCountArgs} args - Arguments to filter UserStats to count.
     * @example
     * // Count the number of UserStats
     * const count = await prisma.userStats.count({
     *   where: {
     *     // ... the filter for the UserStats we want to count
     *   }
     * })
    **/
    count<T extends UserStatsCountArgs>(
      args?: Subset<T, UserStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserStatsAggregateArgs>(args: Subset<T, UserStatsAggregateArgs>): Prisma.PrismaPromise<GetUserStatsAggregateType<T>>

    /**
     * Group by UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserStatsGroupByArgs['orderBy'] }
        : { orderBy?: UserStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserStats model
   */
  readonly fields: UserStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserStats model
   */
  interface UserStatsFieldRefs {
    readonly id: FieldRef<"UserStats", 'String'>
    readonly userId: FieldRef<"UserStats", 'String'>
    readonly totalPlayTime: FieldRef<"UserStats", 'Int'>
    readonly totalSessions: FieldRef<"UserStats", 'Int'>
    readonly gamesPlayed: FieldRef<"UserStats", 'Int'>
    readonly gamesCompleted: FieldRef<"UserStats", 'Int'>
    readonly lastPlayedGame: FieldRef<"UserStats", 'String'>
    readonly lastPlayedAt: FieldRef<"UserStats", 'DateTime'>
    readonly weeklyStats: FieldRef<"UserStats", 'Json'>
    readonly monthlyStats: FieldRef<"UserStats", 'Json'>
    readonly achievements: FieldRef<"UserStats", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * UserStats findUnique
   */
  export type UserStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats findUniqueOrThrow
   */
  export type UserStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats findFirst
   */
  export type UserStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStats.
     */
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }

  /**
   * UserStats findFirstOrThrow
   */
  export type UserStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStats.
     */
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }

  /**
   * UserStats findMany
   */
  export type UserStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }

  /**
   * UserStats create
   */
  export type UserStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserStats.
     */
    data: XOR<UserStatsCreateInput, UserStatsUncheckedCreateInput>
  }

  /**
   * UserStats createMany
   */
  export type UserStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserStats.
     */
    data: UserStatsCreateManyInput | UserStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserStats createManyAndReturn
   */
  export type UserStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * The data used to create many UserStats.
     */
    data: UserStatsCreateManyInput | UserStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserStats update
   */
  export type UserStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserStats.
     */
    data: XOR<UserStatsUpdateInput, UserStatsUncheckedUpdateInput>
    /**
     * Choose, which UserStats to update.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats updateMany
   */
  export type UserStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserStats.
     */
    data: XOR<UserStatsUpdateManyMutationInput, UserStatsUncheckedUpdateManyInput>
    /**
     * Filter which UserStats to update
     */
    where?: UserStatsWhereInput
    /**
     * Limit how many UserStats to update.
     */
    limit?: number
  }

  /**
   * UserStats updateManyAndReturn
   */
  export type UserStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * The data used to update UserStats.
     */
    data: XOR<UserStatsUpdateManyMutationInput, UserStatsUncheckedUpdateManyInput>
    /**
     * Filter which UserStats to update
     */
    where?: UserStatsWhereInput
    /**
     * Limit how many UserStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserStats upsert
   */
  export type UserStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserStats to update in case it exists.
     */
    where: UserStatsWhereUniqueInput
    /**
     * In case the UserStats found by the `where` argument doesn't exist, create a new UserStats with this data.
     */
    create: XOR<UserStatsCreateInput, UserStatsUncheckedCreateInput>
    /**
     * In case the UserStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserStatsUpdateInput, UserStatsUncheckedUpdateInput>
  }

  /**
   * UserStats delete
   */
  export type UserStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter which UserStats to delete.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats deleteMany
   */
  export type UserStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStats to delete
     */
    where?: UserStatsWhereInput
    /**
     * Limit how many UserStats to delete.
     */
    limit?: number
  }

  /**
   * UserStats without action
   */
  export type UserStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    name: string | null
    description: string | null
    averageDuration: string | null
    parentId: string | null
    isAutoGenerated: boolean | null
    isMainCampaign: boolean | null
    difficulty: string | null
    createdAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    name: string | null
    description: string | null
    averageDuration: string | null
    parentId: string | null
    isAutoGenerated: boolean | null
    isMainCampaign: boolean | null
    difficulty: string | null
    createdAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    gameId: number
    name: number
    description: number
    averageDuration: number
    customProperties: number
    parentId: number
    isAutoGenerated: number
    isMainCampaign: number
    difficulty: number
    features: number
    createdAt: number
    _all: number
  }


  export type CampaignMinAggregateInputType = {
    id?: true
    gameId?: true
    name?: true
    description?: true
    averageDuration?: true
    parentId?: true
    isAutoGenerated?: true
    isMainCampaign?: true
    difficulty?: true
    createdAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    gameId?: true
    name?: true
    description?: true
    averageDuration?: true
    parentId?: true
    isAutoGenerated?: true
    isMainCampaign?: true
    difficulty?: true
    createdAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    gameId?: true
    name?: true
    description?: true
    averageDuration?: true
    customProperties?: true
    parentId?: true
    isAutoGenerated?: true
    isMainCampaign?: true
    difficulty?: true
    features?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    gameId: string
    name: string
    description: string | null
    averageDuration: string | null
    customProperties: JsonValue | null
    parentId: string | null
    isAutoGenerated: boolean
    isMainCampaign: boolean
    difficulty: string | null
    features: JsonValue | null
    createdAt: Date
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    name?: boolean
    description?: boolean
    averageDuration?: boolean
    customProperties?: boolean
    parentId?: boolean
    isAutoGenerated?: boolean
    isMainCampaign?: boolean
    difficulty?: boolean
    features?: boolean
    createdAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    parent?: boolean | Campaign$parentArgs<ExtArgs>
    children?: boolean | Campaign$childrenArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    name?: boolean
    description?: boolean
    averageDuration?: boolean
    customProperties?: boolean
    parentId?: boolean
    isAutoGenerated?: boolean
    isMainCampaign?: boolean
    difficulty?: boolean
    features?: boolean
    createdAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    parent?: boolean | Campaign$parentArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    name?: boolean
    description?: boolean
    averageDuration?: boolean
    customProperties?: boolean
    parentId?: boolean
    isAutoGenerated?: boolean
    isMainCampaign?: boolean
    difficulty?: boolean
    features?: boolean
    createdAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    parent?: boolean | Campaign$parentArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    gameId?: boolean
    name?: boolean
    description?: boolean
    averageDuration?: boolean
    customProperties?: boolean
    parentId?: boolean
    isAutoGenerated?: boolean
    isMainCampaign?: boolean
    difficulty?: boolean
    features?: boolean
    createdAt?: boolean
  }

  export type CampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameId" | "name" | "description" | "averageDuration" | "customProperties" | "parentId" | "isAutoGenerated" | "isMainCampaign" | "difficulty" | "features" | "createdAt", ExtArgs["result"]["campaign"]>
  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    parent?: boolean | Campaign$parentArgs<ExtArgs>
    children?: boolean | Campaign$childrenArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    parent?: boolean | Campaign$parentArgs<ExtArgs>
  }
  export type CampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    parent?: boolean | Campaign$parentArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      parent: Prisma.$CampaignPayload<ExtArgs> | null
      children: Prisma.$CampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      name: string
      description: string | null
      averageDuration: string | null
      customProperties: Prisma.JsonValue | null
      parentId: string | null
      isAutoGenerated: boolean
      isMainCampaign: boolean
      difficulty: string | null
      features: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns and returns the data updated in the database.
     * @param {CampaignUpdateManyAndReturnArgs} args - Arguments to update many Campaigns.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Campaign$parentArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$parentArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Campaign$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly gameId: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly description: FieldRef<"Campaign", 'String'>
    readonly averageDuration: FieldRef<"Campaign", 'String'>
    readonly customProperties: FieldRef<"Campaign", 'Json'>
    readonly parentId: FieldRef<"Campaign", 'String'>
    readonly isAutoGenerated: FieldRef<"Campaign", 'Boolean'>
    readonly isMainCampaign: FieldRef<"Campaign", 'Boolean'>
    readonly difficulty: FieldRef<"Campaign", 'String'>
    readonly features: FieldRef<"Campaign", 'Json'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
  }

  /**
   * Campaign updateManyAndReturn
   */
  export type CampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to delete.
     */
    limit?: number
  }

  /**
   * Campaign.parent
   */
  export type Campaign$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
  }

  /**
   * Campaign.children
   */
  export type Campaign$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model PageVisit
   */

  export type AggregatePageVisit = {
    _count: PageVisitCountAggregateOutputType | null
    _min: PageVisitMinAggregateOutputType | null
    _max: PageVisitMaxAggregateOutputType | null
  }

  export type PageVisitMinAggregateOutputType = {
    id: string | null
    userId: string | null
    page: string | null
    visitedAt: Date | null
  }

  export type PageVisitMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    page: string | null
    visitedAt: Date | null
  }

  export type PageVisitCountAggregateOutputType = {
    id: number
    userId: number
    page: number
    visitedAt: number
    metadata: number
    _all: number
  }


  export type PageVisitMinAggregateInputType = {
    id?: true
    userId?: true
    page?: true
    visitedAt?: true
  }

  export type PageVisitMaxAggregateInputType = {
    id?: true
    userId?: true
    page?: true
    visitedAt?: true
  }

  export type PageVisitCountAggregateInputType = {
    id?: true
    userId?: true
    page?: true
    visitedAt?: true
    metadata?: true
    _all?: true
  }

  export type PageVisitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageVisit to aggregate.
     */
    where?: PageVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageVisits to fetch.
     */
    orderBy?: PageVisitOrderByWithRelationInput | PageVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PageVisits
    **/
    _count?: true | PageVisitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageVisitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageVisitMaxAggregateInputType
  }

  export type GetPageVisitAggregateType<T extends PageVisitAggregateArgs> = {
        [P in keyof T & keyof AggregatePageVisit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePageVisit[P]>
      : GetScalarType<T[P], AggregatePageVisit[P]>
  }




  export type PageVisitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageVisitWhereInput
    orderBy?: PageVisitOrderByWithAggregationInput | PageVisitOrderByWithAggregationInput[]
    by: PageVisitScalarFieldEnum[] | PageVisitScalarFieldEnum
    having?: PageVisitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageVisitCountAggregateInputType | true
    _min?: PageVisitMinAggregateInputType
    _max?: PageVisitMaxAggregateInputType
  }

  export type PageVisitGroupByOutputType = {
    id: string
    userId: string
    page: string
    visitedAt: Date
    metadata: JsonValue | null
    _count: PageVisitCountAggregateOutputType | null
    _min: PageVisitMinAggregateOutputType | null
    _max: PageVisitMaxAggregateOutputType | null
  }

  type GetPageVisitGroupByPayload<T extends PageVisitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageVisitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageVisitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageVisitGroupByOutputType[P]>
            : GetScalarType<T[P], PageVisitGroupByOutputType[P]>
        }
      >
    >


  export type PageVisitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    page?: boolean
    visitedAt?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageVisit"]>

  export type PageVisitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    page?: boolean
    visitedAt?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageVisit"]>

  export type PageVisitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    page?: boolean
    visitedAt?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageVisit"]>

  export type PageVisitSelectScalar = {
    id?: boolean
    userId?: boolean
    page?: boolean
    visitedAt?: boolean
    metadata?: boolean
  }

  export type PageVisitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "page" | "visitedAt" | "metadata", ExtArgs["result"]["pageVisit"]>
  export type PageVisitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PageVisitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PageVisitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PageVisitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PageVisit"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      page: string
      visitedAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["pageVisit"]>
    composites: {}
  }

  type PageVisitGetPayload<S extends boolean | null | undefined | PageVisitDefaultArgs> = $Result.GetResult<Prisma.$PageVisitPayload, S>

  type PageVisitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PageVisitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PageVisitCountAggregateInputType | true
    }

  export interface PageVisitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PageVisit'], meta: { name: 'PageVisit' } }
    /**
     * Find zero or one PageVisit that matches the filter.
     * @param {PageVisitFindUniqueArgs} args - Arguments to find a PageVisit
     * @example
     * // Get one PageVisit
     * const pageVisit = await prisma.pageVisit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageVisitFindUniqueArgs>(args: SelectSubset<T, PageVisitFindUniqueArgs<ExtArgs>>): Prisma__PageVisitClient<$Result.GetResult<Prisma.$PageVisitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PageVisit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageVisitFindUniqueOrThrowArgs} args - Arguments to find a PageVisit
     * @example
     * // Get one PageVisit
     * const pageVisit = await prisma.pageVisit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageVisitFindUniqueOrThrowArgs>(args: SelectSubset<T, PageVisitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageVisitClient<$Result.GetResult<Prisma.$PageVisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PageVisit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageVisitFindFirstArgs} args - Arguments to find a PageVisit
     * @example
     * // Get one PageVisit
     * const pageVisit = await prisma.pageVisit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageVisitFindFirstArgs>(args?: SelectSubset<T, PageVisitFindFirstArgs<ExtArgs>>): Prisma__PageVisitClient<$Result.GetResult<Prisma.$PageVisitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PageVisit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageVisitFindFirstOrThrowArgs} args - Arguments to find a PageVisit
     * @example
     * // Get one PageVisit
     * const pageVisit = await prisma.pageVisit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageVisitFindFirstOrThrowArgs>(args?: SelectSubset<T, PageVisitFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageVisitClient<$Result.GetResult<Prisma.$PageVisitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PageVisits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageVisitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PageVisits
     * const pageVisits = await prisma.pageVisit.findMany()
     * 
     * // Get first 10 PageVisits
     * const pageVisits = await prisma.pageVisit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageVisitWithIdOnly = await prisma.pageVisit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageVisitFindManyArgs>(args?: SelectSubset<T, PageVisitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageVisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PageVisit.
     * @param {PageVisitCreateArgs} args - Arguments to create a PageVisit.
     * @example
     * // Create one PageVisit
     * const PageVisit = await prisma.pageVisit.create({
     *   data: {
     *     // ... data to create a PageVisit
     *   }
     * })
     * 
     */
    create<T extends PageVisitCreateArgs>(args: SelectSubset<T, PageVisitCreateArgs<ExtArgs>>): Prisma__PageVisitClient<$Result.GetResult<Prisma.$PageVisitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PageVisits.
     * @param {PageVisitCreateManyArgs} args - Arguments to create many PageVisits.
     * @example
     * // Create many PageVisits
     * const pageVisit = await prisma.pageVisit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageVisitCreateManyArgs>(args?: SelectSubset<T, PageVisitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PageVisits and returns the data saved in the database.
     * @param {PageVisitCreateManyAndReturnArgs} args - Arguments to create many PageVisits.
     * @example
     * // Create many PageVisits
     * const pageVisit = await prisma.pageVisit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PageVisits and only return the `id`
     * const pageVisitWithIdOnly = await prisma.pageVisit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageVisitCreateManyAndReturnArgs>(args?: SelectSubset<T, PageVisitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageVisitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PageVisit.
     * @param {PageVisitDeleteArgs} args - Arguments to delete one PageVisit.
     * @example
     * // Delete one PageVisit
     * const PageVisit = await prisma.pageVisit.delete({
     *   where: {
     *     // ... filter to delete one PageVisit
     *   }
     * })
     * 
     */
    delete<T extends PageVisitDeleteArgs>(args: SelectSubset<T, PageVisitDeleteArgs<ExtArgs>>): Prisma__PageVisitClient<$Result.GetResult<Prisma.$PageVisitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PageVisit.
     * @param {PageVisitUpdateArgs} args - Arguments to update one PageVisit.
     * @example
     * // Update one PageVisit
     * const pageVisit = await prisma.pageVisit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageVisitUpdateArgs>(args: SelectSubset<T, PageVisitUpdateArgs<ExtArgs>>): Prisma__PageVisitClient<$Result.GetResult<Prisma.$PageVisitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PageVisits.
     * @param {PageVisitDeleteManyArgs} args - Arguments to filter PageVisits to delete.
     * @example
     * // Delete a few PageVisits
     * const { count } = await prisma.pageVisit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageVisitDeleteManyArgs>(args?: SelectSubset<T, PageVisitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageVisitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PageVisits
     * const pageVisit = await prisma.pageVisit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageVisitUpdateManyArgs>(args: SelectSubset<T, PageVisitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageVisits and returns the data updated in the database.
     * @param {PageVisitUpdateManyAndReturnArgs} args - Arguments to update many PageVisits.
     * @example
     * // Update many PageVisits
     * const pageVisit = await prisma.pageVisit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PageVisits and only return the `id`
     * const pageVisitWithIdOnly = await prisma.pageVisit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PageVisitUpdateManyAndReturnArgs>(args: SelectSubset<T, PageVisitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageVisitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PageVisit.
     * @param {PageVisitUpsertArgs} args - Arguments to update or create a PageVisit.
     * @example
     * // Update or create a PageVisit
     * const pageVisit = await prisma.pageVisit.upsert({
     *   create: {
     *     // ... data to create a PageVisit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PageVisit we want to update
     *   }
     * })
     */
    upsert<T extends PageVisitUpsertArgs>(args: SelectSubset<T, PageVisitUpsertArgs<ExtArgs>>): Prisma__PageVisitClient<$Result.GetResult<Prisma.$PageVisitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PageVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageVisitCountArgs} args - Arguments to filter PageVisits to count.
     * @example
     * // Count the number of PageVisits
     * const count = await prisma.pageVisit.count({
     *   where: {
     *     // ... the filter for the PageVisits we want to count
     *   }
     * })
    **/
    count<T extends PageVisitCountArgs>(
      args?: Subset<T, PageVisitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageVisitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PageVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageVisitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageVisitAggregateArgs>(args: Subset<T, PageVisitAggregateArgs>): Prisma.PrismaPromise<GetPageVisitAggregateType<T>>

    /**
     * Group by PageVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageVisitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageVisitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageVisitGroupByArgs['orderBy'] }
        : { orderBy?: PageVisitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageVisitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageVisitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PageVisit model
   */
  readonly fields: PageVisitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PageVisit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageVisitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PageVisit model
   */
  interface PageVisitFieldRefs {
    readonly id: FieldRef<"PageVisit", 'String'>
    readonly userId: FieldRef<"PageVisit", 'String'>
    readonly page: FieldRef<"PageVisit", 'String'>
    readonly visitedAt: FieldRef<"PageVisit", 'DateTime'>
    readonly metadata: FieldRef<"PageVisit", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * PageVisit findUnique
   */
  export type PageVisitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageVisit
     */
    select?: PageVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageVisit
     */
    omit?: PageVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageVisitInclude<ExtArgs> | null
    /**
     * Filter, which PageVisit to fetch.
     */
    where: PageVisitWhereUniqueInput
  }

  /**
   * PageVisit findUniqueOrThrow
   */
  export type PageVisitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageVisit
     */
    select?: PageVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageVisit
     */
    omit?: PageVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageVisitInclude<ExtArgs> | null
    /**
     * Filter, which PageVisit to fetch.
     */
    where: PageVisitWhereUniqueInput
  }

  /**
   * PageVisit findFirst
   */
  export type PageVisitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageVisit
     */
    select?: PageVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageVisit
     */
    omit?: PageVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageVisitInclude<ExtArgs> | null
    /**
     * Filter, which PageVisit to fetch.
     */
    where?: PageVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageVisits to fetch.
     */
    orderBy?: PageVisitOrderByWithRelationInput | PageVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageVisits.
     */
    cursor?: PageVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageVisits.
     */
    distinct?: PageVisitScalarFieldEnum | PageVisitScalarFieldEnum[]
  }

  /**
   * PageVisit findFirstOrThrow
   */
  export type PageVisitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageVisit
     */
    select?: PageVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageVisit
     */
    omit?: PageVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageVisitInclude<ExtArgs> | null
    /**
     * Filter, which PageVisit to fetch.
     */
    where?: PageVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageVisits to fetch.
     */
    orderBy?: PageVisitOrderByWithRelationInput | PageVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageVisits.
     */
    cursor?: PageVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageVisits.
     */
    distinct?: PageVisitScalarFieldEnum | PageVisitScalarFieldEnum[]
  }

  /**
   * PageVisit findMany
   */
  export type PageVisitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageVisit
     */
    select?: PageVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageVisit
     */
    omit?: PageVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageVisitInclude<ExtArgs> | null
    /**
     * Filter, which PageVisits to fetch.
     */
    where?: PageVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageVisits to fetch.
     */
    orderBy?: PageVisitOrderByWithRelationInput | PageVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PageVisits.
     */
    cursor?: PageVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageVisits.
     */
    skip?: number
    distinct?: PageVisitScalarFieldEnum | PageVisitScalarFieldEnum[]
  }

  /**
   * PageVisit create
   */
  export type PageVisitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageVisit
     */
    select?: PageVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageVisit
     */
    omit?: PageVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageVisitInclude<ExtArgs> | null
    /**
     * The data needed to create a PageVisit.
     */
    data: XOR<PageVisitCreateInput, PageVisitUncheckedCreateInput>
  }

  /**
   * PageVisit createMany
   */
  export type PageVisitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PageVisits.
     */
    data: PageVisitCreateManyInput | PageVisitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PageVisit createManyAndReturn
   */
  export type PageVisitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageVisit
     */
    select?: PageVisitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageVisit
     */
    omit?: PageVisitOmit<ExtArgs> | null
    /**
     * The data used to create many PageVisits.
     */
    data: PageVisitCreateManyInput | PageVisitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageVisitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageVisit update
   */
  export type PageVisitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageVisit
     */
    select?: PageVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageVisit
     */
    omit?: PageVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageVisitInclude<ExtArgs> | null
    /**
     * The data needed to update a PageVisit.
     */
    data: XOR<PageVisitUpdateInput, PageVisitUncheckedUpdateInput>
    /**
     * Choose, which PageVisit to update.
     */
    where: PageVisitWhereUniqueInput
  }

  /**
   * PageVisit updateMany
   */
  export type PageVisitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PageVisits.
     */
    data: XOR<PageVisitUpdateManyMutationInput, PageVisitUncheckedUpdateManyInput>
    /**
     * Filter which PageVisits to update
     */
    where?: PageVisitWhereInput
    /**
     * Limit how many PageVisits to update.
     */
    limit?: number
  }

  /**
   * PageVisit updateManyAndReturn
   */
  export type PageVisitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageVisit
     */
    select?: PageVisitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageVisit
     */
    omit?: PageVisitOmit<ExtArgs> | null
    /**
     * The data used to update PageVisits.
     */
    data: XOR<PageVisitUpdateManyMutationInput, PageVisitUncheckedUpdateManyInput>
    /**
     * Filter which PageVisits to update
     */
    where?: PageVisitWhereInput
    /**
     * Limit how many PageVisits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageVisitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageVisit upsert
   */
  export type PageVisitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageVisit
     */
    select?: PageVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageVisit
     */
    omit?: PageVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageVisitInclude<ExtArgs> | null
    /**
     * The filter to search for the PageVisit to update in case it exists.
     */
    where: PageVisitWhereUniqueInput
    /**
     * In case the PageVisit found by the `where` argument doesn't exist, create a new PageVisit with this data.
     */
    create: XOR<PageVisitCreateInput, PageVisitUncheckedCreateInput>
    /**
     * In case the PageVisit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageVisitUpdateInput, PageVisitUncheckedUpdateInput>
  }

  /**
   * PageVisit delete
   */
  export type PageVisitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageVisit
     */
    select?: PageVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageVisit
     */
    omit?: PageVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageVisitInclude<ExtArgs> | null
    /**
     * Filter which PageVisit to delete.
     */
    where: PageVisitWhereUniqueInput
  }

  /**
   * PageVisit deleteMany
   */
  export type PageVisitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageVisits to delete
     */
    where?: PageVisitWhereInput
    /**
     * Limit how many PageVisits to delete.
     */
    limit?: number
  }

  /**
   * PageVisit without action
   */
  export type PageVisitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageVisit
     */
    select?: PageVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageVisit
     */
    omit?: PageVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageVisitInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    isGlobal: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    isGlobal: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    isRead: number
    isGlobal: number
    metadata: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    isGlobal?: true
    createdAt?: true
    expiresAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    isGlobal?: true
    createdAt?: true
    expiresAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    isGlobal?: true
    metadata?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string | null
    title: string
    message: string
    type: string
    isRead: boolean
    isGlobal: boolean
    metadata: JsonValue | null
    createdAt: Date
    expiresAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    isGlobal?: boolean
    metadata?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    isGlobal?: boolean
    metadata?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    isGlobal?: boolean
    metadata?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    isGlobal?: boolean
    metadata?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "message" | "type" | "isRead" | "isGlobal" | "metadata" | "createdAt" | "expiresAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      title: string
      message: string
      type: string
      isRead: boolean
      isGlobal: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Notification$userArgs<ExtArgs> = {}>(args?: Subset<T, Notification$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly isGlobal: FieldRef<"Notification", 'Boolean'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly expiresAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.user
   */
  export type Notification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model SystemUpdate
   */

  export type AggregateSystemUpdate = {
    _count: SystemUpdateCountAggregateOutputType | null
    _avg: SystemUpdateAvgAggregateOutputType | null
    _sum: SystemUpdateSumAggregateOutputType | null
    _min: SystemUpdateMinAggregateOutputType | null
    _max: SystemUpdateMaxAggregateOutputType | null
  }

  export type SystemUpdateAvgAggregateOutputType = {
    progress: number | null
  }

  export type SystemUpdateSumAggregateOutputType = {
    progress: number | null
  }

  export type SystemUpdateMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    version: string | null
    type: string | null
    status: string | null
    progress: number | null
    priority: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type SystemUpdateMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    version: string | null
    type: string | null
    status: string | null
    progress: number | null
    priority: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type SystemUpdateCountAggregateOutputType = {
    id: number
    title: number
    description: number
    version: number
    type: number
    status: number
    progress: number
    priority: number
    category: number
    metadata: number
    createdAt: number
    updatedAt: number
    completedAt: number
    _all: number
  }


  export type SystemUpdateAvgAggregateInputType = {
    progress?: true
  }

  export type SystemUpdateSumAggregateInputType = {
    progress?: true
  }

  export type SystemUpdateMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    version?: true
    type?: true
    status?: true
    progress?: true
    priority?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type SystemUpdateMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    version?: true
    type?: true
    status?: true
    progress?: true
    priority?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type SystemUpdateCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    version?: true
    type?: true
    status?: true
    progress?: true
    priority?: true
    category?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    _all?: true
  }

  export type SystemUpdateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemUpdate to aggregate.
     */
    where?: SystemUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemUpdates to fetch.
     */
    orderBy?: SystemUpdateOrderByWithRelationInput | SystemUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemUpdates
    **/
    _count?: true | SystemUpdateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemUpdateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemUpdateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemUpdateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemUpdateMaxAggregateInputType
  }

  export type GetSystemUpdateAggregateType<T extends SystemUpdateAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemUpdate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemUpdate[P]>
      : GetScalarType<T[P], AggregateSystemUpdate[P]>
  }




  export type SystemUpdateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemUpdateWhereInput
    orderBy?: SystemUpdateOrderByWithAggregationInput | SystemUpdateOrderByWithAggregationInput[]
    by: SystemUpdateScalarFieldEnum[] | SystemUpdateScalarFieldEnum
    having?: SystemUpdateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemUpdateCountAggregateInputType | true
    _avg?: SystemUpdateAvgAggregateInputType
    _sum?: SystemUpdateSumAggregateInputType
    _min?: SystemUpdateMinAggregateInputType
    _max?: SystemUpdateMaxAggregateInputType
  }

  export type SystemUpdateGroupByOutputType = {
    id: string
    title: string
    description: string
    version: string | null
    type: string
    status: string
    progress: number
    priority: string
    category: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    _count: SystemUpdateCountAggregateOutputType | null
    _avg: SystemUpdateAvgAggregateOutputType | null
    _sum: SystemUpdateSumAggregateOutputType | null
    _min: SystemUpdateMinAggregateOutputType | null
    _max: SystemUpdateMaxAggregateOutputType | null
  }

  type GetSystemUpdateGroupByPayload<T extends SystemUpdateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemUpdateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemUpdateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemUpdateGroupByOutputType[P]>
            : GetScalarType<T[P], SystemUpdateGroupByOutputType[P]>
        }
      >
    >


  export type SystemUpdateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    version?: boolean
    type?: boolean
    status?: boolean
    progress?: boolean
    priority?: boolean
    category?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    substeps?: boolean | SystemUpdate$substepsArgs<ExtArgs>
    _count?: boolean | SystemUpdateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemUpdate"]>

  export type SystemUpdateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    version?: boolean
    type?: boolean
    status?: boolean
    progress?: boolean
    priority?: boolean
    category?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["systemUpdate"]>

  export type SystemUpdateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    version?: boolean
    type?: boolean
    status?: boolean
    progress?: boolean
    priority?: boolean
    category?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["systemUpdate"]>

  export type SystemUpdateSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    version?: boolean
    type?: boolean
    status?: boolean
    progress?: boolean
    priority?: boolean
    category?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }

  export type SystemUpdateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "version" | "type" | "status" | "progress" | "priority" | "category" | "metadata" | "createdAt" | "updatedAt" | "completedAt", ExtArgs["result"]["systemUpdate"]>
  export type SystemUpdateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    substeps?: boolean | SystemUpdate$substepsArgs<ExtArgs>
    _count?: boolean | SystemUpdateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SystemUpdateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SystemUpdateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SystemUpdatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemUpdate"
    objects: {
      substeps: Prisma.$SystemUpdateStepPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      version: string | null
      type: string
      status: string
      progress: number
      priority: string
      category: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["systemUpdate"]>
    composites: {}
  }

  type SystemUpdateGetPayload<S extends boolean | null | undefined | SystemUpdateDefaultArgs> = $Result.GetResult<Prisma.$SystemUpdatePayload, S>

  type SystemUpdateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemUpdateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemUpdateCountAggregateInputType | true
    }

  export interface SystemUpdateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemUpdate'], meta: { name: 'SystemUpdate' } }
    /**
     * Find zero or one SystemUpdate that matches the filter.
     * @param {SystemUpdateFindUniqueArgs} args - Arguments to find a SystemUpdate
     * @example
     * // Get one SystemUpdate
     * const systemUpdate = await prisma.systemUpdate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemUpdateFindUniqueArgs>(args: SelectSubset<T, SystemUpdateFindUniqueArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemUpdate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemUpdateFindUniqueOrThrowArgs} args - Arguments to find a SystemUpdate
     * @example
     * // Get one SystemUpdate
     * const systemUpdate = await prisma.systemUpdate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemUpdateFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemUpdateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemUpdate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateFindFirstArgs} args - Arguments to find a SystemUpdate
     * @example
     * // Get one SystemUpdate
     * const systemUpdate = await prisma.systemUpdate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemUpdateFindFirstArgs>(args?: SelectSubset<T, SystemUpdateFindFirstArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemUpdate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateFindFirstOrThrowArgs} args - Arguments to find a SystemUpdate
     * @example
     * // Get one SystemUpdate
     * const systemUpdate = await prisma.systemUpdate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemUpdateFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemUpdateFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemUpdates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemUpdates
     * const systemUpdates = await prisma.systemUpdate.findMany()
     * 
     * // Get first 10 SystemUpdates
     * const systemUpdates = await prisma.systemUpdate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemUpdateWithIdOnly = await prisma.systemUpdate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemUpdateFindManyArgs>(args?: SelectSubset<T, SystemUpdateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemUpdate.
     * @param {SystemUpdateCreateArgs} args - Arguments to create a SystemUpdate.
     * @example
     * // Create one SystemUpdate
     * const SystemUpdate = await prisma.systemUpdate.create({
     *   data: {
     *     // ... data to create a SystemUpdate
     *   }
     * })
     * 
     */
    create<T extends SystemUpdateCreateArgs>(args: SelectSubset<T, SystemUpdateCreateArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemUpdates.
     * @param {SystemUpdateCreateManyArgs} args - Arguments to create many SystemUpdates.
     * @example
     * // Create many SystemUpdates
     * const systemUpdate = await prisma.systemUpdate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemUpdateCreateManyArgs>(args?: SelectSubset<T, SystemUpdateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemUpdates and returns the data saved in the database.
     * @param {SystemUpdateCreateManyAndReturnArgs} args - Arguments to create many SystemUpdates.
     * @example
     * // Create many SystemUpdates
     * const systemUpdate = await prisma.systemUpdate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemUpdates and only return the `id`
     * const systemUpdateWithIdOnly = await prisma.systemUpdate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemUpdateCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemUpdateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemUpdate.
     * @param {SystemUpdateDeleteArgs} args - Arguments to delete one SystemUpdate.
     * @example
     * // Delete one SystemUpdate
     * const SystemUpdate = await prisma.systemUpdate.delete({
     *   where: {
     *     // ... filter to delete one SystemUpdate
     *   }
     * })
     * 
     */
    delete<T extends SystemUpdateDeleteArgs>(args: SelectSubset<T, SystemUpdateDeleteArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemUpdate.
     * @param {SystemUpdateUpdateArgs} args - Arguments to update one SystemUpdate.
     * @example
     * // Update one SystemUpdate
     * const systemUpdate = await prisma.systemUpdate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemUpdateUpdateArgs>(args: SelectSubset<T, SystemUpdateUpdateArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemUpdates.
     * @param {SystemUpdateDeleteManyArgs} args - Arguments to filter SystemUpdates to delete.
     * @example
     * // Delete a few SystemUpdates
     * const { count } = await prisma.systemUpdate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemUpdateDeleteManyArgs>(args?: SelectSubset<T, SystemUpdateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemUpdates
     * const systemUpdate = await prisma.systemUpdate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemUpdateUpdateManyArgs>(args: SelectSubset<T, SystemUpdateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemUpdates and returns the data updated in the database.
     * @param {SystemUpdateUpdateManyAndReturnArgs} args - Arguments to update many SystemUpdates.
     * @example
     * // Update many SystemUpdates
     * const systemUpdate = await prisma.systemUpdate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemUpdates and only return the `id`
     * const systemUpdateWithIdOnly = await prisma.systemUpdate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemUpdateUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemUpdateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemUpdate.
     * @param {SystemUpdateUpsertArgs} args - Arguments to update or create a SystemUpdate.
     * @example
     * // Update or create a SystemUpdate
     * const systemUpdate = await prisma.systemUpdate.upsert({
     *   create: {
     *     // ... data to create a SystemUpdate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemUpdate we want to update
     *   }
     * })
     */
    upsert<T extends SystemUpdateUpsertArgs>(args: SelectSubset<T, SystemUpdateUpsertArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateCountArgs} args - Arguments to filter SystemUpdates to count.
     * @example
     * // Count the number of SystemUpdates
     * const count = await prisma.systemUpdate.count({
     *   where: {
     *     // ... the filter for the SystemUpdates we want to count
     *   }
     * })
    **/
    count<T extends SystemUpdateCountArgs>(
      args?: Subset<T, SystemUpdateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemUpdateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemUpdateAggregateArgs>(args: Subset<T, SystemUpdateAggregateArgs>): Prisma.PrismaPromise<GetSystemUpdateAggregateType<T>>

    /**
     * Group by SystemUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemUpdateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemUpdateGroupByArgs['orderBy'] }
        : { orderBy?: SystemUpdateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemUpdateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemUpdateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemUpdate model
   */
  readonly fields: SystemUpdateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemUpdate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemUpdateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    substeps<T extends SystemUpdate$substepsArgs<ExtArgs> = {}>(args?: Subset<T, SystemUpdate$substepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemUpdateStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemUpdate model
   */
  interface SystemUpdateFieldRefs {
    readonly id: FieldRef<"SystemUpdate", 'String'>
    readonly title: FieldRef<"SystemUpdate", 'String'>
    readonly description: FieldRef<"SystemUpdate", 'String'>
    readonly version: FieldRef<"SystemUpdate", 'String'>
    readonly type: FieldRef<"SystemUpdate", 'String'>
    readonly status: FieldRef<"SystemUpdate", 'String'>
    readonly progress: FieldRef<"SystemUpdate", 'Int'>
    readonly priority: FieldRef<"SystemUpdate", 'String'>
    readonly category: FieldRef<"SystemUpdate", 'String'>
    readonly metadata: FieldRef<"SystemUpdate", 'Json'>
    readonly createdAt: FieldRef<"SystemUpdate", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemUpdate", 'DateTime'>
    readonly completedAt: FieldRef<"SystemUpdate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemUpdate findUnique
   */
  export type SystemUpdateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * Filter, which SystemUpdate to fetch.
     */
    where: SystemUpdateWhereUniqueInput
  }

  /**
   * SystemUpdate findUniqueOrThrow
   */
  export type SystemUpdateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * Filter, which SystemUpdate to fetch.
     */
    where: SystemUpdateWhereUniqueInput
  }

  /**
   * SystemUpdate findFirst
   */
  export type SystemUpdateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * Filter, which SystemUpdate to fetch.
     */
    where?: SystemUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemUpdates to fetch.
     */
    orderBy?: SystemUpdateOrderByWithRelationInput | SystemUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemUpdates.
     */
    cursor?: SystemUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemUpdates.
     */
    distinct?: SystemUpdateScalarFieldEnum | SystemUpdateScalarFieldEnum[]
  }

  /**
   * SystemUpdate findFirstOrThrow
   */
  export type SystemUpdateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * Filter, which SystemUpdate to fetch.
     */
    where?: SystemUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemUpdates to fetch.
     */
    orderBy?: SystemUpdateOrderByWithRelationInput | SystemUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemUpdates.
     */
    cursor?: SystemUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemUpdates.
     */
    distinct?: SystemUpdateScalarFieldEnum | SystemUpdateScalarFieldEnum[]
  }

  /**
   * SystemUpdate findMany
   */
  export type SystemUpdateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * Filter, which SystemUpdates to fetch.
     */
    where?: SystemUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemUpdates to fetch.
     */
    orderBy?: SystemUpdateOrderByWithRelationInput | SystemUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemUpdates.
     */
    cursor?: SystemUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemUpdates.
     */
    skip?: number
    distinct?: SystemUpdateScalarFieldEnum | SystemUpdateScalarFieldEnum[]
  }

  /**
   * SystemUpdate create
   */
  export type SystemUpdateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemUpdate.
     */
    data: XOR<SystemUpdateCreateInput, SystemUpdateUncheckedCreateInput>
  }

  /**
   * SystemUpdate createMany
   */
  export type SystemUpdateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemUpdates.
     */
    data: SystemUpdateCreateManyInput | SystemUpdateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemUpdate createManyAndReturn
   */
  export type SystemUpdateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * The data used to create many SystemUpdates.
     */
    data: SystemUpdateCreateManyInput | SystemUpdateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemUpdate update
   */
  export type SystemUpdateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemUpdate.
     */
    data: XOR<SystemUpdateUpdateInput, SystemUpdateUncheckedUpdateInput>
    /**
     * Choose, which SystemUpdate to update.
     */
    where: SystemUpdateWhereUniqueInput
  }

  /**
   * SystemUpdate updateMany
   */
  export type SystemUpdateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemUpdates.
     */
    data: XOR<SystemUpdateUpdateManyMutationInput, SystemUpdateUncheckedUpdateManyInput>
    /**
     * Filter which SystemUpdates to update
     */
    where?: SystemUpdateWhereInput
    /**
     * Limit how many SystemUpdates to update.
     */
    limit?: number
  }

  /**
   * SystemUpdate updateManyAndReturn
   */
  export type SystemUpdateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * The data used to update SystemUpdates.
     */
    data: XOR<SystemUpdateUpdateManyMutationInput, SystemUpdateUncheckedUpdateManyInput>
    /**
     * Filter which SystemUpdates to update
     */
    where?: SystemUpdateWhereInput
    /**
     * Limit how many SystemUpdates to update.
     */
    limit?: number
  }

  /**
   * SystemUpdate upsert
   */
  export type SystemUpdateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemUpdate to update in case it exists.
     */
    where: SystemUpdateWhereUniqueInput
    /**
     * In case the SystemUpdate found by the `where` argument doesn't exist, create a new SystemUpdate with this data.
     */
    create: XOR<SystemUpdateCreateInput, SystemUpdateUncheckedCreateInput>
    /**
     * In case the SystemUpdate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemUpdateUpdateInput, SystemUpdateUncheckedUpdateInput>
  }

  /**
   * SystemUpdate delete
   */
  export type SystemUpdateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * Filter which SystemUpdate to delete.
     */
    where: SystemUpdateWhereUniqueInput
  }

  /**
   * SystemUpdate deleteMany
   */
  export type SystemUpdateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemUpdates to delete
     */
    where?: SystemUpdateWhereInput
    /**
     * Limit how many SystemUpdates to delete.
     */
    limit?: number
  }

  /**
   * SystemUpdate.substeps
   */
  export type SystemUpdate$substepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdateStep
     */
    select?: SystemUpdateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdateStep
     */
    omit?: SystemUpdateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateStepInclude<ExtArgs> | null
    where?: SystemUpdateStepWhereInput
    orderBy?: SystemUpdateStepOrderByWithRelationInput | SystemUpdateStepOrderByWithRelationInput[]
    cursor?: SystemUpdateStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemUpdateStepScalarFieldEnum | SystemUpdateStepScalarFieldEnum[]
  }

  /**
   * SystemUpdate without action
   */
  export type SystemUpdateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
  }


  /**
   * Model SystemUpdateStep
   */

  export type AggregateSystemUpdateStep = {
    _count: SystemUpdateStepCountAggregateOutputType | null
    _avg: SystemUpdateStepAvgAggregateOutputType | null
    _sum: SystemUpdateStepSumAggregateOutputType | null
    _min: SystemUpdateStepMinAggregateOutputType | null
    _max: SystemUpdateStepMaxAggregateOutputType | null
  }

  export type SystemUpdateStepAvgAggregateOutputType = {
    progress: number | null
    order: number | null
  }

  export type SystemUpdateStepSumAggregateOutputType = {
    progress: number | null
    order: number | null
  }

  export type SystemUpdateStepMinAggregateOutputType = {
    id: string | null
    updateId: string | null
    title: string | null
    description: string | null
    progress: number | null
    status: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type SystemUpdateStepMaxAggregateOutputType = {
    id: string | null
    updateId: string | null
    title: string | null
    description: string | null
    progress: number | null
    status: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type SystemUpdateStepCountAggregateOutputType = {
    id: number
    updateId: number
    title: number
    description: number
    progress: number
    status: number
    order: number
    createdAt: number
    updatedAt: number
    completedAt: number
    _all: number
  }


  export type SystemUpdateStepAvgAggregateInputType = {
    progress?: true
    order?: true
  }

  export type SystemUpdateStepSumAggregateInputType = {
    progress?: true
    order?: true
  }

  export type SystemUpdateStepMinAggregateInputType = {
    id?: true
    updateId?: true
    title?: true
    description?: true
    progress?: true
    status?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type SystemUpdateStepMaxAggregateInputType = {
    id?: true
    updateId?: true
    title?: true
    description?: true
    progress?: true
    status?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type SystemUpdateStepCountAggregateInputType = {
    id?: true
    updateId?: true
    title?: true
    description?: true
    progress?: true
    status?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    _all?: true
  }

  export type SystemUpdateStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemUpdateStep to aggregate.
     */
    where?: SystemUpdateStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemUpdateSteps to fetch.
     */
    orderBy?: SystemUpdateStepOrderByWithRelationInput | SystemUpdateStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemUpdateStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemUpdateSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemUpdateSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemUpdateSteps
    **/
    _count?: true | SystemUpdateStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemUpdateStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemUpdateStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemUpdateStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemUpdateStepMaxAggregateInputType
  }

  export type GetSystemUpdateStepAggregateType<T extends SystemUpdateStepAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemUpdateStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemUpdateStep[P]>
      : GetScalarType<T[P], AggregateSystemUpdateStep[P]>
  }




  export type SystemUpdateStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemUpdateStepWhereInput
    orderBy?: SystemUpdateStepOrderByWithAggregationInput | SystemUpdateStepOrderByWithAggregationInput[]
    by: SystemUpdateStepScalarFieldEnum[] | SystemUpdateStepScalarFieldEnum
    having?: SystemUpdateStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemUpdateStepCountAggregateInputType | true
    _avg?: SystemUpdateStepAvgAggregateInputType
    _sum?: SystemUpdateStepSumAggregateInputType
    _min?: SystemUpdateStepMinAggregateInputType
    _max?: SystemUpdateStepMaxAggregateInputType
  }

  export type SystemUpdateStepGroupByOutputType = {
    id: string
    updateId: string
    title: string
    description: string | null
    progress: number
    status: string
    order: number
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    _count: SystemUpdateStepCountAggregateOutputType | null
    _avg: SystemUpdateStepAvgAggregateOutputType | null
    _sum: SystemUpdateStepSumAggregateOutputType | null
    _min: SystemUpdateStepMinAggregateOutputType | null
    _max: SystemUpdateStepMaxAggregateOutputType | null
  }

  type GetSystemUpdateStepGroupByPayload<T extends SystemUpdateStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemUpdateStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemUpdateStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemUpdateStepGroupByOutputType[P]>
            : GetScalarType<T[P], SystemUpdateStepGroupByOutputType[P]>
        }
      >
    >


  export type SystemUpdateStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    updateId?: boolean
    title?: boolean
    description?: boolean
    progress?: boolean
    status?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    update?: boolean | SystemUpdateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemUpdateStep"]>

  export type SystemUpdateStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    updateId?: boolean
    title?: boolean
    description?: boolean
    progress?: boolean
    status?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    update?: boolean | SystemUpdateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemUpdateStep"]>

  export type SystemUpdateStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    updateId?: boolean
    title?: boolean
    description?: boolean
    progress?: boolean
    status?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    update?: boolean | SystemUpdateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemUpdateStep"]>

  export type SystemUpdateStepSelectScalar = {
    id?: boolean
    updateId?: boolean
    title?: boolean
    description?: boolean
    progress?: boolean
    status?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }

  export type SystemUpdateStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "updateId" | "title" | "description" | "progress" | "status" | "order" | "createdAt" | "updatedAt" | "completedAt", ExtArgs["result"]["systemUpdateStep"]>
  export type SystemUpdateStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    update?: boolean | SystemUpdateDefaultArgs<ExtArgs>
  }
  export type SystemUpdateStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    update?: boolean | SystemUpdateDefaultArgs<ExtArgs>
  }
  export type SystemUpdateStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    update?: boolean | SystemUpdateDefaultArgs<ExtArgs>
  }

  export type $SystemUpdateStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemUpdateStep"
    objects: {
      update: Prisma.$SystemUpdatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      updateId: string
      title: string
      description: string | null
      progress: number
      status: string
      order: number
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["systemUpdateStep"]>
    composites: {}
  }

  type SystemUpdateStepGetPayload<S extends boolean | null | undefined | SystemUpdateStepDefaultArgs> = $Result.GetResult<Prisma.$SystemUpdateStepPayload, S>

  type SystemUpdateStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemUpdateStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemUpdateStepCountAggregateInputType | true
    }

  export interface SystemUpdateStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemUpdateStep'], meta: { name: 'SystemUpdateStep' } }
    /**
     * Find zero or one SystemUpdateStep that matches the filter.
     * @param {SystemUpdateStepFindUniqueArgs} args - Arguments to find a SystemUpdateStep
     * @example
     * // Get one SystemUpdateStep
     * const systemUpdateStep = await prisma.systemUpdateStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemUpdateStepFindUniqueArgs>(args: SelectSubset<T, SystemUpdateStepFindUniqueArgs<ExtArgs>>): Prisma__SystemUpdateStepClient<$Result.GetResult<Prisma.$SystemUpdateStepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemUpdateStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemUpdateStepFindUniqueOrThrowArgs} args - Arguments to find a SystemUpdateStep
     * @example
     * // Get one SystemUpdateStep
     * const systemUpdateStep = await prisma.systemUpdateStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemUpdateStepFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemUpdateStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemUpdateStepClient<$Result.GetResult<Prisma.$SystemUpdateStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemUpdateStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateStepFindFirstArgs} args - Arguments to find a SystemUpdateStep
     * @example
     * // Get one SystemUpdateStep
     * const systemUpdateStep = await prisma.systemUpdateStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemUpdateStepFindFirstArgs>(args?: SelectSubset<T, SystemUpdateStepFindFirstArgs<ExtArgs>>): Prisma__SystemUpdateStepClient<$Result.GetResult<Prisma.$SystemUpdateStepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemUpdateStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateStepFindFirstOrThrowArgs} args - Arguments to find a SystemUpdateStep
     * @example
     * // Get one SystemUpdateStep
     * const systemUpdateStep = await prisma.systemUpdateStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemUpdateStepFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemUpdateStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemUpdateStepClient<$Result.GetResult<Prisma.$SystemUpdateStepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemUpdateSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemUpdateSteps
     * const systemUpdateSteps = await prisma.systemUpdateStep.findMany()
     * 
     * // Get first 10 SystemUpdateSteps
     * const systemUpdateSteps = await prisma.systemUpdateStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemUpdateStepWithIdOnly = await prisma.systemUpdateStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemUpdateStepFindManyArgs>(args?: SelectSubset<T, SystemUpdateStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemUpdateStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemUpdateStep.
     * @param {SystemUpdateStepCreateArgs} args - Arguments to create a SystemUpdateStep.
     * @example
     * // Create one SystemUpdateStep
     * const SystemUpdateStep = await prisma.systemUpdateStep.create({
     *   data: {
     *     // ... data to create a SystemUpdateStep
     *   }
     * })
     * 
     */
    create<T extends SystemUpdateStepCreateArgs>(args: SelectSubset<T, SystemUpdateStepCreateArgs<ExtArgs>>): Prisma__SystemUpdateStepClient<$Result.GetResult<Prisma.$SystemUpdateStepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemUpdateSteps.
     * @param {SystemUpdateStepCreateManyArgs} args - Arguments to create many SystemUpdateSteps.
     * @example
     * // Create many SystemUpdateSteps
     * const systemUpdateStep = await prisma.systemUpdateStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemUpdateStepCreateManyArgs>(args?: SelectSubset<T, SystemUpdateStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemUpdateSteps and returns the data saved in the database.
     * @param {SystemUpdateStepCreateManyAndReturnArgs} args - Arguments to create many SystemUpdateSteps.
     * @example
     * // Create many SystemUpdateSteps
     * const systemUpdateStep = await prisma.systemUpdateStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemUpdateSteps and only return the `id`
     * const systemUpdateStepWithIdOnly = await prisma.systemUpdateStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemUpdateStepCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemUpdateStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemUpdateStepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemUpdateStep.
     * @param {SystemUpdateStepDeleteArgs} args - Arguments to delete one SystemUpdateStep.
     * @example
     * // Delete one SystemUpdateStep
     * const SystemUpdateStep = await prisma.systemUpdateStep.delete({
     *   where: {
     *     // ... filter to delete one SystemUpdateStep
     *   }
     * })
     * 
     */
    delete<T extends SystemUpdateStepDeleteArgs>(args: SelectSubset<T, SystemUpdateStepDeleteArgs<ExtArgs>>): Prisma__SystemUpdateStepClient<$Result.GetResult<Prisma.$SystemUpdateStepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemUpdateStep.
     * @param {SystemUpdateStepUpdateArgs} args - Arguments to update one SystemUpdateStep.
     * @example
     * // Update one SystemUpdateStep
     * const systemUpdateStep = await prisma.systemUpdateStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemUpdateStepUpdateArgs>(args: SelectSubset<T, SystemUpdateStepUpdateArgs<ExtArgs>>): Prisma__SystemUpdateStepClient<$Result.GetResult<Prisma.$SystemUpdateStepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemUpdateSteps.
     * @param {SystemUpdateStepDeleteManyArgs} args - Arguments to filter SystemUpdateSteps to delete.
     * @example
     * // Delete a few SystemUpdateSteps
     * const { count } = await prisma.systemUpdateStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemUpdateStepDeleteManyArgs>(args?: SelectSubset<T, SystemUpdateStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemUpdateSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemUpdateSteps
     * const systemUpdateStep = await prisma.systemUpdateStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemUpdateStepUpdateManyArgs>(args: SelectSubset<T, SystemUpdateStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemUpdateSteps and returns the data updated in the database.
     * @param {SystemUpdateStepUpdateManyAndReturnArgs} args - Arguments to update many SystemUpdateSteps.
     * @example
     * // Update many SystemUpdateSteps
     * const systemUpdateStep = await prisma.systemUpdateStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemUpdateSteps and only return the `id`
     * const systemUpdateStepWithIdOnly = await prisma.systemUpdateStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemUpdateStepUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemUpdateStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemUpdateStepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemUpdateStep.
     * @param {SystemUpdateStepUpsertArgs} args - Arguments to update or create a SystemUpdateStep.
     * @example
     * // Update or create a SystemUpdateStep
     * const systemUpdateStep = await prisma.systemUpdateStep.upsert({
     *   create: {
     *     // ... data to create a SystemUpdateStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemUpdateStep we want to update
     *   }
     * })
     */
    upsert<T extends SystemUpdateStepUpsertArgs>(args: SelectSubset<T, SystemUpdateStepUpsertArgs<ExtArgs>>): Prisma__SystemUpdateStepClient<$Result.GetResult<Prisma.$SystemUpdateStepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemUpdateSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateStepCountArgs} args - Arguments to filter SystemUpdateSteps to count.
     * @example
     * // Count the number of SystemUpdateSteps
     * const count = await prisma.systemUpdateStep.count({
     *   where: {
     *     // ... the filter for the SystemUpdateSteps we want to count
     *   }
     * })
    **/
    count<T extends SystemUpdateStepCountArgs>(
      args?: Subset<T, SystemUpdateStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemUpdateStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemUpdateStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemUpdateStepAggregateArgs>(args: Subset<T, SystemUpdateStepAggregateArgs>): Prisma.PrismaPromise<GetSystemUpdateStepAggregateType<T>>

    /**
     * Group by SystemUpdateStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemUpdateStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemUpdateStepGroupByArgs['orderBy'] }
        : { orderBy?: SystemUpdateStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemUpdateStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemUpdateStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemUpdateStep model
   */
  readonly fields: SystemUpdateStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemUpdateStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemUpdateStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    update<T extends SystemUpdateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SystemUpdateDefaultArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemUpdateStep model
   */
  interface SystemUpdateStepFieldRefs {
    readonly id: FieldRef<"SystemUpdateStep", 'String'>
    readonly updateId: FieldRef<"SystemUpdateStep", 'String'>
    readonly title: FieldRef<"SystemUpdateStep", 'String'>
    readonly description: FieldRef<"SystemUpdateStep", 'String'>
    readonly progress: FieldRef<"SystemUpdateStep", 'Int'>
    readonly status: FieldRef<"SystemUpdateStep", 'String'>
    readonly order: FieldRef<"SystemUpdateStep", 'Int'>
    readonly createdAt: FieldRef<"SystemUpdateStep", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemUpdateStep", 'DateTime'>
    readonly completedAt: FieldRef<"SystemUpdateStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemUpdateStep findUnique
   */
  export type SystemUpdateStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdateStep
     */
    select?: SystemUpdateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdateStep
     */
    omit?: SystemUpdateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateStepInclude<ExtArgs> | null
    /**
     * Filter, which SystemUpdateStep to fetch.
     */
    where: SystemUpdateStepWhereUniqueInput
  }

  /**
   * SystemUpdateStep findUniqueOrThrow
   */
  export type SystemUpdateStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdateStep
     */
    select?: SystemUpdateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdateStep
     */
    omit?: SystemUpdateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateStepInclude<ExtArgs> | null
    /**
     * Filter, which SystemUpdateStep to fetch.
     */
    where: SystemUpdateStepWhereUniqueInput
  }

  /**
   * SystemUpdateStep findFirst
   */
  export type SystemUpdateStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdateStep
     */
    select?: SystemUpdateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdateStep
     */
    omit?: SystemUpdateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateStepInclude<ExtArgs> | null
    /**
     * Filter, which SystemUpdateStep to fetch.
     */
    where?: SystemUpdateStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemUpdateSteps to fetch.
     */
    orderBy?: SystemUpdateStepOrderByWithRelationInput | SystemUpdateStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemUpdateSteps.
     */
    cursor?: SystemUpdateStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemUpdateSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemUpdateSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemUpdateSteps.
     */
    distinct?: SystemUpdateStepScalarFieldEnum | SystemUpdateStepScalarFieldEnum[]
  }

  /**
   * SystemUpdateStep findFirstOrThrow
   */
  export type SystemUpdateStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdateStep
     */
    select?: SystemUpdateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdateStep
     */
    omit?: SystemUpdateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateStepInclude<ExtArgs> | null
    /**
     * Filter, which SystemUpdateStep to fetch.
     */
    where?: SystemUpdateStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemUpdateSteps to fetch.
     */
    orderBy?: SystemUpdateStepOrderByWithRelationInput | SystemUpdateStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemUpdateSteps.
     */
    cursor?: SystemUpdateStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemUpdateSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemUpdateSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemUpdateSteps.
     */
    distinct?: SystemUpdateStepScalarFieldEnum | SystemUpdateStepScalarFieldEnum[]
  }

  /**
   * SystemUpdateStep findMany
   */
  export type SystemUpdateStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdateStep
     */
    select?: SystemUpdateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdateStep
     */
    omit?: SystemUpdateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateStepInclude<ExtArgs> | null
    /**
     * Filter, which SystemUpdateSteps to fetch.
     */
    where?: SystemUpdateStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemUpdateSteps to fetch.
     */
    orderBy?: SystemUpdateStepOrderByWithRelationInput | SystemUpdateStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemUpdateSteps.
     */
    cursor?: SystemUpdateStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemUpdateSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemUpdateSteps.
     */
    skip?: number
    distinct?: SystemUpdateStepScalarFieldEnum | SystemUpdateStepScalarFieldEnum[]
  }

  /**
   * SystemUpdateStep create
   */
  export type SystemUpdateStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdateStep
     */
    select?: SystemUpdateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdateStep
     */
    omit?: SystemUpdateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateStepInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemUpdateStep.
     */
    data: XOR<SystemUpdateStepCreateInput, SystemUpdateStepUncheckedCreateInput>
  }

  /**
   * SystemUpdateStep createMany
   */
  export type SystemUpdateStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemUpdateSteps.
     */
    data: SystemUpdateStepCreateManyInput | SystemUpdateStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemUpdateStep createManyAndReturn
   */
  export type SystemUpdateStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdateStep
     */
    select?: SystemUpdateStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdateStep
     */
    omit?: SystemUpdateStepOmit<ExtArgs> | null
    /**
     * The data used to create many SystemUpdateSteps.
     */
    data: SystemUpdateStepCreateManyInput | SystemUpdateStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemUpdateStep update
   */
  export type SystemUpdateStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdateStep
     */
    select?: SystemUpdateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdateStep
     */
    omit?: SystemUpdateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateStepInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemUpdateStep.
     */
    data: XOR<SystemUpdateStepUpdateInput, SystemUpdateStepUncheckedUpdateInput>
    /**
     * Choose, which SystemUpdateStep to update.
     */
    where: SystemUpdateStepWhereUniqueInput
  }

  /**
   * SystemUpdateStep updateMany
   */
  export type SystemUpdateStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemUpdateSteps.
     */
    data: XOR<SystemUpdateStepUpdateManyMutationInput, SystemUpdateStepUncheckedUpdateManyInput>
    /**
     * Filter which SystemUpdateSteps to update
     */
    where?: SystemUpdateStepWhereInput
    /**
     * Limit how many SystemUpdateSteps to update.
     */
    limit?: number
  }

  /**
   * SystemUpdateStep updateManyAndReturn
   */
  export type SystemUpdateStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdateStep
     */
    select?: SystemUpdateStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdateStep
     */
    omit?: SystemUpdateStepOmit<ExtArgs> | null
    /**
     * The data used to update SystemUpdateSteps.
     */
    data: XOR<SystemUpdateStepUpdateManyMutationInput, SystemUpdateStepUncheckedUpdateManyInput>
    /**
     * Filter which SystemUpdateSteps to update
     */
    where?: SystemUpdateStepWhereInput
    /**
     * Limit how many SystemUpdateSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemUpdateStep upsert
   */
  export type SystemUpdateStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdateStep
     */
    select?: SystemUpdateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdateStep
     */
    omit?: SystemUpdateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateStepInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemUpdateStep to update in case it exists.
     */
    where: SystemUpdateStepWhereUniqueInput
    /**
     * In case the SystemUpdateStep found by the `where` argument doesn't exist, create a new SystemUpdateStep with this data.
     */
    create: XOR<SystemUpdateStepCreateInput, SystemUpdateStepUncheckedCreateInput>
    /**
     * In case the SystemUpdateStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemUpdateStepUpdateInput, SystemUpdateStepUncheckedUpdateInput>
  }

  /**
   * SystemUpdateStep delete
   */
  export type SystemUpdateStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdateStep
     */
    select?: SystemUpdateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdateStep
     */
    omit?: SystemUpdateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateStepInclude<ExtArgs> | null
    /**
     * Filter which SystemUpdateStep to delete.
     */
    where: SystemUpdateStepWhereUniqueInput
  }

  /**
   * SystemUpdateStep deleteMany
   */
  export type SystemUpdateStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemUpdateSteps to delete
     */
    where?: SystemUpdateStepWhereInput
    /**
     * Limit how many SystemUpdateSteps to delete.
     */
    limit?: number
  }

  /**
   * SystemUpdateStep without action
   */
  export type SystemUpdateStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdateStep
     */
    select?: SystemUpdateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdateStep
     */
    omit?: SystemUpdateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateStepInclude<ExtArgs> | null
  }


  /**
   * Model Platform
   */

  export type AggregatePlatform = {
    _count: PlatformCountAggregateOutputType | null
    _min: PlatformMinAggregateOutputType | null
    _max: PlatformMaxAggregateOutputType | null
  }

  export type PlatformMinAggregateOutputType = {
    id: string | null
    name: string | null
    logoUrl: string | null
    logoKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformMaxAggregateOutputType = {
    id: string | null
    name: string | null
    logoUrl: string | null
    logoKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformCountAggregateOutputType = {
    id: number
    name: number
    logoUrl: number
    logoKey: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlatformMinAggregateInputType = {
    id?: true
    name?: true
    logoUrl?: true
    logoKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformMaxAggregateInputType = {
    id?: true
    name?: true
    logoUrl?: true
    logoKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformCountAggregateInputType = {
    id?: true
    name?: true
    logoUrl?: true
    logoKey?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlatformAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Platform to aggregate.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Platforms
    **/
    _count?: true | PlatformCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformMaxAggregateInputType
  }

  export type GetPlatformAggregateType<T extends PlatformAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatform]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatform[P]>
      : GetScalarType<T[P], AggregatePlatform[P]>
  }




  export type PlatformGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformWhereInput
    orderBy?: PlatformOrderByWithAggregationInput | PlatformOrderByWithAggregationInput[]
    by: PlatformScalarFieldEnum[] | PlatformScalarFieldEnum
    having?: PlatformScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformCountAggregateInputType | true
    _min?: PlatformMinAggregateInputType
    _max?: PlatformMaxAggregateInputType
  }

  export type PlatformGroupByOutputType = {
    id: string
    name: string
    logoUrl: string | null
    logoKey: string | null
    createdAt: Date
    updatedAt: Date
    _count: PlatformCountAggregateOutputType | null
    _min: PlatformMinAggregateOutputType | null
    _max: PlatformMaxAggregateOutputType | null
  }

  type GetPlatformGroupByPayload<T extends PlatformGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformGroupByOutputType[P]>
        }
      >
    >


  export type PlatformSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logoUrl?: boolean
    logoKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["platform"]>

  export type PlatformSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logoUrl?: boolean
    logoKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["platform"]>

  export type PlatformSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logoUrl?: boolean
    logoKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["platform"]>

  export type PlatformSelectScalar = {
    id?: boolean
    name?: boolean
    logoUrl?: boolean
    logoKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlatformOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "logoUrl" | "logoKey" | "createdAt" | "updatedAt", ExtArgs["result"]["platform"]>

  export type $PlatformPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Platform"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      logoUrl: string | null
      logoKey: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["platform"]>
    composites: {}
  }

  type PlatformGetPayload<S extends boolean | null | undefined | PlatformDefaultArgs> = $Result.GetResult<Prisma.$PlatformPayload, S>

  type PlatformCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlatformFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlatformCountAggregateInputType | true
    }

  export interface PlatformDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Platform'], meta: { name: 'Platform' } }
    /**
     * Find zero or one Platform that matches the filter.
     * @param {PlatformFindUniqueArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformFindUniqueArgs>(args: SelectSubset<T, PlatformFindUniqueArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Platform that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlatformFindUniqueOrThrowArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Platform that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindFirstArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformFindFirstArgs>(args?: SelectSubset<T, PlatformFindFirstArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Platform that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindFirstOrThrowArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Platforms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Platforms
     * const platforms = await prisma.platform.findMany()
     * 
     * // Get first 10 Platforms
     * const platforms = await prisma.platform.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformWithIdOnly = await prisma.platform.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformFindManyArgs>(args?: SelectSubset<T, PlatformFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Platform.
     * @param {PlatformCreateArgs} args - Arguments to create a Platform.
     * @example
     * // Create one Platform
     * const Platform = await prisma.platform.create({
     *   data: {
     *     // ... data to create a Platform
     *   }
     * })
     * 
     */
    create<T extends PlatformCreateArgs>(args: SelectSubset<T, PlatformCreateArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Platforms.
     * @param {PlatformCreateManyArgs} args - Arguments to create many Platforms.
     * @example
     * // Create many Platforms
     * const platform = await prisma.platform.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformCreateManyArgs>(args?: SelectSubset<T, PlatformCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Platforms and returns the data saved in the database.
     * @param {PlatformCreateManyAndReturnArgs} args - Arguments to create many Platforms.
     * @example
     * // Create many Platforms
     * const platform = await prisma.platform.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Platforms and only return the `id`
     * const platformWithIdOnly = await prisma.platform.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlatformCreateManyAndReturnArgs>(args?: SelectSubset<T, PlatformCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Platform.
     * @param {PlatformDeleteArgs} args - Arguments to delete one Platform.
     * @example
     * // Delete one Platform
     * const Platform = await prisma.platform.delete({
     *   where: {
     *     // ... filter to delete one Platform
     *   }
     * })
     * 
     */
    delete<T extends PlatformDeleteArgs>(args: SelectSubset<T, PlatformDeleteArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Platform.
     * @param {PlatformUpdateArgs} args - Arguments to update one Platform.
     * @example
     * // Update one Platform
     * const platform = await prisma.platform.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformUpdateArgs>(args: SelectSubset<T, PlatformUpdateArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Platforms.
     * @param {PlatformDeleteManyArgs} args - Arguments to filter Platforms to delete.
     * @example
     * // Delete a few Platforms
     * const { count } = await prisma.platform.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformDeleteManyArgs>(args?: SelectSubset<T, PlatformDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Platforms
     * const platform = await prisma.platform.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformUpdateManyArgs>(args: SelectSubset<T, PlatformUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Platforms and returns the data updated in the database.
     * @param {PlatformUpdateManyAndReturnArgs} args - Arguments to update many Platforms.
     * @example
     * // Update many Platforms
     * const platform = await prisma.platform.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Platforms and only return the `id`
     * const platformWithIdOnly = await prisma.platform.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlatformUpdateManyAndReturnArgs>(args: SelectSubset<T, PlatformUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Platform.
     * @param {PlatformUpsertArgs} args - Arguments to update or create a Platform.
     * @example
     * // Update or create a Platform
     * const platform = await prisma.platform.upsert({
     *   create: {
     *     // ... data to create a Platform
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Platform we want to update
     *   }
     * })
     */
    upsert<T extends PlatformUpsertArgs>(args: SelectSubset<T, PlatformUpsertArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformCountArgs} args - Arguments to filter Platforms to count.
     * @example
     * // Count the number of Platforms
     * const count = await prisma.platform.count({
     *   where: {
     *     // ... the filter for the Platforms we want to count
     *   }
     * })
    **/
    count<T extends PlatformCountArgs>(
      args?: Subset<T, PlatformCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Platform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformAggregateArgs>(args: Subset<T, PlatformAggregateArgs>): Prisma.PrismaPromise<GetPlatformAggregateType<T>>

    /**
     * Group by Platform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformGroupByArgs['orderBy'] }
        : { orderBy?: PlatformGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Platform model
   */
  readonly fields: PlatformFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Platform.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Platform model
   */
  interface PlatformFieldRefs {
    readonly id: FieldRef<"Platform", 'String'>
    readonly name: FieldRef<"Platform", 'String'>
    readonly logoUrl: FieldRef<"Platform", 'String'>
    readonly logoKey: FieldRef<"Platform", 'String'>
    readonly createdAt: FieldRef<"Platform", 'DateTime'>
    readonly updatedAt: FieldRef<"Platform", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Platform findUnique
   */
  export type PlatformFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform findUniqueOrThrow
   */
  export type PlatformFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform findFirst
   */
  export type PlatformFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Platforms.
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Platforms.
     */
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Platform findFirstOrThrow
   */
  export type PlatformFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Platforms.
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Platforms.
     */
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Platform findMany
   */
  export type PlatformFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Filter, which Platforms to fetch.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Platforms.
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Platform create
   */
  export type PlatformCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * The data needed to create a Platform.
     */
    data: XOR<PlatformCreateInput, PlatformUncheckedCreateInput>
  }

  /**
   * Platform createMany
   */
  export type PlatformCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Platforms.
     */
    data: PlatformCreateManyInput | PlatformCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Platform createManyAndReturn
   */
  export type PlatformCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * The data used to create many Platforms.
     */
    data: PlatformCreateManyInput | PlatformCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Platform update
   */
  export type PlatformUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * The data needed to update a Platform.
     */
    data: XOR<PlatformUpdateInput, PlatformUncheckedUpdateInput>
    /**
     * Choose, which Platform to update.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform updateMany
   */
  export type PlatformUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Platforms.
     */
    data: XOR<PlatformUpdateManyMutationInput, PlatformUncheckedUpdateManyInput>
    /**
     * Filter which Platforms to update
     */
    where?: PlatformWhereInput
    /**
     * Limit how many Platforms to update.
     */
    limit?: number
  }

  /**
   * Platform updateManyAndReturn
   */
  export type PlatformUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * The data used to update Platforms.
     */
    data: XOR<PlatformUpdateManyMutationInput, PlatformUncheckedUpdateManyInput>
    /**
     * Filter which Platforms to update
     */
    where?: PlatformWhereInput
    /**
     * Limit how many Platforms to update.
     */
    limit?: number
  }

  /**
   * Platform upsert
   */
  export type PlatformUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * The filter to search for the Platform to update in case it exists.
     */
    where: PlatformWhereUniqueInput
    /**
     * In case the Platform found by the `where` argument doesn't exist, create a new Platform with this data.
     */
    create: XOR<PlatformCreateInput, PlatformUncheckedCreateInput>
    /**
     * In case the Platform was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformUpdateInput, PlatformUncheckedUpdateInput>
  }

  /**
   * Platform delete
   */
  export type PlatformDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Filter which Platform to delete.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform deleteMany
   */
  export type PlatformDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Platforms to delete
     */
    where?: PlatformWhereInput
    /**
     * Limit how many Platforms to delete.
     */
    limit?: number
  }

  /**
   * Platform without action
   */
  export type PlatformDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
  }


  /**
   * Model Changelog
   */

  export type AggregateChangelog = {
    _count: ChangelogCountAggregateOutputType | null
    _min: ChangelogMinAggregateOutputType | null
    _max: ChangelogMaxAggregateOutputType | null
  }

  export type ChangelogMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    version: string | null
    type: string | null
    isPublished: boolean | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
    releaseDate: Date | null
  }

  export type ChangelogMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    version: string | null
    type: string | null
    isPublished: boolean | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
    releaseDate: Date | null
  }

  export type ChangelogCountAggregateOutputType = {
    id: number
    title: number
    content: number
    version: number
    type: number
    isPublished: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    authorId: number
    releaseDate: number
    _all: number
  }


  export type ChangelogMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    version?: true
    type?: true
    isPublished?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    releaseDate?: true
  }

  export type ChangelogMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    version?: true
    type?: true
    isPublished?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    releaseDate?: true
  }

  export type ChangelogCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    version?: true
    type?: true
    isPublished?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    releaseDate?: true
    _all?: true
  }

  export type ChangelogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Changelog to aggregate.
     */
    where?: ChangelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Changelogs to fetch.
     */
    orderBy?: ChangelogOrderByWithRelationInput | ChangelogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChangelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Changelogs
    **/
    _count?: true | ChangelogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChangelogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChangelogMaxAggregateInputType
  }

  export type GetChangelogAggregateType<T extends ChangelogAggregateArgs> = {
        [P in keyof T & keyof AggregateChangelog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChangelog[P]>
      : GetScalarType<T[P], AggregateChangelog[P]>
  }




  export type ChangelogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangelogWhereInput
    orderBy?: ChangelogOrderByWithAggregationInput | ChangelogOrderByWithAggregationInput[]
    by: ChangelogScalarFieldEnum[] | ChangelogScalarFieldEnum
    having?: ChangelogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChangelogCountAggregateInputType | true
    _min?: ChangelogMinAggregateInputType
    _max?: ChangelogMaxAggregateInputType
  }

  export type ChangelogGroupByOutputType = {
    id: string
    title: string
    content: string
    version: string | null
    type: string
    isPublished: boolean
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    authorId: string
    releaseDate: Date | null
    _count: ChangelogCountAggregateOutputType | null
    _min: ChangelogMinAggregateOutputType | null
    _max: ChangelogMaxAggregateOutputType | null
  }

  type GetChangelogGroupByPayload<T extends ChangelogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChangelogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChangelogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChangelogGroupByOutputType[P]>
            : GetScalarType<T[P], ChangelogGroupByOutputType[P]>
        }
      >
    >


  export type ChangelogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    version?: boolean
    type?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    releaseDate?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changelog"]>

  export type ChangelogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    version?: boolean
    type?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    releaseDate?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changelog"]>

  export type ChangelogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    version?: boolean
    type?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    releaseDate?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changelog"]>

  export type ChangelogSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    version?: boolean
    type?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    releaseDate?: boolean
  }

  export type ChangelogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "version" | "type" | "isPublished" | "publishedAt" | "createdAt" | "updatedAt" | "authorId" | "releaseDate", ExtArgs["result"]["changelog"]>
  export type ChangelogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChangelogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChangelogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChangelogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Changelog"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      version: string | null
      type: string
      isPublished: boolean
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
      authorId: string
      releaseDate: Date | null
    }, ExtArgs["result"]["changelog"]>
    composites: {}
  }

  type ChangelogGetPayload<S extends boolean | null | undefined | ChangelogDefaultArgs> = $Result.GetResult<Prisma.$ChangelogPayload, S>

  type ChangelogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChangelogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChangelogCountAggregateInputType | true
    }

  export interface ChangelogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Changelog'], meta: { name: 'Changelog' } }
    /**
     * Find zero or one Changelog that matches the filter.
     * @param {ChangelogFindUniqueArgs} args - Arguments to find a Changelog
     * @example
     * // Get one Changelog
     * const changelog = await prisma.changelog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChangelogFindUniqueArgs>(args: SelectSubset<T, ChangelogFindUniqueArgs<ExtArgs>>): Prisma__ChangelogClient<$Result.GetResult<Prisma.$ChangelogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Changelog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChangelogFindUniqueOrThrowArgs} args - Arguments to find a Changelog
     * @example
     * // Get one Changelog
     * const changelog = await prisma.changelog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChangelogFindUniqueOrThrowArgs>(args: SelectSubset<T, ChangelogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChangelogClient<$Result.GetResult<Prisma.$ChangelogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Changelog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangelogFindFirstArgs} args - Arguments to find a Changelog
     * @example
     * // Get one Changelog
     * const changelog = await prisma.changelog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChangelogFindFirstArgs>(args?: SelectSubset<T, ChangelogFindFirstArgs<ExtArgs>>): Prisma__ChangelogClient<$Result.GetResult<Prisma.$ChangelogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Changelog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangelogFindFirstOrThrowArgs} args - Arguments to find a Changelog
     * @example
     * // Get one Changelog
     * const changelog = await prisma.changelog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChangelogFindFirstOrThrowArgs>(args?: SelectSubset<T, ChangelogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChangelogClient<$Result.GetResult<Prisma.$ChangelogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Changelogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangelogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Changelogs
     * const changelogs = await prisma.changelog.findMany()
     * 
     * // Get first 10 Changelogs
     * const changelogs = await prisma.changelog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const changelogWithIdOnly = await prisma.changelog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChangelogFindManyArgs>(args?: SelectSubset<T, ChangelogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangelogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Changelog.
     * @param {ChangelogCreateArgs} args - Arguments to create a Changelog.
     * @example
     * // Create one Changelog
     * const Changelog = await prisma.changelog.create({
     *   data: {
     *     // ... data to create a Changelog
     *   }
     * })
     * 
     */
    create<T extends ChangelogCreateArgs>(args: SelectSubset<T, ChangelogCreateArgs<ExtArgs>>): Prisma__ChangelogClient<$Result.GetResult<Prisma.$ChangelogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Changelogs.
     * @param {ChangelogCreateManyArgs} args - Arguments to create many Changelogs.
     * @example
     * // Create many Changelogs
     * const changelog = await prisma.changelog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChangelogCreateManyArgs>(args?: SelectSubset<T, ChangelogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Changelogs and returns the data saved in the database.
     * @param {ChangelogCreateManyAndReturnArgs} args - Arguments to create many Changelogs.
     * @example
     * // Create many Changelogs
     * const changelog = await prisma.changelog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Changelogs and only return the `id`
     * const changelogWithIdOnly = await prisma.changelog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChangelogCreateManyAndReturnArgs>(args?: SelectSubset<T, ChangelogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangelogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Changelog.
     * @param {ChangelogDeleteArgs} args - Arguments to delete one Changelog.
     * @example
     * // Delete one Changelog
     * const Changelog = await prisma.changelog.delete({
     *   where: {
     *     // ... filter to delete one Changelog
     *   }
     * })
     * 
     */
    delete<T extends ChangelogDeleteArgs>(args: SelectSubset<T, ChangelogDeleteArgs<ExtArgs>>): Prisma__ChangelogClient<$Result.GetResult<Prisma.$ChangelogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Changelog.
     * @param {ChangelogUpdateArgs} args - Arguments to update one Changelog.
     * @example
     * // Update one Changelog
     * const changelog = await prisma.changelog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChangelogUpdateArgs>(args: SelectSubset<T, ChangelogUpdateArgs<ExtArgs>>): Prisma__ChangelogClient<$Result.GetResult<Prisma.$ChangelogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Changelogs.
     * @param {ChangelogDeleteManyArgs} args - Arguments to filter Changelogs to delete.
     * @example
     * // Delete a few Changelogs
     * const { count } = await prisma.changelog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChangelogDeleteManyArgs>(args?: SelectSubset<T, ChangelogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Changelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangelogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Changelogs
     * const changelog = await prisma.changelog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChangelogUpdateManyArgs>(args: SelectSubset<T, ChangelogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Changelogs and returns the data updated in the database.
     * @param {ChangelogUpdateManyAndReturnArgs} args - Arguments to update many Changelogs.
     * @example
     * // Update many Changelogs
     * const changelog = await prisma.changelog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Changelogs and only return the `id`
     * const changelogWithIdOnly = await prisma.changelog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChangelogUpdateManyAndReturnArgs>(args: SelectSubset<T, ChangelogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangelogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Changelog.
     * @param {ChangelogUpsertArgs} args - Arguments to update or create a Changelog.
     * @example
     * // Update or create a Changelog
     * const changelog = await prisma.changelog.upsert({
     *   create: {
     *     // ... data to create a Changelog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Changelog we want to update
     *   }
     * })
     */
    upsert<T extends ChangelogUpsertArgs>(args: SelectSubset<T, ChangelogUpsertArgs<ExtArgs>>): Prisma__ChangelogClient<$Result.GetResult<Prisma.$ChangelogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Changelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangelogCountArgs} args - Arguments to filter Changelogs to count.
     * @example
     * // Count the number of Changelogs
     * const count = await prisma.changelog.count({
     *   where: {
     *     // ... the filter for the Changelogs we want to count
     *   }
     * })
    **/
    count<T extends ChangelogCountArgs>(
      args?: Subset<T, ChangelogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangelogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Changelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangelogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangelogAggregateArgs>(args: Subset<T, ChangelogAggregateArgs>): Prisma.PrismaPromise<GetChangelogAggregateType<T>>

    /**
     * Group by Changelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangelogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChangelogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChangelogGroupByArgs['orderBy'] }
        : { orderBy?: ChangelogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChangelogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChangelogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Changelog model
   */
  readonly fields: ChangelogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Changelog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChangelogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Changelog model
   */
  interface ChangelogFieldRefs {
    readonly id: FieldRef<"Changelog", 'String'>
    readonly title: FieldRef<"Changelog", 'String'>
    readonly content: FieldRef<"Changelog", 'String'>
    readonly version: FieldRef<"Changelog", 'String'>
    readonly type: FieldRef<"Changelog", 'String'>
    readonly isPublished: FieldRef<"Changelog", 'Boolean'>
    readonly publishedAt: FieldRef<"Changelog", 'DateTime'>
    readonly createdAt: FieldRef<"Changelog", 'DateTime'>
    readonly updatedAt: FieldRef<"Changelog", 'DateTime'>
    readonly authorId: FieldRef<"Changelog", 'String'>
    readonly releaseDate: FieldRef<"Changelog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Changelog findUnique
   */
  export type ChangelogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changelog
     */
    select?: ChangelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Changelog
     */
    omit?: ChangelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangelogInclude<ExtArgs> | null
    /**
     * Filter, which Changelog to fetch.
     */
    where: ChangelogWhereUniqueInput
  }

  /**
   * Changelog findUniqueOrThrow
   */
  export type ChangelogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changelog
     */
    select?: ChangelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Changelog
     */
    omit?: ChangelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangelogInclude<ExtArgs> | null
    /**
     * Filter, which Changelog to fetch.
     */
    where: ChangelogWhereUniqueInput
  }

  /**
   * Changelog findFirst
   */
  export type ChangelogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changelog
     */
    select?: ChangelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Changelog
     */
    omit?: ChangelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangelogInclude<ExtArgs> | null
    /**
     * Filter, which Changelog to fetch.
     */
    where?: ChangelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Changelogs to fetch.
     */
    orderBy?: ChangelogOrderByWithRelationInput | ChangelogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Changelogs.
     */
    cursor?: ChangelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Changelogs.
     */
    distinct?: ChangelogScalarFieldEnum | ChangelogScalarFieldEnum[]
  }

  /**
   * Changelog findFirstOrThrow
   */
  export type ChangelogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changelog
     */
    select?: ChangelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Changelog
     */
    omit?: ChangelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangelogInclude<ExtArgs> | null
    /**
     * Filter, which Changelog to fetch.
     */
    where?: ChangelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Changelogs to fetch.
     */
    orderBy?: ChangelogOrderByWithRelationInput | ChangelogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Changelogs.
     */
    cursor?: ChangelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Changelogs.
     */
    distinct?: ChangelogScalarFieldEnum | ChangelogScalarFieldEnum[]
  }

  /**
   * Changelog findMany
   */
  export type ChangelogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changelog
     */
    select?: ChangelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Changelog
     */
    omit?: ChangelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangelogInclude<ExtArgs> | null
    /**
     * Filter, which Changelogs to fetch.
     */
    where?: ChangelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Changelogs to fetch.
     */
    orderBy?: ChangelogOrderByWithRelationInput | ChangelogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Changelogs.
     */
    cursor?: ChangelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Changelogs.
     */
    skip?: number
    distinct?: ChangelogScalarFieldEnum | ChangelogScalarFieldEnum[]
  }

  /**
   * Changelog create
   */
  export type ChangelogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changelog
     */
    select?: ChangelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Changelog
     */
    omit?: ChangelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangelogInclude<ExtArgs> | null
    /**
     * The data needed to create a Changelog.
     */
    data: XOR<ChangelogCreateInput, ChangelogUncheckedCreateInput>
  }

  /**
   * Changelog createMany
   */
  export type ChangelogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Changelogs.
     */
    data: ChangelogCreateManyInput | ChangelogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Changelog createManyAndReturn
   */
  export type ChangelogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changelog
     */
    select?: ChangelogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Changelog
     */
    omit?: ChangelogOmit<ExtArgs> | null
    /**
     * The data used to create many Changelogs.
     */
    data: ChangelogCreateManyInput | ChangelogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangelogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Changelog update
   */
  export type ChangelogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changelog
     */
    select?: ChangelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Changelog
     */
    omit?: ChangelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangelogInclude<ExtArgs> | null
    /**
     * The data needed to update a Changelog.
     */
    data: XOR<ChangelogUpdateInput, ChangelogUncheckedUpdateInput>
    /**
     * Choose, which Changelog to update.
     */
    where: ChangelogWhereUniqueInput
  }

  /**
   * Changelog updateMany
   */
  export type ChangelogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Changelogs.
     */
    data: XOR<ChangelogUpdateManyMutationInput, ChangelogUncheckedUpdateManyInput>
    /**
     * Filter which Changelogs to update
     */
    where?: ChangelogWhereInput
    /**
     * Limit how many Changelogs to update.
     */
    limit?: number
  }

  /**
   * Changelog updateManyAndReturn
   */
  export type ChangelogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changelog
     */
    select?: ChangelogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Changelog
     */
    omit?: ChangelogOmit<ExtArgs> | null
    /**
     * The data used to update Changelogs.
     */
    data: XOR<ChangelogUpdateManyMutationInput, ChangelogUncheckedUpdateManyInput>
    /**
     * Filter which Changelogs to update
     */
    where?: ChangelogWhereInput
    /**
     * Limit how many Changelogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangelogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Changelog upsert
   */
  export type ChangelogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changelog
     */
    select?: ChangelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Changelog
     */
    omit?: ChangelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangelogInclude<ExtArgs> | null
    /**
     * The filter to search for the Changelog to update in case it exists.
     */
    where: ChangelogWhereUniqueInput
    /**
     * In case the Changelog found by the `where` argument doesn't exist, create a new Changelog with this data.
     */
    create: XOR<ChangelogCreateInput, ChangelogUncheckedCreateInput>
    /**
     * In case the Changelog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChangelogUpdateInput, ChangelogUncheckedUpdateInput>
  }

  /**
   * Changelog delete
   */
  export type ChangelogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changelog
     */
    select?: ChangelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Changelog
     */
    omit?: ChangelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangelogInclude<ExtArgs> | null
    /**
     * Filter which Changelog to delete.
     */
    where: ChangelogWhereUniqueInput
  }

  /**
   * Changelog deleteMany
   */
  export type ChangelogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Changelogs to delete
     */
    where?: ChangelogWhereInput
    /**
     * Limit how many Changelogs to delete.
     */
    limit?: number
  }

  /**
   * Changelog without action
   */
  export type ChangelogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changelog
     */
    select?: ChangelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Changelog
     */
    omit?: ChangelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangelogInclude<ExtArgs> | null
  }


  /**
   * Model AdminAuditLog
   */

  export type AggregateAdminAuditLog = {
    _count: AdminAuditLogCountAggregateOutputType | null
    _min: AdminAuditLogMinAggregateOutputType | null
    _max: AdminAuditLogMaxAggregateOutputType | null
  }

  export type AdminAuditLogMinAggregateOutputType = {
    id: string | null
    action: string | null
    targetType: string | null
    targetId: string | null
    targetName: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    errorMessage: string | null
    createdAt: Date | null
    adminId: string | null
  }

  export type AdminAuditLogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    targetType: string | null
    targetId: string | null
    targetName: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    errorMessage: string | null
    createdAt: Date | null
    adminId: string | null
  }

  export type AdminAuditLogCountAggregateOutputType = {
    id: number
    action: number
    targetType: number
    targetId: number
    targetName: number
    details: number
    ipAddress: number
    userAgent: number
    success: number
    errorMessage: number
    createdAt: number
    adminId: number
    _all: number
  }


  export type AdminAuditLogMinAggregateInputType = {
    id?: true
    action?: true
    targetType?: true
    targetId?: true
    targetName?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    createdAt?: true
    adminId?: true
  }

  export type AdminAuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    targetType?: true
    targetId?: true
    targetName?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    createdAt?: true
    adminId?: true
  }

  export type AdminAuditLogCountAggregateInputType = {
    id?: true
    action?: true
    targetType?: true
    targetId?: true
    targetName?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    createdAt?: true
    adminId?: true
    _all?: true
  }

  export type AdminAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditLog to aggregate.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAuditLogs
    **/
    _count?: true | AdminAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAuditLogMaxAggregateInputType
  }

  export type GetAdminAuditLogAggregateType<T extends AdminAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAuditLog[P]>
      : GetScalarType<T[P], AggregateAdminAuditLog[P]>
  }




  export type AdminAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditLogWhereInput
    orderBy?: AdminAuditLogOrderByWithAggregationInput | AdminAuditLogOrderByWithAggregationInput[]
    by: AdminAuditLogScalarFieldEnum[] | AdminAuditLogScalarFieldEnum
    having?: AdminAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAuditLogCountAggregateInputType | true
    _min?: AdminAuditLogMinAggregateInputType
    _max?: AdminAuditLogMaxAggregateInputType
  }

  export type AdminAuditLogGroupByOutputType = {
    id: string
    action: string
    targetType: string
    targetId: string | null
    targetName: string | null
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean
    errorMessage: string | null
    createdAt: Date
    adminId: string
    _count: AdminAuditLogCountAggregateOutputType | null
    _min: AdminAuditLogMinAggregateOutputType | null
    _max: AdminAuditLogMaxAggregateOutputType | null
  }

  type GetAdminAuditLogGroupByPayload<T extends AdminAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AdminAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    targetName?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    adminId?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    targetName?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    adminId?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    targetName?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    adminId?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    targetName?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    adminId?: boolean
  }

  export type AdminAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "targetType" | "targetId" | "targetName" | "details" | "ipAddress" | "userAgent" | "success" | "errorMessage" | "createdAt" | "adminId", ExtArgs["result"]["adminAuditLog"]>
  export type AdminAuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminAuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminAuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAuditLog"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      targetType: string
      targetId: string | null
      targetName: string | null
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      success: boolean
      errorMessage: string | null
      createdAt: Date
      adminId: string
    }, ExtArgs["result"]["adminAuditLog"]>
    composites: {}
  }

  type AdminAuditLogGetPayload<S extends boolean | null | undefined | AdminAuditLogDefaultArgs> = $Result.GetResult<Prisma.$AdminAuditLogPayload, S>

  type AdminAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminAuditLogCountAggregateInputType | true
    }

  export interface AdminAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAuditLog'], meta: { name: 'AdminAuditLog' } }
    /**
     * Find zero or one AdminAuditLog that matches the filter.
     * @param {AdminAuditLogFindUniqueArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminAuditLogFindUniqueArgs>(args: SelectSubset<T, AdminAuditLogFindUniqueArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminAuditLogFindUniqueOrThrowArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindFirstArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminAuditLogFindFirstArgs>(args?: SelectSubset<T, AdminAuditLogFindFirstArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindFirstOrThrowArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAuditLogs
     * const adminAuditLogs = await prisma.adminAuditLog.findMany()
     * 
     * // Get first 10 AdminAuditLogs
     * const adminAuditLogs = await prisma.adminAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminAuditLogFindManyArgs>(args?: SelectSubset<T, AdminAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminAuditLog.
     * @param {AdminAuditLogCreateArgs} args - Arguments to create a AdminAuditLog.
     * @example
     * // Create one AdminAuditLog
     * const AdminAuditLog = await prisma.adminAuditLog.create({
     *   data: {
     *     // ... data to create a AdminAuditLog
     *   }
     * })
     * 
     */
    create<T extends AdminAuditLogCreateArgs>(args: SelectSubset<T, AdminAuditLogCreateArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminAuditLogs.
     * @param {AdminAuditLogCreateManyArgs} args - Arguments to create many AdminAuditLogs.
     * @example
     * // Create many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminAuditLogCreateManyArgs>(args?: SelectSubset<T, AdminAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminAuditLogs and returns the data saved in the database.
     * @param {AdminAuditLogCreateManyAndReturnArgs} args - Arguments to create many AdminAuditLogs.
     * @example
     * // Create many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminAuditLogs and only return the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminAuditLog.
     * @param {AdminAuditLogDeleteArgs} args - Arguments to delete one AdminAuditLog.
     * @example
     * // Delete one AdminAuditLog
     * const AdminAuditLog = await prisma.adminAuditLog.delete({
     *   where: {
     *     // ... filter to delete one AdminAuditLog
     *   }
     * })
     * 
     */
    delete<T extends AdminAuditLogDeleteArgs>(args: SelectSubset<T, AdminAuditLogDeleteArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminAuditLog.
     * @param {AdminAuditLogUpdateArgs} args - Arguments to update one AdminAuditLog.
     * @example
     * // Update one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminAuditLogUpdateArgs>(args: SelectSubset<T, AdminAuditLogUpdateArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminAuditLogs.
     * @param {AdminAuditLogDeleteManyArgs} args - Arguments to filter AdminAuditLogs to delete.
     * @example
     * // Delete a few AdminAuditLogs
     * const { count } = await prisma.adminAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminAuditLogDeleteManyArgs>(args?: SelectSubset<T, AdminAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminAuditLogUpdateManyArgs>(args: SelectSubset<T, AdminAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuditLogs and returns the data updated in the database.
     * @param {AdminAuditLogUpdateManyAndReturnArgs} args - Arguments to update many AdminAuditLogs.
     * @example
     * // Update many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminAuditLogs and only return the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminAuditLog.
     * @param {AdminAuditLogUpsertArgs} args - Arguments to update or create a AdminAuditLog.
     * @example
     * // Update or create a AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.upsert({
     *   create: {
     *     // ... data to create a AdminAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AdminAuditLogUpsertArgs>(args: SelectSubset<T, AdminAuditLogUpsertArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogCountArgs} args - Arguments to filter AdminAuditLogs to count.
     * @example
     * // Count the number of AdminAuditLogs
     * const count = await prisma.adminAuditLog.count({
     *   where: {
     *     // ... the filter for the AdminAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AdminAuditLogCountArgs>(
      args?: Subset<T, AdminAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAuditLogAggregateArgs>(args: Subset<T, AdminAuditLogAggregateArgs>): Prisma.PrismaPromise<GetAdminAuditLogAggregateType<T>>

    /**
     * Group by AdminAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AdminAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAuditLog model
   */
  readonly fields: AdminAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAuditLog model
   */
  interface AdminAuditLogFieldRefs {
    readonly id: FieldRef<"AdminAuditLog", 'String'>
    readonly action: FieldRef<"AdminAuditLog", 'String'>
    readonly targetType: FieldRef<"AdminAuditLog", 'String'>
    readonly targetId: FieldRef<"AdminAuditLog", 'String'>
    readonly targetName: FieldRef<"AdminAuditLog", 'String'>
    readonly details: FieldRef<"AdminAuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AdminAuditLog", 'String'>
    readonly userAgent: FieldRef<"AdminAuditLog", 'String'>
    readonly success: FieldRef<"AdminAuditLog", 'Boolean'>
    readonly errorMessage: FieldRef<"AdminAuditLog", 'String'>
    readonly createdAt: FieldRef<"AdminAuditLog", 'DateTime'>
    readonly adminId: FieldRef<"AdminAuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdminAuditLog findUnique
   */
  export type AdminAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog findUniqueOrThrow
   */
  export type AdminAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog findFirst
   */
  export type AdminAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditLogs.
     */
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog findFirstOrThrow
   */
  export type AdminAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditLogs.
     */
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog findMany
   */
  export type AdminAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLogs to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog create
   */
  export type AdminAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAuditLog.
     */
    data: XOR<AdminAuditLogCreateInput, AdminAuditLogUncheckedCreateInput>
  }

  /**
   * AdminAuditLog createMany
   */
  export type AdminAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAuditLogs.
     */
    data: AdminAuditLogCreateManyInput | AdminAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAuditLog createManyAndReturn
   */
  export type AdminAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AdminAuditLogs.
     */
    data: AdminAuditLogCreateManyInput | AdminAuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuditLog update
   */
  export type AdminAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAuditLog.
     */
    data: XOR<AdminAuditLogUpdateInput, AdminAuditLogUncheckedUpdateInput>
    /**
     * Choose, which AdminAuditLog to update.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog updateMany
   */
  export type AdminAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAuditLogs.
     */
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuditLogs to update
     */
    where?: AdminAuditLogWhereInput
    /**
     * Limit how many AdminAuditLogs to update.
     */
    limit?: number
  }

  /**
   * AdminAuditLog updateManyAndReturn
   */
  export type AdminAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AdminAuditLogs.
     */
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuditLogs to update
     */
    where?: AdminAuditLogWhereInput
    /**
     * Limit how many AdminAuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuditLog upsert
   */
  export type AdminAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAuditLog to update in case it exists.
     */
    where: AdminAuditLogWhereUniqueInput
    /**
     * In case the AdminAuditLog found by the `where` argument doesn't exist, create a new AdminAuditLog with this data.
     */
    create: XOR<AdminAuditLogCreateInput, AdminAuditLogUncheckedCreateInput>
    /**
     * In case the AdminAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAuditLogUpdateInput, AdminAuditLogUncheckedUpdateInput>
  }

  /**
   * AdminAuditLog delete
   */
  export type AdminAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter which AdminAuditLog to delete.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog deleteMany
   */
  export type AdminAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditLogs to delete
     */
    where?: AdminAuditLogWhereInput
    /**
     * Limit how many AdminAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AdminAuditLog without action
   */
  export type AdminAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
  }


  /**
   * Model session_history
   */

  export type AggregateSession_history = {
    _count: Session_historyCountAggregateOutputType | null
    _avg: Session_historyAvgAggregateOutputType | null
    _sum: Session_historySumAggregateOutputType | null
    _min: Session_historyMinAggregateOutputType | null
    _max: Session_historyMaxAggregateOutputType | null
  }

  export type Session_historyAvgAggregateOutputType = {
    playtime: number | null
  }

  export type Session_historySumAggregateOutputType = {
    playtime: number | null
  }

  export type Session_historyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    gameId: string | null
    gameName: string | null
    startTime: Date | null
    endTime: Date | null
    playtime: number | null
    platform: string | null
    status: string | null
    createdAt: Date | null
  }

  export type Session_historyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    gameId: string | null
    gameName: string | null
    startTime: Date | null
    endTime: Date | null
    playtime: number | null
    platform: string | null
    status: string | null
    createdAt: Date | null
  }

  export type Session_historyCountAggregateOutputType = {
    id: number
    userId: number
    gameId: number
    gameName: number
    startTime: number
    endTime: number
    playtime: number
    campaigns: number
    platform: number
    status: number
    createdAt: number
    _all: number
  }


  export type Session_historyAvgAggregateInputType = {
    playtime?: true
  }

  export type Session_historySumAggregateInputType = {
    playtime?: true
  }

  export type Session_historyMinAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    gameName?: true
    startTime?: true
    endTime?: true
    playtime?: true
    platform?: true
    status?: true
    createdAt?: true
  }

  export type Session_historyMaxAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    gameName?: true
    startTime?: true
    endTime?: true
    playtime?: true
    platform?: true
    status?: true
    createdAt?: true
  }

  export type Session_historyCountAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    gameName?: true
    startTime?: true
    endTime?: true
    playtime?: true
    campaigns?: true
    platform?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type Session_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session_history to aggregate.
     */
    where?: session_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_histories to fetch.
     */
    orderBy?: session_historyOrderByWithRelationInput | session_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: session_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned session_histories
    **/
    _count?: true | Session_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Session_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Session_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Session_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Session_historyMaxAggregateInputType
  }

  export type GetSession_historyAggregateType<T extends Session_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateSession_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession_history[P]>
      : GetScalarType<T[P], AggregateSession_history[P]>
  }




  export type session_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_historyWhereInput
    orderBy?: session_historyOrderByWithAggregationInput | session_historyOrderByWithAggregationInput[]
    by: Session_historyScalarFieldEnum[] | Session_historyScalarFieldEnum
    having?: session_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Session_historyCountAggregateInputType | true
    _avg?: Session_historyAvgAggregateInputType
    _sum?: Session_historySumAggregateInputType
    _min?: Session_historyMinAggregateInputType
    _max?: Session_historyMaxAggregateInputType
  }

  export type Session_historyGroupByOutputType = {
    id: string
    userId: string
    gameId: string
    gameName: string
    startTime: Date
    endTime: Date
    playtime: number
    campaigns: JsonValue | null
    platform: string | null
    status: string | null
    createdAt: Date
    _count: Session_historyCountAggregateOutputType | null
    _avg: Session_historyAvgAggregateOutputType | null
    _sum: Session_historySumAggregateOutputType | null
    _min: Session_historyMinAggregateOutputType | null
    _max: Session_historyMaxAggregateOutputType | null
  }

  type GetSession_historyGroupByPayload<T extends session_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Session_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Session_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Session_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Session_historyGroupByOutputType[P]>
        }
      >
    >


  export type session_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    gameName?: boolean
    startTime?: boolean
    endTime?: boolean
    playtime?: boolean
    campaigns?: boolean
    platform?: boolean
    status?: boolean
    createdAt?: boolean
    games?: boolean | GameDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session_history"]>

  export type session_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    gameName?: boolean
    startTime?: boolean
    endTime?: boolean
    playtime?: boolean
    campaigns?: boolean
    platform?: boolean
    status?: boolean
    createdAt?: boolean
    games?: boolean | GameDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session_history"]>

  export type session_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    gameName?: boolean
    startTime?: boolean
    endTime?: boolean
    playtime?: boolean
    campaigns?: boolean
    platform?: boolean
    status?: boolean
    createdAt?: boolean
    games?: boolean | GameDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session_history"]>

  export type session_historySelectScalar = {
    id?: boolean
    userId?: boolean
    gameId?: boolean
    gameName?: boolean
    startTime?: boolean
    endTime?: boolean
    playtime?: boolean
    campaigns?: boolean
    platform?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type session_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "gameId" | "gameName" | "startTime" | "endTime" | "playtime" | "campaigns" | "platform" | "status" | "createdAt", ExtArgs["result"]["session_history"]>
  export type session_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | GameDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type session_historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | GameDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type session_historyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | GameDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $session_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "session_history"
    objects: {
      games: Prisma.$GamePayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      gameId: string
      gameName: string
      startTime: Date
      endTime: Date
      playtime: number
      campaigns: Prisma.JsonValue | null
      platform: string | null
      status: string | null
      createdAt: Date
    }, ExtArgs["result"]["session_history"]>
    composites: {}
  }

  type session_historyGetPayload<S extends boolean | null | undefined | session_historyDefaultArgs> = $Result.GetResult<Prisma.$session_historyPayload, S>

  type session_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<session_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Session_historyCountAggregateInputType | true
    }

  export interface session_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session_history'], meta: { name: 'session_history' } }
    /**
     * Find zero or one Session_history that matches the filter.
     * @param {session_historyFindUniqueArgs} args - Arguments to find a Session_history
     * @example
     * // Get one Session_history
     * const session_history = await prisma.session_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends session_historyFindUniqueArgs>(args: SelectSubset<T, session_historyFindUniqueArgs<ExtArgs>>): Prisma__session_historyClient<$Result.GetResult<Prisma.$session_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {session_historyFindUniqueOrThrowArgs} args - Arguments to find a Session_history
     * @example
     * // Get one Session_history
     * const session_history = await prisma.session_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends session_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, session_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__session_historyClient<$Result.GetResult<Prisma.$session_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_historyFindFirstArgs} args - Arguments to find a Session_history
     * @example
     * // Get one Session_history
     * const session_history = await prisma.session_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends session_historyFindFirstArgs>(args?: SelectSubset<T, session_historyFindFirstArgs<ExtArgs>>): Prisma__session_historyClient<$Result.GetResult<Prisma.$session_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_historyFindFirstOrThrowArgs} args - Arguments to find a Session_history
     * @example
     * // Get one Session_history
     * const session_history = await prisma.session_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends session_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, session_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__session_historyClient<$Result.GetResult<Prisma.$session_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Session_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Session_histories
     * const session_histories = await prisma.session_history.findMany()
     * 
     * // Get first 10 Session_histories
     * const session_histories = await prisma.session_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const session_historyWithIdOnly = await prisma.session_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends session_historyFindManyArgs>(args?: SelectSubset<T, session_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session_history.
     * @param {session_historyCreateArgs} args - Arguments to create a Session_history.
     * @example
     * // Create one Session_history
     * const Session_history = await prisma.session_history.create({
     *   data: {
     *     // ... data to create a Session_history
     *   }
     * })
     * 
     */
    create<T extends session_historyCreateArgs>(args: SelectSubset<T, session_historyCreateArgs<ExtArgs>>): Prisma__session_historyClient<$Result.GetResult<Prisma.$session_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Session_histories.
     * @param {session_historyCreateManyArgs} args - Arguments to create many Session_histories.
     * @example
     * // Create many Session_histories
     * const session_history = await prisma.session_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends session_historyCreateManyArgs>(args?: SelectSubset<T, session_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Session_histories and returns the data saved in the database.
     * @param {session_historyCreateManyAndReturnArgs} args - Arguments to create many Session_histories.
     * @example
     * // Create many Session_histories
     * const session_history = await prisma.session_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Session_histories and only return the `id`
     * const session_historyWithIdOnly = await prisma.session_history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends session_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, session_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_historyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session_history.
     * @param {session_historyDeleteArgs} args - Arguments to delete one Session_history.
     * @example
     * // Delete one Session_history
     * const Session_history = await prisma.session_history.delete({
     *   where: {
     *     // ... filter to delete one Session_history
     *   }
     * })
     * 
     */
    delete<T extends session_historyDeleteArgs>(args: SelectSubset<T, session_historyDeleteArgs<ExtArgs>>): Prisma__session_historyClient<$Result.GetResult<Prisma.$session_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session_history.
     * @param {session_historyUpdateArgs} args - Arguments to update one Session_history.
     * @example
     * // Update one Session_history
     * const session_history = await prisma.session_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends session_historyUpdateArgs>(args: SelectSubset<T, session_historyUpdateArgs<ExtArgs>>): Prisma__session_historyClient<$Result.GetResult<Prisma.$session_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Session_histories.
     * @param {session_historyDeleteManyArgs} args - Arguments to filter Session_histories to delete.
     * @example
     * // Delete a few Session_histories
     * const { count } = await prisma.session_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends session_historyDeleteManyArgs>(args?: SelectSubset<T, session_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Session_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Session_histories
     * const session_history = await prisma.session_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends session_historyUpdateManyArgs>(args: SelectSubset<T, session_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Session_histories and returns the data updated in the database.
     * @param {session_historyUpdateManyAndReturnArgs} args - Arguments to update many Session_histories.
     * @example
     * // Update many Session_histories
     * const session_history = await prisma.session_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Session_histories and only return the `id`
     * const session_historyWithIdOnly = await prisma.session_history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends session_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, session_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_historyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session_history.
     * @param {session_historyUpsertArgs} args - Arguments to update or create a Session_history.
     * @example
     * // Update or create a Session_history
     * const session_history = await prisma.session_history.upsert({
     *   create: {
     *     // ... data to create a Session_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session_history we want to update
     *   }
     * })
     */
    upsert<T extends session_historyUpsertArgs>(args: SelectSubset<T, session_historyUpsertArgs<ExtArgs>>): Prisma__session_historyClient<$Result.GetResult<Prisma.$session_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Session_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_historyCountArgs} args - Arguments to filter Session_histories to count.
     * @example
     * // Count the number of Session_histories
     * const count = await prisma.session_history.count({
     *   where: {
     *     // ... the filter for the Session_histories we want to count
     *   }
     * })
    **/
    count<T extends session_historyCountArgs>(
      args?: Subset<T, session_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Session_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Session_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Session_historyAggregateArgs>(args: Subset<T, Session_historyAggregateArgs>): Prisma.PrismaPromise<GetSession_historyAggregateType<T>>

    /**
     * Group by Session_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends session_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: session_historyGroupByArgs['orderBy'] }
        : { orderBy?: session_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, session_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSession_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the session_history model
   */
  readonly fields: session_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__session_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the session_history model
   */
  interface session_historyFieldRefs {
    readonly id: FieldRef<"session_history", 'String'>
    readonly userId: FieldRef<"session_history", 'String'>
    readonly gameId: FieldRef<"session_history", 'String'>
    readonly gameName: FieldRef<"session_history", 'String'>
    readonly startTime: FieldRef<"session_history", 'DateTime'>
    readonly endTime: FieldRef<"session_history", 'DateTime'>
    readonly playtime: FieldRef<"session_history", 'Int'>
    readonly campaigns: FieldRef<"session_history", 'Json'>
    readonly platform: FieldRef<"session_history", 'String'>
    readonly status: FieldRef<"session_history", 'String'>
    readonly createdAt: FieldRef<"session_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * session_history findUnique
   */
  export type session_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_history
     */
    select?: session_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_history
     */
    omit?: session_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_historyInclude<ExtArgs> | null
    /**
     * Filter, which session_history to fetch.
     */
    where: session_historyWhereUniqueInput
  }

  /**
   * session_history findUniqueOrThrow
   */
  export type session_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_history
     */
    select?: session_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_history
     */
    omit?: session_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_historyInclude<ExtArgs> | null
    /**
     * Filter, which session_history to fetch.
     */
    where: session_historyWhereUniqueInput
  }

  /**
   * session_history findFirst
   */
  export type session_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_history
     */
    select?: session_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_history
     */
    omit?: session_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_historyInclude<ExtArgs> | null
    /**
     * Filter, which session_history to fetch.
     */
    where?: session_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_histories to fetch.
     */
    orderBy?: session_historyOrderByWithRelationInput | session_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for session_histories.
     */
    cursor?: session_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of session_histories.
     */
    distinct?: Session_historyScalarFieldEnum | Session_historyScalarFieldEnum[]
  }

  /**
   * session_history findFirstOrThrow
   */
  export type session_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_history
     */
    select?: session_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_history
     */
    omit?: session_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_historyInclude<ExtArgs> | null
    /**
     * Filter, which session_history to fetch.
     */
    where?: session_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_histories to fetch.
     */
    orderBy?: session_historyOrderByWithRelationInput | session_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for session_histories.
     */
    cursor?: session_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of session_histories.
     */
    distinct?: Session_historyScalarFieldEnum | Session_historyScalarFieldEnum[]
  }

  /**
   * session_history findMany
   */
  export type session_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_history
     */
    select?: session_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_history
     */
    omit?: session_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_historyInclude<ExtArgs> | null
    /**
     * Filter, which session_histories to fetch.
     */
    where?: session_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_histories to fetch.
     */
    orderBy?: session_historyOrderByWithRelationInput | session_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing session_histories.
     */
    cursor?: session_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_histories.
     */
    skip?: number
    distinct?: Session_historyScalarFieldEnum | Session_historyScalarFieldEnum[]
  }

  /**
   * session_history create
   */
  export type session_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_history
     */
    select?: session_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_history
     */
    omit?: session_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a session_history.
     */
    data: XOR<session_historyCreateInput, session_historyUncheckedCreateInput>
  }

  /**
   * session_history createMany
   */
  export type session_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many session_histories.
     */
    data: session_historyCreateManyInput | session_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * session_history createManyAndReturn
   */
  export type session_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_history
     */
    select?: session_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the session_history
     */
    omit?: session_historyOmit<ExtArgs> | null
    /**
     * The data used to create many session_histories.
     */
    data: session_historyCreateManyInput | session_historyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_historyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * session_history update
   */
  export type session_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_history
     */
    select?: session_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_history
     */
    omit?: session_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a session_history.
     */
    data: XOR<session_historyUpdateInput, session_historyUncheckedUpdateInput>
    /**
     * Choose, which session_history to update.
     */
    where: session_historyWhereUniqueInput
  }

  /**
   * session_history updateMany
   */
  export type session_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update session_histories.
     */
    data: XOR<session_historyUpdateManyMutationInput, session_historyUncheckedUpdateManyInput>
    /**
     * Filter which session_histories to update
     */
    where?: session_historyWhereInput
    /**
     * Limit how many session_histories to update.
     */
    limit?: number
  }

  /**
   * session_history updateManyAndReturn
   */
  export type session_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_history
     */
    select?: session_historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the session_history
     */
    omit?: session_historyOmit<ExtArgs> | null
    /**
     * The data used to update session_histories.
     */
    data: XOR<session_historyUpdateManyMutationInput, session_historyUncheckedUpdateManyInput>
    /**
     * Filter which session_histories to update
     */
    where?: session_historyWhereInput
    /**
     * Limit how many session_histories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_historyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * session_history upsert
   */
  export type session_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_history
     */
    select?: session_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_history
     */
    omit?: session_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the session_history to update in case it exists.
     */
    where: session_historyWhereUniqueInput
    /**
     * In case the session_history found by the `where` argument doesn't exist, create a new session_history with this data.
     */
    create: XOR<session_historyCreateInput, session_historyUncheckedCreateInput>
    /**
     * In case the session_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<session_historyUpdateInput, session_historyUncheckedUpdateInput>
  }

  /**
   * session_history delete
   */
  export type session_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_history
     */
    select?: session_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_history
     */
    omit?: session_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_historyInclude<ExtArgs> | null
    /**
     * Filter which session_history to delete.
     */
    where: session_historyWhereUniqueInput
  }

  /**
   * session_history deleteMany
   */
  export type session_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session_histories to delete
     */
    where?: session_historyWhereInput
    /**
     * Limit how many session_histories to delete.
     */
    limit?: number
  }

  /**
   * session_history without action
   */
  export type session_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_history
     */
    select?: session_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_history
     */
    omit?: session_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_historyInclude<ExtArgs> | null
  }


  /**
   * Model user_libraries
   */

  export type AggregateUser_libraries = {
    _count: User_librariesCountAggregateOutputType | null
    _avg: User_librariesAvgAggregateOutputType | null
    _sum: User_librariesSumAggregateOutputType | null
    _min: User_librariesMinAggregateOutputType | null
    _max: User_librariesMaxAggregateOutputType | null
  }

  export type User_librariesAvgAggregateOutputType = {
    totalGames: number | null
    totalPlaytime: number | null
  }

  export type User_librariesSumAggregateOutputType = {
    totalGames: number | null
    totalPlaytime: number | null
  }

  export type User_librariesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    version: string | null
    totalGames: number | null
    totalPlaytime: number | null
    lastUpdated: Date | null
  }

  export type User_librariesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    version: string | null
    totalGames: number | null
    totalPlaytime: number | null
    lastUpdated: Date | null
  }

  export type User_librariesCountAggregateOutputType = {
    id: number
    userId: number
    version: number
    totalGames: number
    totalPlaytime: number
    lastUpdated: number
    _all: number
  }


  export type User_librariesAvgAggregateInputType = {
    totalGames?: true
    totalPlaytime?: true
  }

  export type User_librariesSumAggregateInputType = {
    totalGames?: true
    totalPlaytime?: true
  }

  export type User_librariesMinAggregateInputType = {
    id?: true
    userId?: true
    version?: true
    totalGames?: true
    totalPlaytime?: true
    lastUpdated?: true
  }

  export type User_librariesMaxAggregateInputType = {
    id?: true
    userId?: true
    version?: true
    totalGames?: true
    totalPlaytime?: true
    lastUpdated?: true
  }

  export type User_librariesCountAggregateInputType = {
    id?: true
    userId?: true
    version?: true
    totalGames?: true
    totalPlaytime?: true
    lastUpdated?: true
    _all?: true
  }

  export type User_librariesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_libraries to aggregate.
     */
    where?: user_librariesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_libraries to fetch.
     */
    orderBy?: user_librariesOrderByWithRelationInput | user_librariesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_librariesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_libraries
    **/
    _count?: true | User_librariesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_librariesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_librariesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_librariesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_librariesMaxAggregateInputType
  }

  export type GetUser_librariesAggregateType<T extends User_librariesAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_libraries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_libraries[P]>
      : GetScalarType<T[P], AggregateUser_libraries[P]>
  }




  export type user_librariesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_librariesWhereInput
    orderBy?: user_librariesOrderByWithAggregationInput | user_librariesOrderByWithAggregationInput[]
    by: User_librariesScalarFieldEnum[] | User_librariesScalarFieldEnum
    having?: user_librariesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_librariesCountAggregateInputType | true
    _avg?: User_librariesAvgAggregateInputType
    _sum?: User_librariesSumAggregateInputType
    _min?: User_librariesMinAggregateInputType
    _max?: User_librariesMaxAggregateInputType
  }

  export type User_librariesGroupByOutputType = {
    id: string
    userId: string
    version: string
    totalGames: number
    totalPlaytime: number
    lastUpdated: Date
    _count: User_librariesCountAggregateOutputType | null
    _avg: User_librariesAvgAggregateOutputType | null
    _sum: User_librariesSumAggregateOutputType | null
    _min: User_librariesMinAggregateOutputType | null
    _max: User_librariesMaxAggregateOutputType | null
  }

  type GetUser_librariesGroupByPayload<T extends user_librariesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_librariesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_librariesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_librariesGroupByOutputType[P]>
            : GetScalarType<T[P], User_librariesGroupByOutputType[P]>
        }
      >
    >


  export type user_librariesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    version?: boolean
    totalGames?: boolean
    totalPlaytime?: boolean
    lastUpdated?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_libraries"]>

  export type user_librariesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    version?: boolean
    totalGames?: boolean
    totalPlaytime?: boolean
    lastUpdated?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_libraries"]>

  export type user_librariesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    version?: boolean
    totalGames?: boolean
    totalPlaytime?: boolean
    lastUpdated?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_libraries"]>

  export type user_librariesSelectScalar = {
    id?: boolean
    userId?: boolean
    version?: boolean
    totalGames?: boolean
    totalPlaytime?: boolean
    lastUpdated?: boolean
  }

  export type user_librariesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "version" | "totalGames" | "totalPlaytime" | "lastUpdated", ExtArgs["result"]["user_libraries"]>
  export type user_librariesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type user_librariesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type user_librariesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $user_librariesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_libraries"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      version: string
      totalGames: number
      totalPlaytime: number
      lastUpdated: Date
    }, ExtArgs["result"]["user_libraries"]>
    composites: {}
  }

  type user_librariesGetPayload<S extends boolean | null | undefined | user_librariesDefaultArgs> = $Result.GetResult<Prisma.$user_librariesPayload, S>

  type user_librariesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_librariesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_librariesCountAggregateInputType | true
    }

  export interface user_librariesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_libraries'], meta: { name: 'user_libraries' } }
    /**
     * Find zero or one User_libraries that matches the filter.
     * @param {user_librariesFindUniqueArgs} args - Arguments to find a User_libraries
     * @example
     * // Get one User_libraries
     * const user_libraries = await prisma.user_libraries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_librariesFindUniqueArgs>(args: SelectSubset<T, user_librariesFindUniqueArgs<ExtArgs>>): Prisma__user_librariesClient<$Result.GetResult<Prisma.$user_librariesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_libraries that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_librariesFindUniqueOrThrowArgs} args - Arguments to find a User_libraries
     * @example
     * // Get one User_libraries
     * const user_libraries = await prisma.user_libraries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_librariesFindUniqueOrThrowArgs>(args: SelectSubset<T, user_librariesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_librariesClient<$Result.GetResult<Prisma.$user_librariesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_libraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_librariesFindFirstArgs} args - Arguments to find a User_libraries
     * @example
     * // Get one User_libraries
     * const user_libraries = await prisma.user_libraries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_librariesFindFirstArgs>(args?: SelectSubset<T, user_librariesFindFirstArgs<ExtArgs>>): Prisma__user_librariesClient<$Result.GetResult<Prisma.$user_librariesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_libraries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_librariesFindFirstOrThrowArgs} args - Arguments to find a User_libraries
     * @example
     * // Get one User_libraries
     * const user_libraries = await prisma.user_libraries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_librariesFindFirstOrThrowArgs>(args?: SelectSubset<T, user_librariesFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_librariesClient<$Result.GetResult<Prisma.$user_librariesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_libraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_librariesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_libraries
     * const user_libraries = await prisma.user_libraries.findMany()
     * 
     * // Get first 10 User_libraries
     * const user_libraries = await prisma.user_libraries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_librariesWithIdOnly = await prisma.user_libraries.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_librariesFindManyArgs>(args?: SelectSubset<T, user_librariesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_librariesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_libraries.
     * @param {user_librariesCreateArgs} args - Arguments to create a User_libraries.
     * @example
     * // Create one User_libraries
     * const User_libraries = await prisma.user_libraries.create({
     *   data: {
     *     // ... data to create a User_libraries
     *   }
     * })
     * 
     */
    create<T extends user_librariesCreateArgs>(args: SelectSubset<T, user_librariesCreateArgs<ExtArgs>>): Prisma__user_librariesClient<$Result.GetResult<Prisma.$user_librariesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_libraries.
     * @param {user_librariesCreateManyArgs} args - Arguments to create many User_libraries.
     * @example
     * // Create many User_libraries
     * const user_libraries = await prisma.user_libraries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_librariesCreateManyArgs>(args?: SelectSubset<T, user_librariesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_libraries and returns the data saved in the database.
     * @param {user_librariesCreateManyAndReturnArgs} args - Arguments to create many User_libraries.
     * @example
     * // Create many User_libraries
     * const user_libraries = await prisma.user_libraries.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_libraries and only return the `id`
     * const user_librariesWithIdOnly = await prisma.user_libraries.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_librariesCreateManyAndReturnArgs>(args?: SelectSubset<T, user_librariesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_librariesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_libraries.
     * @param {user_librariesDeleteArgs} args - Arguments to delete one User_libraries.
     * @example
     * // Delete one User_libraries
     * const User_libraries = await prisma.user_libraries.delete({
     *   where: {
     *     // ... filter to delete one User_libraries
     *   }
     * })
     * 
     */
    delete<T extends user_librariesDeleteArgs>(args: SelectSubset<T, user_librariesDeleteArgs<ExtArgs>>): Prisma__user_librariesClient<$Result.GetResult<Prisma.$user_librariesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_libraries.
     * @param {user_librariesUpdateArgs} args - Arguments to update one User_libraries.
     * @example
     * // Update one User_libraries
     * const user_libraries = await prisma.user_libraries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_librariesUpdateArgs>(args: SelectSubset<T, user_librariesUpdateArgs<ExtArgs>>): Prisma__user_librariesClient<$Result.GetResult<Prisma.$user_librariesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_libraries.
     * @param {user_librariesDeleteManyArgs} args - Arguments to filter User_libraries to delete.
     * @example
     * // Delete a few User_libraries
     * const { count } = await prisma.user_libraries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_librariesDeleteManyArgs>(args?: SelectSubset<T, user_librariesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_libraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_librariesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_libraries
     * const user_libraries = await prisma.user_libraries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_librariesUpdateManyArgs>(args: SelectSubset<T, user_librariesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_libraries and returns the data updated in the database.
     * @param {user_librariesUpdateManyAndReturnArgs} args - Arguments to update many User_libraries.
     * @example
     * // Update many User_libraries
     * const user_libraries = await prisma.user_libraries.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_libraries and only return the `id`
     * const user_librariesWithIdOnly = await prisma.user_libraries.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_librariesUpdateManyAndReturnArgs>(args: SelectSubset<T, user_librariesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_librariesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_libraries.
     * @param {user_librariesUpsertArgs} args - Arguments to update or create a User_libraries.
     * @example
     * // Update or create a User_libraries
     * const user_libraries = await prisma.user_libraries.upsert({
     *   create: {
     *     // ... data to create a User_libraries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_libraries we want to update
     *   }
     * })
     */
    upsert<T extends user_librariesUpsertArgs>(args: SelectSubset<T, user_librariesUpsertArgs<ExtArgs>>): Prisma__user_librariesClient<$Result.GetResult<Prisma.$user_librariesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_libraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_librariesCountArgs} args - Arguments to filter User_libraries to count.
     * @example
     * // Count the number of User_libraries
     * const count = await prisma.user_libraries.count({
     *   where: {
     *     // ... the filter for the User_libraries we want to count
     *   }
     * })
    **/
    count<T extends user_librariesCountArgs>(
      args?: Subset<T, user_librariesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_librariesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_libraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_librariesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_librariesAggregateArgs>(args: Subset<T, User_librariesAggregateArgs>): Prisma.PrismaPromise<GetUser_librariesAggregateType<T>>

    /**
     * Group by User_libraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_librariesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_librariesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_librariesGroupByArgs['orderBy'] }
        : { orderBy?: user_librariesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_librariesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_librariesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_libraries model
   */
  readonly fields: user_librariesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_libraries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_librariesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_libraries model
   */
  interface user_librariesFieldRefs {
    readonly id: FieldRef<"user_libraries", 'String'>
    readonly userId: FieldRef<"user_libraries", 'String'>
    readonly version: FieldRef<"user_libraries", 'String'>
    readonly totalGames: FieldRef<"user_libraries", 'Int'>
    readonly totalPlaytime: FieldRef<"user_libraries", 'Int'>
    readonly lastUpdated: FieldRef<"user_libraries", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_libraries findUnique
   */
  export type user_librariesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_libraries
     */
    select?: user_librariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_libraries
     */
    omit?: user_librariesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_librariesInclude<ExtArgs> | null
    /**
     * Filter, which user_libraries to fetch.
     */
    where: user_librariesWhereUniqueInput
  }

  /**
   * user_libraries findUniqueOrThrow
   */
  export type user_librariesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_libraries
     */
    select?: user_librariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_libraries
     */
    omit?: user_librariesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_librariesInclude<ExtArgs> | null
    /**
     * Filter, which user_libraries to fetch.
     */
    where: user_librariesWhereUniqueInput
  }

  /**
   * user_libraries findFirst
   */
  export type user_librariesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_libraries
     */
    select?: user_librariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_libraries
     */
    omit?: user_librariesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_librariesInclude<ExtArgs> | null
    /**
     * Filter, which user_libraries to fetch.
     */
    where?: user_librariesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_libraries to fetch.
     */
    orderBy?: user_librariesOrderByWithRelationInput | user_librariesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_libraries.
     */
    cursor?: user_librariesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_libraries.
     */
    distinct?: User_librariesScalarFieldEnum | User_librariesScalarFieldEnum[]
  }

  /**
   * user_libraries findFirstOrThrow
   */
  export type user_librariesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_libraries
     */
    select?: user_librariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_libraries
     */
    omit?: user_librariesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_librariesInclude<ExtArgs> | null
    /**
     * Filter, which user_libraries to fetch.
     */
    where?: user_librariesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_libraries to fetch.
     */
    orderBy?: user_librariesOrderByWithRelationInput | user_librariesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_libraries.
     */
    cursor?: user_librariesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_libraries.
     */
    distinct?: User_librariesScalarFieldEnum | User_librariesScalarFieldEnum[]
  }

  /**
   * user_libraries findMany
   */
  export type user_librariesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_libraries
     */
    select?: user_librariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_libraries
     */
    omit?: user_librariesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_librariesInclude<ExtArgs> | null
    /**
     * Filter, which user_libraries to fetch.
     */
    where?: user_librariesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_libraries to fetch.
     */
    orderBy?: user_librariesOrderByWithRelationInput | user_librariesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_libraries.
     */
    cursor?: user_librariesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_libraries.
     */
    skip?: number
    distinct?: User_librariesScalarFieldEnum | User_librariesScalarFieldEnum[]
  }

  /**
   * user_libraries create
   */
  export type user_librariesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_libraries
     */
    select?: user_librariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_libraries
     */
    omit?: user_librariesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_librariesInclude<ExtArgs> | null
    /**
     * The data needed to create a user_libraries.
     */
    data: XOR<user_librariesCreateInput, user_librariesUncheckedCreateInput>
  }

  /**
   * user_libraries createMany
   */
  export type user_librariesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_libraries.
     */
    data: user_librariesCreateManyInput | user_librariesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_libraries createManyAndReturn
   */
  export type user_librariesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_libraries
     */
    select?: user_librariesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_libraries
     */
    omit?: user_librariesOmit<ExtArgs> | null
    /**
     * The data used to create many user_libraries.
     */
    data: user_librariesCreateManyInput | user_librariesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_librariesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_libraries update
   */
  export type user_librariesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_libraries
     */
    select?: user_librariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_libraries
     */
    omit?: user_librariesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_librariesInclude<ExtArgs> | null
    /**
     * The data needed to update a user_libraries.
     */
    data: XOR<user_librariesUpdateInput, user_librariesUncheckedUpdateInput>
    /**
     * Choose, which user_libraries to update.
     */
    where: user_librariesWhereUniqueInput
  }

  /**
   * user_libraries updateMany
   */
  export type user_librariesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_libraries.
     */
    data: XOR<user_librariesUpdateManyMutationInput, user_librariesUncheckedUpdateManyInput>
    /**
     * Filter which user_libraries to update
     */
    where?: user_librariesWhereInput
    /**
     * Limit how many user_libraries to update.
     */
    limit?: number
  }

  /**
   * user_libraries updateManyAndReturn
   */
  export type user_librariesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_libraries
     */
    select?: user_librariesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_libraries
     */
    omit?: user_librariesOmit<ExtArgs> | null
    /**
     * The data used to update user_libraries.
     */
    data: XOR<user_librariesUpdateManyMutationInput, user_librariesUncheckedUpdateManyInput>
    /**
     * Filter which user_libraries to update
     */
    where?: user_librariesWhereInput
    /**
     * Limit how many user_libraries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_librariesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_libraries upsert
   */
  export type user_librariesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_libraries
     */
    select?: user_librariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_libraries
     */
    omit?: user_librariesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_librariesInclude<ExtArgs> | null
    /**
     * The filter to search for the user_libraries to update in case it exists.
     */
    where: user_librariesWhereUniqueInput
    /**
     * In case the user_libraries found by the `where` argument doesn't exist, create a new user_libraries with this data.
     */
    create: XOR<user_librariesCreateInput, user_librariesUncheckedCreateInput>
    /**
     * In case the user_libraries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_librariesUpdateInput, user_librariesUncheckedUpdateInput>
  }

  /**
   * user_libraries delete
   */
  export type user_librariesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_libraries
     */
    select?: user_librariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_libraries
     */
    omit?: user_librariesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_librariesInclude<ExtArgs> | null
    /**
     * Filter which user_libraries to delete.
     */
    where: user_librariesWhereUniqueInput
  }

  /**
   * user_libraries deleteMany
   */
  export type user_librariesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_libraries to delete
     */
    where?: user_librariesWhereInput
    /**
     * Limit how many user_libraries to delete.
     */
    limit?: number
  }

  /**
   * user_libraries without action
   */
  export type user_librariesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_libraries
     */
    select?: user_librariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_libraries
     */
    omit?: user_librariesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_librariesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    username: 'username',
    createdAt: 'createdAt',
    lastActive: 'lastActive',
    role: 'role',
    updatedAt: 'updatedAt',
    password: 'password',
    profileImage: 'profileImage',
    profileImageKey: 'profileImageKey',
    status: 'status'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    serviceName: 'serviceName',
    keyName: 'keyName',
    keyValue: 'keyValue',
    isActive: 'isActive',
    isGlobal: 'isGlobal',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastUsed: 'lastUsed'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    name: 'name',
    cover: 'cover',
    firstReleaseDate: 'firstReleaseDate',
    genres: 'genres',
    platforms: 'platforms',
    summary: 'summary',
    rating: 'rating',
    developer: 'developer',
    developers: 'developers',
    publisher: 'publisher',
    publishers: 'publishers',
    steamData: 'steamData',
    igdbData: 'igdbData',
    hltbData: 'hltbData',
    metacriticData: 'metacriticData',
    cachedAt: 'cachedAt',
    lastAccessed: 'lastAccessed',
    accessCount: 'accessCount',
    coverKey: 'coverKey'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const LibraryEntryScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    category: 'category',
    playtime: 'playtime',
    rating: 'rating',
    notes: 'notes',
    lastPlayed: 'lastPlayed',
    progress: 'progress',
    addedAt: 'addedAt',
    isPublic: 'isPublic',
    tags: 'tags',
    updatedAt: 'updatedAt',
    userId: 'userId',
    priority: 'priority'
  };

  export type LibraryEntryScalarFieldEnum = (typeof LibraryEntryScalarFieldEnum)[keyof typeof LibraryEntryScalarFieldEnum]


  export const UserPreferencesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    preferredPlatform: 'preferredPlatform',
    preferredStatus: 'preferredStatus',
    includeDLCs: 'includeDLCs',
    selectedDLCs: 'selectedDLCs',
    selectedCampaigns: 'selectedCampaigns',
    preferredVersion: 'preferredVersion',
    gameSpecificPrefs: 'gameSpecificPrefs',
    autoLoadHLTB: 'autoLoadHLTB',
    autoLoadMetacritic: 'autoLoadMetacritic',
    autoGenerateCampaigns: 'autoGenerateCampaigns'
  };

  export type UserPreferencesScalarFieldEnum = (typeof UserPreferencesScalarFieldEnum)[keyof typeof UserPreferencesScalarFieldEnum]


  export const GameSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gameId: 'gameId',
    gameName: 'gameName',
    startTime: 'startTime',
    endTime: 'endTime',
    playtime: 'playtime',
    isActive: 'isActive',
    campaigns: 'campaigns',
    platform: 'platform',
    status: 'status'
  };

  export type GameSessionScalarFieldEnum = (typeof GameSessionScalarFieldEnum)[keyof typeof GameSessionScalarFieldEnum]


  export const UserStatsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalPlayTime: 'totalPlayTime',
    totalSessions: 'totalSessions',
    gamesPlayed: 'gamesPlayed',
    gamesCompleted: 'gamesCompleted',
    lastPlayedGame: 'lastPlayedGame',
    lastPlayedAt: 'lastPlayedAt',
    weeklyStats: 'weeklyStats',
    monthlyStats: 'monthlyStats',
    achievements: 'achievements'
  };

  export type UserStatsScalarFieldEnum = (typeof UserStatsScalarFieldEnum)[keyof typeof UserStatsScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    name: 'name',
    description: 'description',
    averageDuration: 'averageDuration',
    customProperties: 'customProperties',
    parentId: 'parentId',
    isAutoGenerated: 'isAutoGenerated',
    isMainCampaign: 'isMainCampaign',
    difficulty: 'difficulty',
    features: 'features',
    createdAt: 'createdAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const PageVisitScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    page: 'page',
    visitedAt: 'visitedAt',
    metadata: 'metadata'
  };

  export type PageVisitScalarFieldEnum = (typeof PageVisitScalarFieldEnum)[keyof typeof PageVisitScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    isRead: 'isRead',
    isGlobal: 'isGlobal',
    metadata: 'metadata',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SystemUpdateScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    version: 'version',
    type: 'type',
    status: 'status',
    progress: 'progress',
    priority: 'priority',
    category: 'category',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt'
  };

  export type SystemUpdateScalarFieldEnum = (typeof SystemUpdateScalarFieldEnum)[keyof typeof SystemUpdateScalarFieldEnum]


  export const SystemUpdateStepScalarFieldEnum: {
    id: 'id',
    updateId: 'updateId',
    title: 'title',
    description: 'description',
    progress: 'progress',
    status: 'status',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt'
  };

  export type SystemUpdateStepScalarFieldEnum = (typeof SystemUpdateStepScalarFieldEnum)[keyof typeof SystemUpdateStepScalarFieldEnum]


  export const PlatformScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logoUrl: 'logoUrl',
    logoKey: 'logoKey',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlatformScalarFieldEnum = (typeof PlatformScalarFieldEnum)[keyof typeof PlatformScalarFieldEnum]


  export const ChangelogScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    version: 'version',
    type: 'type',
    isPublished: 'isPublished',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authorId: 'authorId',
    releaseDate: 'releaseDate'
  };

  export type ChangelogScalarFieldEnum = (typeof ChangelogScalarFieldEnum)[keyof typeof ChangelogScalarFieldEnum]


  export const AdminAuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    targetType: 'targetType',
    targetId: 'targetId',
    targetName: 'targetName',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    success: 'success',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    adminId: 'adminId'
  };

  export type AdminAuditLogScalarFieldEnum = (typeof AdminAuditLogScalarFieldEnum)[keyof typeof AdminAuditLogScalarFieldEnum]


  export const Session_historyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gameId: 'gameId',
    gameName: 'gameName',
    startTime: 'startTime',
    endTime: 'endTime',
    playtime: 'playtime',
    campaigns: 'campaigns',
    platform: 'platform',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type Session_historyScalarFieldEnum = (typeof Session_historyScalarFieldEnum)[keyof typeof Session_historyScalarFieldEnum]


  export const User_librariesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    version: 'version',
    totalGames: 'totalGames',
    totalPlaytime: 'totalPlaytime',
    lastUpdated: 'lastUpdated'
  };

  export type User_librariesScalarFieldEnum = (typeof User_librariesScalarFieldEnum)[keyof typeof User_librariesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    lastActive?: DateTimeFilter<"User"> | Date | string
    role?: StringFilter<"User"> | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    password?: StringNullableFilter<"User"> | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    profileImageKey?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    adminAuditLogs?: AdminAuditLogListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    changelogs?: ChangelogListRelationFilter
    sessions?: GameSessionListRelationFilter
    libraryEntries?: LibraryEntryListRelationFilter
    notifications?: NotificationListRelationFilter
    pageVisits?: PageVisitListRelationFilter
    session_history?: Session_historyListRelationFilter
    user_libraries?: XOR<User_librariesNullableScalarRelationFilter, user_librariesWhereInput> | null
    preferences?: XOR<UserPreferencesNullableScalarRelationFilter, UserPreferencesWhereInput> | null
    userStats?: XOR<UserStatsNullableScalarRelationFilter, UserStatsWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastActive?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    profileImageKey?: SortOrderInput | SortOrder
    status?: SortOrder
    adminAuditLogs?: AdminAuditLogOrderByRelationAggregateInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    changelogs?: ChangelogOrderByRelationAggregateInput
    sessions?: GameSessionOrderByRelationAggregateInput
    libraryEntries?: LibraryEntryOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    pageVisits?: PageVisitOrderByRelationAggregateInput
    session_history?: session_historyOrderByRelationAggregateInput
    user_libraries?: user_librariesOrderByWithRelationInput
    preferences?: UserPreferencesOrderByWithRelationInput
    userStats?: UserStatsOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    lastActive?: DateTimeFilter<"User"> | Date | string
    role?: StringFilter<"User"> | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    password?: StringNullableFilter<"User"> | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    profileImageKey?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    adminAuditLogs?: AdminAuditLogListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    changelogs?: ChangelogListRelationFilter
    sessions?: GameSessionListRelationFilter
    libraryEntries?: LibraryEntryListRelationFilter
    notifications?: NotificationListRelationFilter
    pageVisits?: PageVisitListRelationFilter
    session_history?: Session_historyListRelationFilter
    user_libraries?: XOR<User_librariesNullableScalarRelationFilter, user_librariesWhereInput> | null
    preferences?: XOR<UserPreferencesNullableScalarRelationFilter, UserPreferencesWhereInput> | null
    userStats?: XOR<UserStatsNullableScalarRelationFilter, UserStatsWhereInput> | null
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastActive?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    profileImageKey?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastActive?: DateTimeWithAggregatesFilter<"User"> | Date | string
    role?: StringWithAggregatesFilter<"User"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileImageKey?: StringNullableWithAggregatesFilter<"User"> | string | null
    status?: StringWithAggregatesFilter<"User"> | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    userId?: StringNullableFilter<"ApiKey"> | string | null
    serviceName?: StringFilter<"ApiKey"> | string
    keyName?: StringFilter<"ApiKey"> | string
    keyValue?: StringFilter<"ApiKey"> | string
    isActive?: BoolFilter<"ApiKey"> | boolean
    isGlobal?: BoolFilter<"ApiKey"> | boolean
    metadata?: JsonNullableFilter<"ApiKey">
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    lastUsed?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    serviceName?: SortOrder
    keyName?: SortOrder
    keyValue?: SortOrder
    isActive?: SortOrder
    isGlobal?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serviceName_userId?: ApiKeyServiceNameUserIdCompoundUniqueInput
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    userId?: StringNullableFilter<"ApiKey"> | string | null
    serviceName?: StringFilter<"ApiKey"> | string
    keyName?: StringFilter<"ApiKey"> | string
    keyValue?: StringFilter<"ApiKey"> | string
    isActive?: BoolFilter<"ApiKey"> | boolean
    isGlobal?: BoolFilter<"ApiKey"> | boolean
    metadata?: JsonNullableFilter<"ApiKey">
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    lastUsed?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "serviceName_userId">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    serviceName?: SortOrder
    keyName?: SortOrder
    keyValue?: SortOrder
    isActive?: SortOrder
    isGlobal?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    userId?: StringNullableWithAggregatesFilter<"ApiKey"> | string | null
    serviceName?: StringWithAggregatesFilter<"ApiKey"> | string
    keyName?: StringWithAggregatesFilter<"ApiKey"> | string
    keyValue?: StringWithAggregatesFilter<"ApiKey"> | string
    isActive?: BoolWithAggregatesFilter<"ApiKey"> | boolean
    isGlobal?: BoolWithAggregatesFilter<"ApiKey"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"ApiKey">
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    lastUsed?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
  }

  export type GameWhereInput = {
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    id?: StringFilter<"Game"> | string
    name?: StringFilter<"Game"> | string
    cover?: StringNullableFilter<"Game"> | string | null
    firstReleaseDate?: DateTimeNullableFilter<"Game"> | Date | string | null
    genres?: JsonNullableFilter<"Game">
    platforms?: JsonNullableFilter<"Game">
    summary?: StringNullableFilter<"Game"> | string | null
    rating?: FloatNullableFilter<"Game"> | number | null
    developer?: StringNullableFilter<"Game"> | string | null
    developers?: JsonNullableFilter<"Game">
    publisher?: StringNullableFilter<"Game"> | string | null
    publishers?: JsonNullableFilter<"Game">
    steamData?: JsonNullableFilter<"Game">
    igdbData?: JsonNullableFilter<"Game">
    hltbData?: JsonNullableFilter<"Game">
    metacriticData?: JsonNullableFilter<"Game">
    cachedAt?: DateTimeFilter<"Game"> | Date | string
    lastAccessed?: DateTimeFilter<"Game"> | Date | string
    accessCount?: IntFilter<"Game"> | number
    coverKey?: StringNullableFilter<"Game"> | string | null
    campaigns?: CampaignListRelationFilter
    sessions?: GameSessionListRelationFilter
    libraryEntries?: LibraryEntryListRelationFilter
    session_history?: Session_historyListRelationFilter
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    cover?: SortOrderInput | SortOrder
    firstReleaseDate?: SortOrderInput | SortOrder
    genres?: SortOrderInput | SortOrder
    platforms?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    developer?: SortOrderInput | SortOrder
    developers?: SortOrderInput | SortOrder
    publisher?: SortOrderInput | SortOrder
    publishers?: SortOrderInput | SortOrder
    steamData?: SortOrderInput | SortOrder
    igdbData?: SortOrderInput | SortOrder
    hltbData?: SortOrderInput | SortOrder
    metacriticData?: SortOrderInput | SortOrder
    cachedAt?: SortOrder
    lastAccessed?: SortOrder
    accessCount?: SortOrder
    coverKey?: SortOrderInput | SortOrder
    campaigns?: CampaignOrderByRelationAggregateInput
    sessions?: GameSessionOrderByRelationAggregateInput
    libraryEntries?: LibraryEntryOrderByRelationAggregateInput
    session_history?: session_historyOrderByRelationAggregateInput
  }

  export type GameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    name?: StringFilter<"Game"> | string
    cover?: StringNullableFilter<"Game"> | string | null
    firstReleaseDate?: DateTimeNullableFilter<"Game"> | Date | string | null
    genres?: JsonNullableFilter<"Game">
    platforms?: JsonNullableFilter<"Game">
    summary?: StringNullableFilter<"Game"> | string | null
    rating?: FloatNullableFilter<"Game"> | number | null
    developer?: StringNullableFilter<"Game"> | string | null
    developers?: JsonNullableFilter<"Game">
    publisher?: StringNullableFilter<"Game"> | string | null
    publishers?: JsonNullableFilter<"Game">
    steamData?: JsonNullableFilter<"Game">
    igdbData?: JsonNullableFilter<"Game">
    hltbData?: JsonNullableFilter<"Game">
    metacriticData?: JsonNullableFilter<"Game">
    cachedAt?: DateTimeFilter<"Game"> | Date | string
    lastAccessed?: DateTimeFilter<"Game"> | Date | string
    accessCount?: IntFilter<"Game"> | number
    coverKey?: StringNullableFilter<"Game"> | string | null
    campaigns?: CampaignListRelationFilter
    sessions?: GameSessionListRelationFilter
    libraryEntries?: LibraryEntryListRelationFilter
    session_history?: Session_historyListRelationFilter
  }, "id">

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    cover?: SortOrderInput | SortOrder
    firstReleaseDate?: SortOrderInput | SortOrder
    genres?: SortOrderInput | SortOrder
    platforms?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    developer?: SortOrderInput | SortOrder
    developers?: SortOrderInput | SortOrder
    publisher?: SortOrderInput | SortOrder
    publishers?: SortOrderInput | SortOrder
    steamData?: SortOrderInput | SortOrder
    igdbData?: SortOrderInput | SortOrder
    hltbData?: SortOrderInput | SortOrder
    metacriticData?: SortOrderInput | SortOrder
    cachedAt?: SortOrder
    lastAccessed?: SortOrder
    accessCount?: SortOrder
    coverKey?: SortOrderInput | SortOrder
    _count?: GameCountOrderByAggregateInput
    _avg?: GameAvgOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
    _sum?: GameSumOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    OR?: GameScalarWhereWithAggregatesInput[]
    NOT?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Game"> | string
    name?: StringWithAggregatesFilter<"Game"> | string
    cover?: StringNullableWithAggregatesFilter<"Game"> | string | null
    firstReleaseDate?: DateTimeNullableWithAggregatesFilter<"Game"> | Date | string | null
    genres?: JsonNullableWithAggregatesFilter<"Game">
    platforms?: JsonNullableWithAggregatesFilter<"Game">
    summary?: StringNullableWithAggregatesFilter<"Game"> | string | null
    rating?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    developer?: StringNullableWithAggregatesFilter<"Game"> | string | null
    developers?: JsonNullableWithAggregatesFilter<"Game">
    publisher?: StringNullableWithAggregatesFilter<"Game"> | string | null
    publishers?: JsonNullableWithAggregatesFilter<"Game">
    steamData?: JsonNullableWithAggregatesFilter<"Game">
    igdbData?: JsonNullableWithAggregatesFilter<"Game">
    hltbData?: JsonNullableWithAggregatesFilter<"Game">
    metacriticData?: JsonNullableWithAggregatesFilter<"Game">
    cachedAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    lastAccessed?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    accessCount?: IntWithAggregatesFilter<"Game"> | number
    coverKey?: StringNullableWithAggregatesFilter<"Game"> | string | null
  }

  export type LibraryEntryWhereInput = {
    AND?: LibraryEntryWhereInput | LibraryEntryWhereInput[]
    OR?: LibraryEntryWhereInput[]
    NOT?: LibraryEntryWhereInput | LibraryEntryWhereInput[]
    id?: StringFilter<"LibraryEntry"> | string
    gameId?: StringFilter<"LibraryEntry"> | string
    category?: StringFilter<"LibraryEntry"> | string
    playtime?: IntFilter<"LibraryEntry"> | number
    rating?: FloatNullableFilter<"LibraryEntry"> | number | null
    notes?: StringNullableFilter<"LibraryEntry"> | string | null
    lastPlayed?: DateTimeNullableFilter<"LibraryEntry"> | Date | string | null
    progress?: IntFilter<"LibraryEntry"> | number
    addedAt?: DateTimeFilter<"LibraryEntry"> | Date | string
    isPublic?: BoolFilter<"LibraryEntry"> | boolean
    tags?: JsonNullableFilter<"LibraryEntry">
    updatedAt?: DateTimeFilter<"LibraryEntry"> | Date | string
    userId?: StringFilter<"LibraryEntry"> | string
    priority?: IntFilter<"LibraryEntry"> | number
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LibraryEntryOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    category?: SortOrder
    playtime?: SortOrder
    rating?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    lastPlayed?: SortOrderInput | SortOrder
    progress?: SortOrder
    addedAt?: SortOrder
    isPublic?: SortOrder
    tags?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    game?: GameOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LibraryEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_gameId?: LibraryEntryUserIdGameIdCompoundUniqueInput
    AND?: LibraryEntryWhereInput | LibraryEntryWhereInput[]
    OR?: LibraryEntryWhereInput[]
    NOT?: LibraryEntryWhereInput | LibraryEntryWhereInput[]
    gameId?: StringFilter<"LibraryEntry"> | string
    category?: StringFilter<"LibraryEntry"> | string
    playtime?: IntFilter<"LibraryEntry"> | number
    rating?: FloatNullableFilter<"LibraryEntry"> | number | null
    notes?: StringNullableFilter<"LibraryEntry"> | string | null
    lastPlayed?: DateTimeNullableFilter<"LibraryEntry"> | Date | string | null
    progress?: IntFilter<"LibraryEntry"> | number
    addedAt?: DateTimeFilter<"LibraryEntry"> | Date | string
    isPublic?: BoolFilter<"LibraryEntry"> | boolean
    tags?: JsonNullableFilter<"LibraryEntry">
    updatedAt?: DateTimeFilter<"LibraryEntry"> | Date | string
    userId?: StringFilter<"LibraryEntry"> | string
    priority?: IntFilter<"LibraryEntry"> | number
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_gameId">

  export type LibraryEntryOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    category?: SortOrder
    playtime?: SortOrder
    rating?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    lastPlayed?: SortOrderInput | SortOrder
    progress?: SortOrder
    addedAt?: SortOrder
    isPublic?: SortOrder
    tags?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    _count?: LibraryEntryCountOrderByAggregateInput
    _avg?: LibraryEntryAvgOrderByAggregateInput
    _max?: LibraryEntryMaxOrderByAggregateInput
    _min?: LibraryEntryMinOrderByAggregateInput
    _sum?: LibraryEntrySumOrderByAggregateInput
  }

  export type LibraryEntryScalarWhereWithAggregatesInput = {
    AND?: LibraryEntryScalarWhereWithAggregatesInput | LibraryEntryScalarWhereWithAggregatesInput[]
    OR?: LibraryEntryScalarWhereWithAggregatesInput[]
    NOT?: LibraryEntryScalarWhereWithAggregatesInput | LibraryEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LibraryEntry"> | string
    gameId?: StringWithAggregatesFilter<"LibraryEntry"> | string
    category?: StringWithAggregatesFilter<"LibraryEntry"> | string
    playtime?: IntWithAggregatesFilter<"LibraryEntry"> | number
    rating?: FloatNullableWithAggregatesFilter<"LibraryEntry"> | number | null
    notes?: StringNullableWithAggregatesFilter<"LibraryEntry"> | string | null
    lastPlayed?: DateTimeNullableWithAggregatesFilter<"LibraryEntry"> | Date | string | null
    progress?: IntWithAggregatesFilter<"LibraryEntry"> | number
    addedAt?: DateTimeWithAggregatesFilter<"LibraryEntry"> | Date | string
    isPublic?: BoolWithAggregatesFilter<"LibraryEntry"> | boolean
    tags?: JsonNullableWithAggregatesFilter<"LibraryEntry">
    updatedAt?: DateTimeWithAggregatesFilter<"LibraryEntry"> | Date | string
    userId?: StringWithAggregatesFilter<"LibraryEntry"> | string
    priority?: IntWithAggregatesFilter<"LibraryEntry"> | number
  }

  export type UserPreferencesWhereInput = {
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    id?: StringFilter<"UserPreferences"> | string
    userId?: StringFilter<"UserPreferences"> | string
    preferredPlatform?: StringNullableFilter<"UserPreferences"> | string | null
    preferredStatus?: StringFilter<"UserPreferences"> | string
    includeDLCs?: BoolFilter<"UserPreferences"> | boolean
    selectedDLCs?: JsonNullableFilter<"UserPreferences">
    selectedCampaigns?: JsonNullableFilter<"UserPreferences">
    preferredVersion?: StringNullableFilter<"UserPreferences"> | string | null
    gameSpecificPrefs?: JsonNullableFilter<"UserPreferences">
    autoLoadHLTB?: BoolFilter<"UserPreferences"> | boolean
    autoLoadMetacritic?: BoolFilter<"UserPreferences"> | boolean
    autoGenerateCampaigns?: BoolFilter<"UserPreferences"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    preferredPlatform?: SortOrderInput | SortOrder
    preferredStatus?: SortOrder
    includeDLCs?: SortOrder
    selectedDLCs?: SortOrderInput | SortOrder
    selectedCampaigns?: SortOrderInput | SortOrder
    preferredVersion?: SortOrderInput | SortOrder
    gameSpecificPrefs?: SortOrderInput | SortOrder
    autoLoadHLTB?: SortOrder
    autoLoadMetacritic?: SortOrder
    autoGenerateCampaigns?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    preferredPlatform?: StringNullableFilter<"UserPreferences"> | string | null
    preferredStatus?: StringFilter<"UserPreferences"> | string
    includeDLCs?: BoolFilter<"UserPreferences"> | boolean
    selectedDLCs?: JsonNullableFilter<"UserPreferences">
    selectedCampaigns?: JsonNullableFilter<"UserPreferences">
    preferredVersion?: StringNullableFilter<"UserPreferences"> | string | null
    gameSpecificPrefs?: JsonNullableFilter<"UserPreferences">
    autoLoadHLTB?: BoolFilter<"UserPreferences"> | boolean
    autoLoadMetacritic?: BoolFilter<"UserPreferences"> | boolean
    autoGenerateCampaigns?: BoolFilter<"UserPreferences"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    preferredPlatform?: SortOrderInput | SortOrder
    preferredStatus?: SortOrder
    includeDLCs?: SortOrder
    selectedDLCs?: SortOrderInput | SortOrder
    selectedCampaigns?: SortOrderInput | SortOrder
    preferredVersion?: SortOrderInput | SortOrder
    gameSpecificPrefs?: SortOrderInput | SortOrder
    autoLoadHLTB?: SortOrder
    autoLoadMetacritic?: SortOrder
    autoGenerateCampaigns?: SortOrder
    _count?: UserPreferencesCountOrderByAggregateInput
    _max?: UserPreferencesMaxOrderByAggregateInput
    _min?: UserPreferencesMinOrderByAggregateInput
  }

  export type UserPreferencesScalarWhereWithAggregatesInput = {
    AND?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    OR?: UserPreferencesScalarWhereWithAggregatesInput[]
    NOT?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPreferences"> | string
    userId?: StringWithAggregatesFilter<"UserPreferences"> | string
    preferredPlatform?: StringNullableWithAggregatesFilter<"UserPreferences"> | string | null
    preferredStatus?: StringWithAggregatesFilter<"UserPreferences"> | string
    includeDLCs?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    selectedDLCs?: JsonNullableWithAggregatesFilter<"UserPreferences">
    selectedCampaigns?: JsonNullableWithAggregatesFilter<"UserPreferences">
    preferredVersion?: StringNullableWithAggregatesFilter<"UserPreferences"> | string | null
    gameSpecificPrefs?: JsonNullableWithAggregatesFilter<"UserPreferences">
    autoLoadHLTB?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    autoLoadMetacritic?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    autoGenerateCampaigns?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
  }

  export type GameSessionWhereInput = {
    AND?: GameSessionWhereInput | GameSessionWhereInput[]
    OR?: GameSessionWhereInput[]
    NOT?: GameSessionWhereInput | GameSessionWhereInput[]
    id?: StringFilter<"GameSession"> | string
    userId?: StringFilter<"GameSession"> | string
    gameId?: StringFilter<"GameSession"> | string
    gameName?: StringFilter<"GameSession"> | string
    startTime?: DateTimeFilter<"GameSession"> | Date | string
    endTime?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    playtime?: IntFilter<"GameSession"> | number
    isActive?: BoolFilter<"GameSession"> | boolean
    campaigns?: JsonNullableFilter<"GameSession">
    platform?: StringNullableFilter<"GameSession"> | string | null
    status?: StringNullableFilter<"GameSession"> | string | null
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GameSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    gameName?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    playtime?: SortOrder
    isActive?: SortOrder
    campaigns?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    game?: GameOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type GameSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameSessionWhereInput | GameSessionWhereInput[]
    OR?: GameSessionWhereInput[]
    NOT?: GameSessionWhereInput | GameSessionWhereInput[]
    userId?: StringFilter<"GameSession"> | string
    gameId?: StringFilter<"GameSession"> | string
    gameName?: StringFilter<"GameSession"> | string
    startTime?: DateTimeFilter<"GameSession"> | Date | string
    endTime?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    playtime?: IntFilter<"GameSession"> | number
    isActive?: BoolFilter<"GameSession"> | boolean
    campaigns?: JsonNullableFilter<"GameSession">
    platform?: StringNullableFilter<"GameSession"> | string | null
    status?: StringNullableFilter<"GameSession"> | string | null
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type GameSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    gameName?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    playtime?: SortOrder
    isActive?: SortOrder
    campaigns?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: GameSessionCountOrderByAggregateInput
    _avg?: GameSessionAvgOrderByAggregateInput
    _max?: GameSessionMaxOrderByAggregateInput
    _min?: GameSessionMinOrderByAggregateInput
    _sum?: GameSessionSumOrderByAggregateInput
  }

  export type GameSessionScalarWhereWithAggregatesInput = {
    AND?: GameSessionScalarWhereWithAggregatesInput | GameSessionScalarWhereWithAggregatesInput[]
    OR?: GameSessionScalarWhereWithAggregatesInput[]
    NOT?: GameSessionScalarWhereWithAggregatesInput | GameSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameSession"> | string
    userId?: StringWithAggregatesFilter<"GameSession"> | string
    gameId?: StringWithAggregatesFilter<"GameSession"> | string
    gameName?: StringWithAggregatesFilter<"GameSession"> | string
    startTime?: DateTimeWithAggregatesFilter<"GameSession"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"GameSession"> | Date | string | null
    playtime?: IntWithAggregatesFilter<"GameSession"> | number
    isActive?: BoolWithAggregatesFilter<"GameSession"> | boolean
    campaigns?: JsonNullableWithAggregatesFilter<"GameSession">
    platform?: StringNullableWithAggregatesFilter<"GameSession"> | string | null
    status?: StringNullableWithAggregatesFilter<"GameSession"> | string | null
  }

  export type UserStatsWhereInput = {
    AND?: UserStatsWhereInput | UserStatsWhereInput[]
    OR?: UserStatsWhereInput[]
    NOT?: UserStatsWhereInput | UserStatsWhereInput[]
    id?: StringFilter<"UserStats"> | string
    userId?: StringFilter<"UserStats"> | string
    totalPlayTime?: IntFilter<"UserStats"> | number
    totalSessions?: IntFilter<"UserStats"> | number
    gamesPlayed?: IntFilter<"UserStats"> | number
    gamesCompleted?: IntFilter<"UserStats"> | number
    lastPlayedGame?: StringNullableFilter<"UserStats"> | string | null
    lastPlayedAt?: DateTimeNullableFilter<"UserStats"> | Date | string | null
    weeklyStats?: JsonNullableFilter<"UserStats">
    monthlyStats?: JsonNullableFilter<"UserStats">
    achievements?: JsonNullableFilter<"UserStats">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserStatsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPlayTime?: SortOrder
    totalSessions?: SortOrder
    gamesPlayed?: SortOrder
    gamesCompleted?: SortOrder
    lastPlayedGame?: SortOrderInput | SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    weeklyStats?: SortOrderInput | SortOrder
    monthlyStats?: SortOrderInput | SortOrder
    achievements?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserStatsWhereInput | UserStatsWhereInput[]
    OR?: UserStatsWhereInput[]
    NOT?: UserStatsWhereInput | UserStatsWhereInput[]
    totalPlayTime?: IntFilter<"UserStats"> | number
    totalSessions?: IntFilter<"UserStats"> | number
    gamesPlayed?: IntFilter<"UserStats"> | number
    gamesCompleted?: IntFilter<"UserStats"> | number
    lastPlayedGame?: StringNullableFilter<"UserStats"> | string | null
    lastPlayedAt?: DateTimeNullableFilter<"UserStats"> | Date | string | null
    weeklyStats?: JsonNullableFilter<"UserStats">
    monthlyStats?: JsonNullableFilter<"UserStats">
    achievements?: JsonNullableFilter<"UserStats">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserStatsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPlayTime?: SortOrder
    totalSessions?: SortOrder
    gamesPlayed?: SortOrder
    gamesCompleted?: SortOrder
    lastPlayedGame?: SortOrderInput | SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    weeklyStats?: SortOrderInput | SortOrder
    monthlyStats?: SortOrderInput | SortOrder
    achievements?: SortOrderInput | SortOrder
    _count?: UserStatsCountOrderByAggregateInput
    _avg?: UserStatsAvgOrderByAggregateInput
    _max?: UserStatsMaxOrderByAggregateInput
    _min?: UserStatsMinOrderByAggregateInput
    _sum?: UserStatsSumOrderByAggregateInput
  }

  export type UserStatsScalarWhereWithAggregatesInput = {
    AND?: UserStatsScalarWhereWithAggregatesInput | UserStatsScalarWhereWithAggregatesInput[]
    OR?: UserStatsScalarWhereWithAggregatesInput[]
    NOT?: UserStatsScalarWhereWithAggregatesInput | UserStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserStats"> | string
    userId?: StringWithAggregatesFilter<"UserStats"> | string
    totalPlayTime?: IntWithAggregatesFilter<"UserStats"> | number
    totalSessions?: IntWithAggregatesFilter<"UserStats"> | number
    gamesPlayed?: IntWithAggregatesFilter<"UserStats"> | number
    gamesCompleted?: IntWithAggregatesFilter<"UserStats"> | number
    lastPlayedGame?: StringNullableWithAggregatesFilter<"UserStats"> | string | null
    lastPlayedAt?: DateTimeNullableWithAggregatesFilter<"UserStats"> | Date | string | null
    weeklyStats?: JsonNullableWithAggregatesFilter<"UserStats">
    monthlyStats?: JsonNullableWithAggregatesFilter<"UserStats">
    achievements?: JsonNullableWithAggregatesFilter<"UserStats">
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    gameId?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    averageDuration?: StringNullableFilter<"Campaign"> | string | null
    customProperties?: JsonNullableFilter<"Campaign">
    parentId?: StringNullableFilter<"Campaign"> | string | null
    isAutoGenerated?: BoolFilter<"Campaign"> | boolean
    isMainCampaign?: BoolFilter<"Campaign"> | boolean
    difficulty?: StringNullableFilter<"Campaign"> | string | null
    features?: JsonNullableFilter<"Campaign">
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    parent?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
    children?: CampaignListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    averageDuration?: SortOrderInput | SortOrder
    customProperties?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    isAutoGenerated?: SortOrder
    isMainCampaign?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    game?: GameOrderByWithRelationInput
    parent?: CampaignOrderByWithRelationInput
    children?: CampaignOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    gameId?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    averageDuration?: StringNullableFilter<"Campaign"> | string | null
    customProperties?: JsonNullableFilter<"Campaign">
    parentId?: StringNullableFilter<"Campaign"> | string | null
    isAutoGenerated?: BoolFilter<"Campaign"> | boolean
    isMainCampaign?: BoolFilter<"Campaign"> | boolean
    difficulty?: StringNullableFilter<"Campaign"> | string | null
    features?: JsonNullableFilter<"Campaign">
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    parent?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
    children?: CampaignListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    averageDuration?: SortOrderInput | SortOrder
    customProperties?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    isAutoGenerated?: SortOrder
    isMainCampaign?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    gameId?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    description?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    averageDuration?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    customProperties?: JsonNullableWithAggregatesFilter<"Campaign">
    parentId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    isAutoGenerated?: BoolWithAggregatesFilter<"Campaign"> | boolean
    isMainCampaign?: BoolWithAggregatesFilter<"Campaign"> | boolean
    difficulty?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    features?: JsonNullableWithAggregatesFilter<"Campaign">
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type PageVisitWhereInput = {
    AND?: PageVisitWhereInput | PageVisitWhereInput[]
    OR?: PageVisitWhereInput[]
    NOT?: PageVisitWhereInput | PageVisitWhereInput[]
    id?: StringFilter<"PageVisit"> | string
    userId?: StringFilter<"PageVisit"> | string
    page?: StringFilter<"PageVisit"> | string
    visitedAt?: DateTimeFilter<"PageVisit"> | Date | string
    metadata?: JsonNullableFilter<"PageVisit">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PageVisitOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    visitedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PageVisitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PageVisitWhereInput | PageVisitWhereInput[]
    OR?: PageVisitWhereInput[]
    NOT?: PageVisitWhereInput | PageVisitWhereInput[]
    userId?: StringFilter<"PageVisit"> | string
    page?: StringFilter<"PageVisit"> | string
    visitedAt?: DateTimeFilter<"PageVisit"> | Date | string
    metadata?: JsonNullableFilter<"PageVisit">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PageVisitOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    visitedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: PageVisitCountOrderByAggregateInput
    _max?: PageVisitMaxOrderByAggregateInput
    _min?: PageVisitMinOrderByAggregateInput
  }

  export type PageVisitScalarWhereWithAggregatesInput = {
    AND?: PageVisitScalarWhereWithAggregatesInput | PageVisitScalarWhereWithAggregatesInput[]
    OR?: PageVisitScalarWhereWithAggregatesInput[]
    NOT?: PageVisitScalarWhereWithAggregatesInput | PageVisitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PageVisit"> | string
    userId?: StringWithAggregatesFilter<"PageVisit"> | string
    page?: StringWithAggregatesFilter<"PageVisit"> | string
    visitedAt?: DateTimeWithAggregatesFilter<"PageVisit"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"PageVisit">
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    isGlobal?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    isGlobal?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    isGlobal?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    isGlobal?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    isGlobal?: BoolWithAggregatesFilter<"Notification"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type SystemUpdateWhereInput = {
    AND?: SystemUpdateWhereInput | SystemUpdateWhereInput[]
    OR?: SystemUpdateWhereInput[]
    NOT?: SystemUpdateWhereInput | SystemUpdateWhereInput[]
    id?: StringFilter<"SystemUpdate"> | string
    title?: StringFilter<"SystemUpdate"> | string
    description?: StringFilter<"SystemUpdate"> | string
    version?: StringNullableFilter<"SystemUpdate"> | string | null
    type?: StringFilter<"SystemUpdate"> | string
    status?: StringFilter<"SystemUpdate"> | string
    progress?: IntFilter<"SystemUpdate"> | number
    priority?: StringFilter<"SystemUpdate"> | string
    category?: StringNullableFilter<"SystemUpdate"> | string | null
    metadata?: JsonNullableFilter<"SystemUpdate">
    createdAt?: DateTimeFilter<"SystemUpdate"> | Date | string
    updatedAt?: DateTimeFilter<"SystemUpdate"> | Date | string
    completedAt?: DateTimeNullableFilter<"SystemUpdate"> | Date | string | null
    substeps?: SystemUpdateStepListRelationFilter
  }

  export type SystemUpdateOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    version?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    priority?: SortOrder
    category?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    substeps?: SystemUpdateStepOrderByRelationAggregateInput
  }

  export type SystemUpdateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemUpdateWhereInput | SystemUpdateWhereInput[]
    OR?: SystemUpdateWhereInput[]
    NOT?: SystemUpdateWhereInput | SystemUpdateWhereInput[]
    title?: StringFilter<"SystemUpdate"> | string
    description?: StringFilter<"SystemUpdate"> | string
    version?: StringNullableFilter<"SystemUpdate"> | string | null
    type?: StringFilter<"SystemUpdate"> | string
    status?: StringFilter<"SystemUpdate"> | string
    progress?: IntFilter<"SystemUpdate"> | number
    priority?: StringFilter<"SystemUpdate"> | string
    category?: StringNullableFilter<"SystemUpdate"> | string | null
    metadata?: JsonNullableFilter<"SystemUpdate">
    createdAt?: DateTimeFilter<"SystemUpdate"> | Date | string
    updatedAt?: DateTimeFilter<"SystemUpdate"> | Date | string
    completedAt?: DateTimeNullableFilter<"SystemUpdate"> | Date | string | null
    substeps?: SystemUpdateStepListRelationFilter
  }, "id">

  export type SystemUpdateOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    version?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    priority?: SortOrder
    category?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: SystemUpdateCountOrderByAggregateInput
    _avg?: SystemUpdateAvgOrderByAggregateInput
    _max?: SystemUpdateMaxOrderByAggregateInput
    _min?: SystemUpdateMinOrderByAggregateInput
    _sum?: SystemUpdateSumOrderByAggregateInput
  }

  export type SystemUpdateScalarWhereWithAggregatesInput = {
    AND?: SystemUpdateScalarWhereWithAggregatesInput | SystemUpdateScalarWhereWithAggregatesInput[]
    OR?: SystemUpdateScalarWhereWithAggregatesInput[]
    NOT?: SystemUpdateScalarWhereWithAggregatesInput | SystemUpdateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemUpdate"> | string
    title?: StringWithAggregatesFilter<"SystemUpdate"> | string
    description?: StringWithAggregatesFilter<"SystemUpdate"> | string
    version?: StringNullableWithAggregatesFilter<"SystemUpdate"> | string | null
    type?: StringWithAggregatesFilter<"SystemUpdate"> | string
    status?: StringWithAggregatesFilter<"SystemUpdate"> | string
    progress?: IntWithAggregatesFilter<"SystemUpdate"> | number
    priority?: StringWithAggregatesFilter<"SystemUpdate"> | string
    category?: StringNullableWithAggregatesFilter<"SystemUpdate"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"SystemUpdate">
    createdAt?: DateTimeWithAggregatesFilter<"SystemUpdate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemUpdate"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"SystemUpdate"> | Date | string | null
  }

  export type SystemUpdateStepWhereInput = {
    AND?: SystemUpdateStepWhereInput | SystemUpdateStepWhereInput[]
    OR?: SystemUpdateStepWhereInput[]
    NOT?: SystemUpdateStepWhereInput | SystemUpdateStepWhereInput[]
    id?: StringFilter<"SystemUpdateStep"> | string
    updateId?: StringFilter<"SystemUpdateStep"> | string
    title?: StringFilter<"SystemUpdateStep"> | string
    description?: StringNullableFilter<"SystemUpdateStep"> | string | null
    progress?: IntFilter<"SystemUpdateStep"> | number
    status?: StringFilter<"SystemUpdateStep"> | string
    order?: IntFilter<"SystemUpdateStep"> | number
    createdAt?: DateTimeFilter<"SystemUpdateStep"> | Date | string
    updatedAt?: DateTimeFilter<"SystemUpdateStep"> | Date | string
    completedAt?: DateTimeNullableFilter<"SystemUpdateStep"> | Date | string | null
    update?: XOR<SystemUpdateScalarRelationFilter, SystemUpdateWhereInput>
  }

  export type SystemUpdateStepOrderByWithRelationInput = {
    id?: SortOrder
    updateId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    progress?: SortOrder
    status?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    update?: SystemUpdateOrderByWithRelationInput
  }

  export type SystemUpdateStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemUpdateStepWhereInput | SystemUpdateStepWhereInput[]
    OR?: SystemUpdateStepWhereInput[]
    NOT?: SystemUpdateStepWhereInput | SystemUpdateStepWhereInput[]
    updateId?: StringFilter<"SystemUpdateStep"> | string
    title?: StringFilter<"SystemUpdateStep"> | string
    description?: StringNullableFilter<"SystemUpdateStep"> | string | null
    progress?: IntFilter<"SystemUpdateStep"> | number
    status?: StringFilter<"SystemUpdateStep"> | string
    order?: IntFilter<"SystemUpdateStep"> | number
    createdAt?: DateTimeFilter<"SystemUpdateStep"> | Date | string
    updatedAt?: DateTimeFilter<"SystemUpdateStep"> | Date | string
    completedAt?: DateTimeNullableFilter<"SystemUpdateStep"> | Date | string | null
    update?: XOR<SystemUpdateScalarRelationFilter, SystemUpdateWhereInput>
  }, "id">

  export type SystemUpdateStepOrderByWithAggregationInput = {
    id?: SortOrder
    updateId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    progress?: SortOrder
    status?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: SystemUpdateStepCountOrderByAggregateInput
    _avg?: SystemUpdateStepAvgOrderByAggregateInput
    _max?: SystemUpdateStepMaxOrderByAggregateInput
    _min?: SystemUpdateStepMinOrderByAggregateInput
    _sum?: SystemUpdateStepSumOrderByAggregateInput
  }

  export type SystemUpdateStepScalarWhereWithAggregatesInput = {
    AND?: SystemUpdateStepScalarWhereWithAggregatesInput | SystemUpdateStepScalarWhereWithAggregatesInput[]
    OR?: SystemUpdateStepScalarWhereWithAggregatesInput[]
    NOT?: SystemUpdateStepScalarWhereWithAggregatesInput | SystemUpdateStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemUpdateStep"> | string
    updateId?: StringWithAggregatesFilter<"SystemUpdateStep"> | string
    title?: StringWithAggregatesFilter<"SystemUpdateStep"> | string
    description?: StringNullableWithAggregatesFilter<"SystemUpdateStep"> | string | null
    progress?: IntWithAggregatesFilter<"SystemUpdateStep"> | number
    status?: StringWithAggregatesFilter<"SystemUpdateStep"> | string
    order?: IntWithAggregatesFilter<"SystemUpdateStep"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SystemUpdateStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemUpdateStep"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"SystemUpdateStep"> | Date | string | null
  }

  export type PlatformWhereInput = {
    AND?: PlatformWhereInput | PlatformWhereInput[]
    OR?: PlatformWhereInput[]
    NOT?: PlatformWhereInput | PlatformWhereInput[]
    id?: StringFilter<"Platform"> | string
    name?: StringFilter<"Platform"> | string
    logoUrl?: StringNullableFilter<"Platform"> | string | null
    logoKey?: StringNullableFilter<"Platform"> | string | null
    createdAt?: DateTimeFilter<"Platform"> | Date | string
    updatedAt?: DateTimeFilter<"Platform"> | Date | string
  }

  export type PlatformOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    logoKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PlatformWhereInput | PlatformWhereInput[]
    OR?: PlatformWhereInput[]
    NOT?: PlatformWhereInput | PlatformWhereInput[]
    logoUrl?: StringNullableFilter<"Platform"> | string | null
    logoKey?: StringNullableFilter<"Platform"> | string | null
    createdAt?: DateTimeFilter<"Platform"> | Date | string
    updatedAt?: DateTimeFilter<"Platform"> | Date | string
  }, "id" | "name">

  export type PlatformOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    logoKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlatformCountOrderByAggregateInput
    _max?: PlatformMaxOrderByAggregateInput
    _min?: PlatformMinOrderByAggregateInput
  }

  export type PlatformScalarWhereWithAggregatesInput = {
    AND?: PlatformScalarWhereWithAggregatesInput | PlatformScalarWhereWithAggregatesInput[]
    OR?: PlatformScalarWhereWithAggregatesInput[]
    NOT?: PlatformScalarWhereWithAggregatesInput | PlatformScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Platform"> | string
    name?: StringWithAggregatesFilter<"Platform"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"Platform"> | string | null
    logoKey?: StringNullableWithAggregatesFilter<"Platform"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Platform"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Platform"> | Date | string
  }

  export type ChangelogWhereInput = {
    AND?: ChangelogWhereInput | ChangelogWhereInput[]
    OR?: ChangelogWhereInput[]
    NOT?: ChangelogWhereInput | ChangelogWhereInput[]
    id?: StringFilter<"Changelog"> | string
    title?: StringFilter<"Changelog"> | string
    content?: StringFilter<"Changelog"> | string
    version?: StringNullableFilter<"Changelog"> | string | null
    type?: StringFilter<"Changelog"> | string
    isPublished?: BoolFilter<"Changelog"> | boolean
    publishedAt?: DateTimeNullableFilter<"Changelog"> | Date | string | null
    createdAt?: DateTimeFilter<"Changelog"> | Date | string
    updatedAt?: DateTimeFilter<"Changelog"> | Date | string
    authorId?: StringFilter<"Changelog"> | string
    releaseDate?: DateTimeNullableFilter<"Changelog"> | Date | string | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChangelogOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    version?: SortOrderInput | SortOrder
    type?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    releaseDate?: SortOrderInput | SortOrder
    author?: UserOrderByWithRelationInput
  }

  export type ChangelogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChangelogWhereInput | ChangelogWhereInput[]
    OR?: ChangelogWhereInput[]
    NOT?: ChangelogWhereInput | ChangelogWhereInput[]
    title?: StringFilter<"Changelog"> | string
    content?: StringFilter<"Changelog"> | string
    version?: StringNullableFilter<"Changelog"> | string | null
    type?: StringFilter<"Changelog"> | string
    isPublished?: BoolFilter<"Changelog"> | boolean
    publishedAt?: DateTimeNullableFilter<"Changelog"> | Date | string | null
    createdAt?: DateTimeFilter<"Changelog"> | Date | string
    updatedAt?: DateTimeFilter<"Changelog"> | Date | string
    authorId?: StringFilter<"Changelog"> | string
    releaseDate?: DateTimeNullableFilter<"Changelog"> | Date | string | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ChangelogOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    version?: SortOrderInput | SortOrder
    type?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    releaseDate?: SortOrderInput | SortOrder
    _count?: ChangelogCountOrderByAggregateInput
    _max?: ChangelogMaxOrderByAggregateInput
    _min?: ChangelogMinOrderByAggregateInput
  }

  export type ChangelogScalarWhereWithAggregatesInput = {
    AND?: ChangelogScalarWhereWithAggregatesInput | ChangelogScalarWhereWithAggregatesInput[]
    OR?: ChangelogScalarWhereWithAggregatesInput[]
    NOT?: ChangelogScalarWhereWithAggregatesInput | ChangelogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Changelog"> | string
    title?: StringWithAggregatesFilter<"Changelog"> | string
    content?: StringWithAggregatesFilter<"Changelog"> | string
    version?: StringNullableWithAggregatesFilter<"Changelog"> | string | null
    type?: StringWithAggregatesFilter<"Changelog"> | string
    isPublished?: BoolWithAggregatesFilter<"Changelog"> | boolean
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Changelog"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Changelog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Changelog"> | Date | string
    authorId?: StringWithAggregatesFilter<"Changelog"> | string
    releaseDate?: DateTimeNullableWithAggregatesFilter<"Changelog"> | Date | string | null
  }

  export type AdminAuditLogWhereInput = {
    AND?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    OR?: AdminAuditLogWhereInput[]
    NOT?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    id?: StringFilter<"AdminAuditLog"> | string
    action?: StringFilter<"AdminAuditLog"> | string
    targetType?: StringFilter<"AdminAuditLog"> | string
    targetId?: StringNullableFilter<"AdminAuditLog"> | string | null
    targetName?: StringNullableFilter<"AdminAuditLog"> | string | null
    details?: JsonNullableFilter<"AdminAuditLog">
    ipAddress?: StringNullableFilter<"AdminAuditLog"> | string | null
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    success?: BoolFilter<"AdminAuditLog"> | boolean
    errorMessage?: StringNullableFilter<"AdminAuditLog"> | string | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
    adminId?: StringFilter<"AdminAuditLog"> | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrderInput | SortOrder
    targetName?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    admin?: UserOrderByWithRelationInput
  }

  export type AdminAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    OR?: AdminAuditLogWhereInput[]
    NOT?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    action?: StringFilter<"AdminAuditLog"> | string
    targetType?: StringFilter<"AdminAuditLog"> | string
    targetId?: StringNullableFilter<"AdminAuditLog"> | string | null
    targetName?: StringNullableFilter<"AdminAuditLog"> | string | null
    details?: JsonNullableFilter<"AdminAuditLog">
    ipAddress?: StringNullableFilter<"AdminAuditLog"> | string | null
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    success?: BoolFilter<"AdminAuditLog"> | boolean
    errorMessage?: StringNullableFilter<"AdminAuditLog"> | string | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
    adminId?: StringFilter<"AdminAuditLog"> | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AdminAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrderInput | SortOrder
    targetName?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    _count?: AdminAuditLogCountOrderByAggregateInput
    _max?: AdminAuditLogMaxOrderByAggregateInput
    _min?: AdminAuditLogMinOrderByAggregateInput
  }

  export type AdminAuditLogScalarWhereWithAggregatesInput = {
    AND?: AdminAuditLogScalarWhereWithAggregatesInput | AdminAuditLogScalarWhereWithAggregatesInput[]
    OR?: AdminAuditLogScalarWhereWithAggregatesInput[]
    NOT?: AdminAuditLogScalarWhereWithAggregatesInput | AdminAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    action?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    targetType?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    targetId?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    targetName?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AdminAuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    success?: BoolWithAggregatesFilter<"AdminAuditLog"> | boolean
    errorMessage?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminAuditLog"> | Date | string
    adminId?: StringWithAggregatesFilter<"AdminAuditLog"> | string
  }

  export type session_historyWhereInput = {
    AND?: session_historyWhereInput | session_historyWhereInput[]
    OR?: session_historyWhereInput[]
    NOT?: session_historyWhereInput | session_historyWhereInput[]
    id?: StringFilter<"session_history"> | string
    userId?: StringFilter<"session_history"> | string
    gameId?: StringFilter<"session_history"> | string
    gameName?: StringFilter<"session_history"> | string
    startTime?: DateTimeFilter<"session_history"> | Date | string
    endTime?: DateTimeFilter<"session_history"> | Date | string
    playtime?: IntFilter<"session_history"> | number
    campaigns?: JsonNullableFilter<"session_history">
    platform?: StringNullableFilter<"session_history"> | string | null
    status?: StringNullableFilter<"session_history"> | string | null
    createdAt?: DateTimeFilter<"session_history"> | Date | string
    games?: XOR<GameScalarRelationFilter, GameWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type session_historyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    gameName?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    playtime?: SortOrder
    campaigns?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    games?: GameOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type session_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: session_historyWhereInput | session_historyWhereInput[]
    OR?: session_historyWhereInput[]
    NOT?: session_historyWhereInput | session_historyWhereInput[]
    userId?: StringFilter<"session_history"> | string
    gameId?: StringFilter<"session_history"> | string
    gameName?: StringFilter<"session_history"> | string
    startTime?: DateTimeFilter<"session_history"> | Date | string
    endTime?: DateTimeFilter<"session_history"> | Date | string
    playtime?: IntFilter<"session_history"> | number
    campaigns?: JsonNullableFilter<"session_history">
    platform?: StringNullableFilter<"session_history"> | string | null
    status?: StringNullableFilter<"session_history"> | string | null
    createdAt?: DateTimeFilter<"session_history"> | Date | string
    games?: XOR<GameScalarRelationFilter, GameWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type session_historyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    gameName?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    playtime?: SortOrder
    campaigns?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: session_historyCountOrderByAggregateInput
    _avg?: session_historyAvgOrderByAggregateInput
    _max?: session_historyMaxOrderByAggregateInput
    _min?: session_historyMinOrderByAggregateInput
    _sum?: session_historySumOrderByAggregateInput
  }

  export type session_historyScalarWhereWithAggregatesInput = {
    AND?: session_historyScalarWhereWithAggregatesInput | session_historyScalarWhereWithAggregatesInput[]
    OR?: session_historyScalarWhereWithAggregatesInput[]
    NOT?: session_historyScalarWhereWithAggregatesInput | session_historyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"session_history"> | string
    userId?: StringWithAggregatesFilter<"session_history"> | string
    gameId?: StringWithAggregatesFilter<"session_history"> | string
    gameName?: StringWithAggregatesFilter<"session_history"> | string
    startTime?: DateTimeWithAggregatesFilter<"session_history"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"session_history"> | Date | string
    playtime?: IntWithAggregatesFilter<"session_history"> | number
    campaigns?: JsonNullableWithAggregatesFilter<"session_history">
    platform?: StringNullableWithAggregatesFilter<"session_history"> | string | null
    status?: StringNullableWithAggregatesFilter<"session_history"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"session_history"> | Date | string
  }

  export type user_librariesWhereInput = {
    AND?: user_librariesWhereInput | user_librariesWhereInput[]
    OR?: user_librariesWhereInput[]
    NOT?: user_librariesWhereInput | user_librariesWhereInput[]
    id?: StringFilter<"user_libraries"> | string
    userId?: StringFilter<"user_libraries"> | string
    version?: StringFilter<"user_libraries"> | string
    totalGames?: IntFilter<"user_libraries"> | number
    totalPlaytime?: IntFilter<"user_libraries"> | number
    lastUpdated?: DateTimeFilter<"user_libraries"> | Date | string
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type user_librariesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    version?: SortOrder
    totalGames?: SortOrder
    totalPlaytime?: SortOrder
    lastUpdated?: SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type user_librariesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: user_librariesWhereInput | user_librariesWhereInput[]
    OR?: user_librariesWhereInput[]
    NOT?: user_librariesWhereInput | user_librariesWhereInput[]
    version?: StringFilter<"user_libraries"> | string
    totalGames?: IntFilter<"user_libraries"> | number
    totalPlaytime?: IntFilter<"user_libraries"> | number
    lastUpdated?: DateTimeFilter<"user_libraries"> | Date | string
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type user_librariesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    version?: SortOrder
    totalGames?: SortOrder
    totalPlaytime?: SortOrder
    lastUpdated?: SortOrder
    _count?: user_librariesCountOrderByAggregateInput
    _avg?: user_librariesAvgOrderByAggregateInput
    _max?: user_librariesMaxOrderByAggregateInput
    _min?: user_librariesMinOrderByAggregateInput
    _sum?: user_librariesSumOrderByAggregateInput
  }

  export type user_librariesScalarWhereWithAggregatesInput = {
    AND?: user_librariesScalarWhereWithAggregatesInput | user_librariesScalarWhereWithAggregatesInput[]
    OR?: user_librariesScalarWhereWithAggregatesInput[]
    NOT?: user_librariesScalarWhereWithAggregatesInput | user_librariesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_libraries"> | string
    userId?: StringWithAggregatesFilter<"user_libraries"> | string
    version?: StringWithAggregatesFilter<"user_libraries"> | string
    totalGames?: IntWithAggregatesFilter<"user_libraries"> | number
    totalPlaytime?: IntWithAggregatesFilter<"user_libraries"> | number
    lastUpdated?: DateTimeWithAggregatesFilter<"user_libraries"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    changelogs?: ChangelogCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitCreateNestedManyWithoutUserInput
    session_history?: session_historyCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    changelogs?: ChangelogUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitUncheckedCreateNestedManyWithoutUserInput
    session_history?: session_historyUncheckedCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesUncheckedCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUpdateManyWithoutUserNestedInput
    session_history?: session_historyUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUncheckedUpdateManyWithoutUserNestedInput
    session_history?: session_historyUncheckedUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUncheckedUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ApiKeyCreateInput = {
    id?: string
    serviceName: string
    keyName: string
    keyValue: string
    isActive?: boolean
    isGlobal?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsed?: Date | string | null
    user?: UserCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    userId?: string | null
    serviceName: string
    keyName: string
    keyValue: string
    isActive?: boolean
    isGlobal?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsed?: Date | string | null
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    keyValue?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceName?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    keyValue?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    userId?: string | null
    serviceName: string
    keyName: string
    keyValue: string
    isActive?: boolean
    isGlobal?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsed?: Date | string | null
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    keyValue?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceName?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    keyValue?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameCreateInput = {
    id: string
    name: string
    cover?: string | null
    firstReleaseDate?: Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: string | null
    rating?: number | null
    developer?: string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: Date | string
    lastAccessed?: Date | string
    accessCount?: number
    coverKey?: string | null
    campaigns?: CampaignCreateNestedManyWithoutGameInput
    sessions?: GameSessionCreateNestedManyWithoutGameInput
    libraryEntries?: LibraryEntryCreateNestedManyWithoutGameInput
    session_history?: session_historyCreateNestedManyWithoutGamesInput
  }

  export type GameUncheckedCreateInput = {
    id: string
    name: string
    cover?: string | null
    firstReleaseDate?: Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: string | null
    rating?: number | null
    developer?: string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: Date | string
    lastAccessed?: Date | string
    accessCount?: number
    coverKey?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutGameInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    libraryEntries?: LibraryEntryUncheckedCreateNestedManyWithoutGameInput
    session_history?: session_historyUncheckedCreateNestedManyWithoutGamesInput
  }

  export type GameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    firstReleaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCount?: IntFieldUpdateOperationsInput | number
    coverKey?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUpdateManyWithoutGameNestedInput
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
    libraryEntries?: LibraryEntryUpdateManyWithoutGameNestedInput
    session_history?: session_historyUpdateManyWithoutGamesNestedInput
  }

  export type GameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    firstReleaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCount?: IntFieldUpdateOperationsInput | number
    coverKey?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutGameNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    libraryEntries?: LibraryEntryUncheckedUpdateManyWithoutGameNestedInput
    session_history?: session_historyUncheckedUpdateManyWithoutGamesNestedInput
  }

  export type GameCreateManyInput = {
    id: string
    name: string
    cover?: string | null
    firstReleaseDate?: Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: string | null
    rating?: number | null
    developer?: string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: Date | string
    lastAccessed?: Date | string
    accessCount?: number
    coverKey?: string | null
  }

  export type GameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    firstReleaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCount?: IntFieldUpdateOperationsInput | number
    coverKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    firstReleaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCount?: IntFieldUpdateOperationsInput | number
    coverKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LibraryEntryCreateInput = {
    id?: string
    category?: string
    playtime?: number
    rating?: number | null
    notes?: string | null
    lastPlayed?: Date | string | null
    progress?: number
    addedAt?: Date | string
    isPublic?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    priority?: number
    game: GameCreateNestedOneWithoutLibraryEntriesInput
    user: UserCreateNestedOneWithoutLibraryEntriesInput
  }

  export type LibraryEntryUncheckedCreateInput = {
    id?: string
    gameId: string
    category?: string
    playtime?: number
    rating?: number | null
    notes?: string | null
    lastPlayed?: Date | string | null
    progress?: number
    addedAt?: Date | string
    isPublic?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    userId: string
    priority?: number
  }

  export type LibraryEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    playtime?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: IntFieldUpdateOperationsInput | number
    game?: GameUpdateOneRequiredWithoutLibraryEntriesNestedInput
    user?: UserUpdateOneRequiredWithoutLibraryEntriesNestedInput
  }

  export type LibraryEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    playtime?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryEntryCreateManyInput = {
    id?: string
    gameId: string
    category?: string
    playtime?: number
    rating?: number | null
    notes?: string | null
    lastPlayed?: Date | string | null
    progress?: number
    addedAt?: Date | string
    isPublic?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    userId: string
    priority?: number
  }

  export type LibraryEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    playtime?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    playtime?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type UserPreferencesCreateInput = {
    id?: string
    preferredPlatform?: string | null
    preferredStatus?: string
    includeDLCs?: boolean
    selectedDLCs?: NullableJsonNullValueInput | InputJsonValue
    selectedCampaigns?: NullableJsonNullValueInput | InputJsonValue
    preferredVersion?: string | null
    gameSpecificPrefs?: NullableJsonNullValueInput | InputJsonValue
    autoLoadHLTB?: boolean
    autoLoadMetacritic?: boolean
    autoGenerateCampaigns?: boolean
    user: UserCreateNestedOneWithoutPreferencesInput
  }

  export type UserPreferencesUncheckedCreateInput = {
    id?: string
    userId: string
    preferredPlatform?: string | null
    preferredStatus?: string
    includeDLCs?: boolean
    selectedDLCs?: NullableJsonNullValueInput | InputJsonValue
    selectedCampaigns?: NullableJsonNullValueInput | InputJsonValue
    preferredVersion?: string | null
    gameSpecificPrefs?: NullableJsonNullValueInput | InputJsonValue
    autoLoadHLTB?: boolean
    autoLoadMetacritic?: boolean
    autoGenerateCampaigns?: boolean
  }

  export type UserPreferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferredPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStatus?: StringFieldUpdateOperationsInput | string
    includeDLCs?: BoolFieldUpdateOperationsInput | boolean
    selectedDLCs?: NullableJsonNullValueInput | InputJsonValue
    selectedCampaigns?: NullableJsonNullValueInput | InputJsonValue
    preferredVersion?: NullableStringFieldUpdateOperationsInput | string | null
    gameSpecificPrefs?: NullableJsonNullValueInput | InputJsonValue
    autoLoadHLTB?: BoolFieldUpdateOperationsInput | boolean
    autoLoadMetacritic?: BoolFieldUpdateOperationsInput | boolean
    autoGenerateCampaigns?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutPreferencesNestedInput
  }

  export type UserPreferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStatus?: StringFieldUpdateOperationsInput | string
    includeDLCs?: BoolFieldUpdateOperationsInput | boolean
    selectedDLCs?: NullableJsonNullValueInput | InputJsonValue
    selectedCampaigns?: NullableJsonNullValueInput | InputJsonValue
    preferredVersion?: NullableStringFieldUpdateOperationsInput | string | null
    gameSpecificPrefs?: NullableJsonNullValueInput | InputJsonValue
    autoLoadHLTB?: BoolFieldUpdateOperationsInput | boolean
    autoLoadMetacritic?: BoolFieldUpdateOperationsInput | boolean
    autoGenerateCampaigns?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserPreferencesCreateManyInput = {
    id?: string
    userId: string
    preferredPlatform?: string | null
    preferredStatus?: string
    includeDLCs?: boolean
    selectedDLCs?: NullableJsonNullValueInput | InputJsonValue
    selectedCampaigns?: NullableJsonNullValueInput | InputJsonValue
    preferredVersion?: string | null
    gameSpecificPrefs?: NullableJsonNullValueInput | InputJsonValue
    autoLoadHLTB?: boolean
    autoLoadMetacritic?: boolean
    autoGenerateCampaigns?: boolean
  }

  export type UserPreferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferredPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStatus?: StringFieldUpdateOperationsInput | string
    includeDLCs?: BoolFieldUpdateOperationsInput | boolean
    selectedDLCs?: NullableJsonNullValueInput | InputJsonValue
    selectedCampaigns?: NullableJsonNullValueInput | InputJsonValue
    preferredVersion?: NullableStringFieldUpdateOperationsInput | string | null
    gameSpecificPrefs?: NullableJsonNullValueInput | InputJsonValue
    autoLoadHLTB?: BoolFieldUpdateOperationsInput | boolean
    autoLoadMetacritic?: BoolFieldUpdateOperationsInput | boolean
    autoGenerateCampaigns?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserPreferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStatus?: StringFieldUpdateOperationsInput | string
    includeDLCs?: BoolFieldUpdateOperationsInput | boolean
    selectedDLCs?: NullableJsonNullValueInput | InputJsonValue
    selectedCampaigns?: NullableJsonNullValueInput | InputJsonValue
    preferredVersion?: NullableStringFieldUpdateOperationsInput | string | null
    gameSpecificPrefs?: NullableJsonNullValueInput | InputJsonValue
    autoLoadHLTB?: BoolFieldUpdateOperationsInput | boolean
    autoLoadMetacritic?: BoolFieldUpdateOperationsInput | boolean
    autoGenerateCampaigns?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GameSessionCreateInput = {
    id?: string
    gameName: string
    startTime?: Date | string
    endTime?: Date | string | null
    playtime?: number
    isActive?: boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
    game: GameCreateNestedOneWithoutSessionsInput
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type GameSessionUncheckedCreateInput = {
    id?: string
    userId: string
    gameId: string
    gameName: string
    startTime?: Date | string
    endTime?: Date | string | null
    playtime?: number
    isActive?: boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
  }

  export type GameSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playtime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    game?: GameUpdateOneRequiredWithoutSessionsNestedInput
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type GameSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playtime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GameSessionCreateManyInput = {
    id?: string
    userId: string
    gameId: string
    gameName: string
    startTime?: Date | string
    endTime?: Date | string | null
    playtime?: number
    isActive?: boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
  }

  export type GameSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playtime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GameSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playtime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserStatsCreateInput = {
    id?: string
    totalPlayTime?: number
    totalSessions?: number
    gamesPlayed?: number
    gamesCompleted?: number
    lastPlayedGame?: string | null
    lastPlayedAt?: Date | string | null
    weeklyStats?: NullableJsonNullValueInput | InputJsonValue
    monthlyStats?: NullableJsonNullValueInput | InputJsonValue
    achievements?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutUserStatsInput
  }

  export type UserStatsUncheckedCreateInput = {
    id?: string
    userId: string
    totalPlayTime?: number
    totalSessions?: number
    gamesPlayed?: number
    gamesCompleted?: number
    lastPlayedGame?: string | null
    lastPlayedAt?: Date | string | null
    weeklyStats?: NullableJsonNullValueInput | InputJsonValue
    monthlyStats?: NullableJsonNullValueInput | InputJsonValue
    achievements?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPlayTime?: IntFieldUpdateOperationsInput | number
    totalSessions?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesCompleted?: IntFieldUpdateOperationsInput | number
    lastPlayedGame?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weeklyStats?: NullableJsonNullValueInput | InputJsonValue
    monthlyStats?: NullableJsonNullValueInput | InputJsonValue
    achievements?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutUserStatsNestedInput
  }

  export type UserStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalPlayTime?: IntFieldUpdateOperationsInput | number
    totalSessions?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesCompleted?: IntFieldUpdateOperationsInput | number
    lastPlayedGame?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weeklyStats?: NullableJsonNullValueInput | InputJsonValue
    monthlyStats?: NullableJsonNullValueInput | InputJsonValue
    achievements?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserStatsCreateManyInput = {
    id?: string
    userId: string
    totalPlayTime?: number
    totalSessions?: number
    gamesPlayed?: number
    gamesCompleted?: number
    lastPlayedGame?: string | null
    lastPlayedAt?: Date | string | null
    weeklyStats?: NullableJsonNullValueInput | InputJsonValue
    monthlyStats?: NullableJsonNullValueInput | InputJsonValue
    achievements?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPlayTime?: IntFieldUpdateOperationsInput | number
    totalSessions?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesCompleted?: IntFieldUpdateOperationsInput | number
    lastPlayedGame?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weeklyStats?: NullableJsonNullValueInput | InputJsonValue
    monthlyStats?: NullableJsonNullValueInput | InputJsonValue
    achievements?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalPlayTime?: IntFieldUpdateOperationsInput | number
    totalSessions?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesCompleted?: IntFieldUpdateOperationsInput | number
    lastPlayedGame?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weeklyStats?: NullableJsonNullValueInput | InputJsonValue
    monthlyStats?: NullableJsonNullValueInput | InputJsonValue
    achievements?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    averageDuration?: string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    isAutoGenerated?: boolean
    isMainCampaign?: boolean
    difficulty?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    game: GameCreateNestedOneWithoutCampaignsInput
    parent?: CampaignCreateNestedOneWithoutChildrenInput
    children?: CampaignCreateNestedManyWithoutParentInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    averageDuration?: string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    parentId?: string | null
    isAutoGenerated?: boolean
    isMainCampaign?: boolean
    difficulty?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    children?: CampaignUncheckedCreateNestedManyWithoutParentInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    averageDuration?: NullableStringFieldUpdateOperationsInput | string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    isMainCampaign?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutCampaignsNestedInput
    parent?: CampaignUpdateOneWithoutChildrenNestedInput
    children?: CampaignUpdateManyWithoutParentNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    averageDuration?: NullableStringFieldUpdateOperationsInput | string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    isMainCampaign?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CampaignUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    averageDuration?: string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    parentId?: string | null
    isAutoGenerated?: boolean
    isMainCampaign?: boolean
    difficulty?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    averageDuration?: NullableStringFieldUpdateOperationsInput | string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    isMainCampaign?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    averageDuration?: NullableStringFieldUpdateOperationsInput | string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    isMainCampaign?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageVisitCreateInput = {
    id?: string
    page: string
    visitedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutPageVisitsInput
  }

  export type PageVisitUncheckedCreateInput = {
    id?: string
    userId: string
    page: string
    visitedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PageVisitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutPageVisitsNestedInput
  }

  export type PageVisitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PageVisitCreateManyInput = {
    id?: string
    userId: string
    page: string
    visitedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PageVisitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PageVisitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type?: string
    isRead?: boolean
    isGlobal?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt?: Date | string | null
    user?: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId?: string | null
    title: string
    message: string
    type?: string
    isRead?: boolean
    isGlobal?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId?: string | null
    title: string
    message: string
    type?: string
    isRead?: boolean
    isGlobal?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemUpdateCreateInput = {
    id?: string
    title: string
    description: string
    version?: string | null
    type?: string
    status?: string
    progress?: number
    priority?: string
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    substeps?: SystemUpdateStepCreateNestedManyWithoutUpdateInput
  }

  export type SystemUpdateUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    version?: string | null
    type?: string
    status?: string
    progress?: number
    priority?: string
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    substeps?: SystemUpdateStepUncheckedCreateNestedManyWithoutUpdateInput
  }

  export type SystemUpdateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    substeps?: SystemUpdateStepUpdateManyWithoutUpdateNestedInput
  }

  export type SystemUpdateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    substeps?: SystemUpdateStepUncheckedUpdateManyWithoutUpdateNestedInput
  }

  export type SystemUpdateCreateManyInput = {
    id?: string
    title: string
    description: string
    version?: string | null
    type?: string
    status?: string
    progress?: number
    priority?: string
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemUpdateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemUpdateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemUpdateStepCreateInput = {
    id?: string
    title: string
    description?: string | null
    progress?: number
    status?: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    update: SystemUpdateCreateNestedOneWithoutSubstepsInput
  }

  export type SystemUpdateStepUncheckedCreateInput = {
    id?: string
    updateId: string
    title: string
    description?: string | null
    progress?: number
    status?: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemUpdateStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update?: SystemUpdateUpdateOneRequiredWithoutSubstepsNestedInput
  }

  export type SystemUpdateStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    updateId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemUpdateStepCreateManyInput = {
    id?: string
    updateId: string
    title: string
    description?: string | null
    progress?: number
    status?: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemUpdateStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemUpdateStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    updateId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlatformCreateInput = {
    id?: string
    name: string
    logoUrl?: string | null
    logoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformUncheckedCreateInput = {
    id?: string
    name: string
    logoUrl?: string | null
    logoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformCreateManyInput = {
    id?: string
    name: string
    logoUrl?: string | null
    logoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangelogCreateInput = {
    id?: string
    title: string
    content: string
    version?: string | null
    type?: string
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    releaseDate?: Date | string | null
    author: UserCreateNestedOneWithoutChangelogsInput
  }

  export type ChangelogUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    version?: string | null
    type?: string
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    releaseDate?: Date | string | null
  }

  export type ChangelogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: UserUpdateOneRequiredWithoutChangelogsNestedInput
  }

  export type ChangelogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangelogCreateManyInput = {
    id?: string
    title: string
    content: string
    version?: string | null
    type?: string
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    releaseDate?: Date | string | null
  }

  export type ChangelogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangelogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminAuditLogCreateInput = {
    id?: string
    action: string
    targetType: string
    targetId?: string | null
    targetName?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
    admin: UserCreateNestedOneWithoutAdminAuditLogsInput
  }

  export type AdminAuditLogUncheckedCreateInput = {
    id?: string
    action: string
    targetType: string
    targetId?: string | null
    targetName?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
    adminId: string
  }

  export type AdminAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneRequiredWithoutAdminAuditLogsNestedInput
  }

  export type AdminAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminAuditLogCreateManyInput = {
    id?: string
    action: string
    targetType: string
    targetId?: string | null
    targetName?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
    adminId: string
  }

  export type AdminAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
  }

  export type session_historyCreateInput = {
    id: string
    gameName: string
    startTime: Date | string
    endTime: Date | string
    playtime: number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
    createdAt?: Date | string
    games: GameCreateNestedOneWithoutSession_historyInput
    users: UserCreateNestedOneWithoutSession_historyInput
  }

  export type session_historyUncheckedCreateInput = {
    id: string
    userId: string
    gameId: string
    gameName: string
    startTime: Date | string
    endTime: Date | string
    playtime: number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type session_historyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    playtime?: IntFieldUpdateOperationsInput | number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameUpdateOneRequiredWithoutSession_historyNestedInput
    users?: UserUpdateOneRequiredWithoutSession_historyNestedInput
  }

  export type session_historyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    playtime?: IntFieldUpdateOperationsInput | number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type session_historyCreateManyInput = {
    id: string
    userId: string
    gameId: string
    gameName: string
    startTime: Date | string
    endTime: Date | string
    playtime: number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type session_historyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    playtime?: IntFieldUpdateOperationsInput | number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type session_historyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    playtime?: IntFieldUpdateOperationsInput | number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_librariesCreateInput = {
    id: string
    version?: string
    totalGames?: number
    totalPlaytime?: number
    lastUpdated?: Date | string
    users: UserCreateNestedOneWithoutUser_librariesInput
  }

  export type user_librariesUncheckedCreateInput = {
    id: string
    userId: string
    version?: string
    totalGames?: number
    totalPlaytime?: number
    lastUpdated?: Date | string
  }

  export type user_librariesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    totalGames?: IntFieldUpdateOperationsInput | number
    totalPlaytime?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneRequiredWithoutUser_librariesNestedInput
  }

  export type user_librariesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    totalGames?: IntFieldUpdateOperationsInput | number
    totalPlaytime?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_librariesCreateManyInput = {
    id: string
    userId: string
    version?: string
    totalGames?: number
    totalPlaytime?: number
    lastUpdated?: Date | string
  }

  export type user_librariesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    totalGames?: IntFieldUpdateOperationsInput | number
    totalPlaytime?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_librariesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    totalGames?: IntFieldUpdateOperationsInput | number
    totalPlaytime?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AdminAuditLogListRelationFilter = {
    every?: AdminAuditLogWhereInput
    some?: AdminAuditLogWhereInput
    none?: AdminAuditLogWhereInput
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type ChangelogListRelationFilter = {
    every?: ChangelogWhereInput
    some?: ChangelogWhereInput
    none?: ChangelogWhereInput
  }

  export type GameSessionListRelationFilter = {
    every?: GameSessionWhereInput
    some?: GameSessionWhereInput
    none?: GameSessionWhereInput
  }

  export type LibraryEntryListRelationFilter = {
    every?: LibraryEntryWhereInput
    some?: LibraryEntryWhereInput
    none?: LibraryEntryWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type PageVisitListRelationFilter = {
    every?: PageVisitWhereInput
    some?: PageVisitWhereInput
    none?: PageVisitWhereInput
  }

  export type Session_historyListRelationFilter = {
    every?: session_historyWhereInput
    some?: session_historyWhereInput
    none?: session_historyWhereInput
  }

  export type User_librariesNullableScalarRelationFilter = {
    is?: user_librariesWhereInput | null
    isNot?: user_librariesWhereInput | null
  }

  export type UserPreferencesNullableScalarRelationFilter = {
    is?: UserPreferencesWhereInput | null
    isNot?: UserPreferencesWhereInput | null
  }

  export type UserStatsNullableScalarRelationFilter = {
    is?: UserStatsWhereInput | null
    isNot?: UserStatsWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AdminAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChangelogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PageVisitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type session_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    createdAt?: SortOrder
    lastActive?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    profileImage?: SortOrder
    profileImageKey?: SortOrder
    status?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    createdAt?: SortOrder
    lastActive?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    profileImage?: SortOrder
    profileImageKey?: SortOrder
    status?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    createdAt?: SortOrder
    lastActive?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    profileImage?: SortOrder
    profileImageKey?: SortOrder
    status?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ApiKeyServiceNameUserIdCompoundUniqueInput = {
    serviceName: string
    userId: string
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceName?: SortOrder
    keyName?: SortOrder
    keyValue?: SortOrder
    isActive?: SortOrder
    isGlobal?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsed?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceName?: SortOrder
    keyName?: SortOrder
    keyValue?: SortOrder
    isActive?: SortOrder
    isGlobal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsed?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceName?: SortOrder
    keyName?: SortOrder
    keyValue?: SortOrder
    isActive?: SortOrder
    isGlobal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsed?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cover?: SortOrder
    firstReleaseDate?: SortOrder
    genres?: SortOrder
    platforms?: SortOrder
    summary?: SortOrder
    rating?: SortOrder
    developer?: SortOrder
    developers?: SortOrder
    publisher?: SortOrder
    publishers?: SortOrder
    steamData?: SortOrder
    igdbData?: SortOrder
    hltbData?: SortOrder
    metacriticData?: SortOrder
    cachedAt?: SortOrder
    lastAccessed?: SortOrder
    accessCount?: SortOrder
    coverKey?: SortOrder
  }

  export type GameAvgOrderByAggregateInput = {
    rating?: SortOrder
    accessCount?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cover?: SortOrder
    firstReleaseDate?: SortOrder
    summary?: SortOrder
    rating?: SortOrder
    developer?: SortOrder
    publisher?: SortOrder
    cachedAt?: SortOrder
    lastAccessed?: SortOrder
    accessCount?: SortOrder
    coverKey?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cover?: SortOrder
    firstReleaseDate?: SortOrder
    summary?: SortOrder
    rating?: SortOrder
    developer?: SortOrder
    publisher?: SortOrder
    cachedAt?: SortOrder
    lastAccessed?: SortOrder
    accessCount?: SortOrder
    coverKey?: SortOrder
  }

  export type GameSumOrderByAggregateInput = {
    rating?: SortOrder
    accessCount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type GameScalarRelationFilter = {
    is?: GameWhereInput
    isNot?: GameWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type LibraryEntryUserIdGameIdCompoundUniqueInput = {
    userId: string
    gameId: string
  }

  export type LibraryEntryCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    category?: SortOrder
    playtime?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    lastPlayed?: SortOrder
    progress?: SortOrder
    addedAt?: SortOrder
    isPublic?: SortOrder
    tags?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
  }

  export type LibraryEntryAvgOrderByAggregateInput = {
    playtime?: SortOrder
    rating?: SortOrder
    progress?: SortOrder
    priority?: SortOrder
  }

  export type LibraryEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    category?: SortOrder
    playtime?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    lastPlayed?: SortOrder
    progress?: SortOrder
    addedAt?: SortOrder
    isPublic?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
  }

  export type LibraryEntryMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    category?: SortOrder
    playtime?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    lastPlayed?: SortOrder
    progress?: SortOrder
    addedAt?: SortOrder
    isPublic?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
  }

  export type LibraryEntrySumOrderByAggregateInput = {
    playtime?: SortOrder
    rating?: SortOrder
    progress?: SortOrder
    priority?: SortOrder
  }

  export type UserPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    preferredPlatform?: SortOrder
    preferredStatus?: SortOrder
    includeDLCs?: SortOrder
    selectedDLCs?: SortOrder
    selectedCampaigns?: SortOrder
    preferredVersion?: SortOrder
    gameSpecificPrefs?: SortOrder
    autoLoadHLTB?: SortOrder
    autoLoadMetacritic?: SortOrder
    autoGenerateCampaigns?: SortOrder
  }

  export type UserPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    preferredPlatform?: SortOrder
    preferredStatus?: SortOrder
    includeDLCs?: SortOrder
    preferredVersion?: SortOrder
    autoLoadHLTB?: SortOrder
    autoLoadMetacritic?: SortOrder
    autoGenerateCampaigns?: SortOrder
  }

  export type UserPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    preferredPlatform?: SortOrder
    preferredStatus?: SortOrder
    includeDLCs?: SortOrder
    preferredVersion?: SortOrder
    autoLoadHLTB?: SortOrder
    autoLoadMetacritic?: SortOrder
    autoGenerateCampaigns?: SortOrder
  }

  export type GameSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    gameName?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    playtime?: SortOrder
    isActive?: SortOrder
    campaigns?: SortOrder
    platform?: SortOrder
    status?: SortOrder
  }

  export type GameSessionAvgOrderByAggregateInput = {
    playtime?: SortOrder
  }

  export type GameSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    gameName?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    playtime?: SortOrder
    isActive?: SortOrder
    platform?: SortOrder
    status?: SortOrder
  }

  export type GameSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    gameName?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    playtime?: SortOrder
    isActive?: SortOrder
    platform?: SortOrder
    status?: SortOrder
  }

  export type GameSessionSumOrderByAggregateInput = {
    playtime?: SortOrder
  }

  export type UserStatsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPlayTime?: SortOrder
    totalSessions?: SortOrder
    gamesPlayed?: SortOrder
    gamesCompleted?: SortOrder
    lastPlayedGame?: SortOrder
    lastPlayedAt?: SortOrder
    weeklyStats?: SortOrder
    monthlyStats?: SortOrder
    achievements?: SortOrder
  }

  export type UserStatsAvgOrderByAggregateInput = {
    totalPlayTime?: SortOrder
    totalSessions?: SortOrder
    gamesPlayed?: SortOrder
    gamesCompleted?: SortOrder
  }

  export type UserStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPlayTime?: SortOrder
    totalSessions?: SortOrder
    gamesPlayed?: SortOrder
    gamesCompleted?: SortOrder
    lastPlayedGame?: SortOrder
    lastPlayedAt?: SortOrder
  }

  export type UserStatsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPlayTime?: SortOrder
    totalSessions?: SortOrder
    gamesPlayed?: SortOrder
    gamesCompleted?: SortOrder
    lastPlayedGame?: SortOrder
    lastPlayedAt?: SortOrder
  }

  export type UserStatsSumOrderByAggregateInput = {
    totalPlayTime?: SortOrder
    totalSessions?: SortOrder
    gamesPlayed?: SortOrder
    gamesCompleted?: SortOrder
  }

  export type CampaignNullableScalarRelationFilter = {
    is?: CampaignWhereInput | null
    isNot?: CampaignWhereInput | null
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    averageDuration?: SortOrder
    customProperties?: SortOrder
    parentId?: SortOrder
    isAutoGenerated?: SortOrder
    isMainCampaign?: SortOrder
    difficulty?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    averageDuration?: SortOrder
    parentId?: SortOrder
    isAutoGenerated?: SortOrder
    isMainCampaign?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    averageDuration?: SortOrder
    parentId?: SortOrder
    isAutoGenerated?: SortOrder
    isMainCampaign?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
  }

  export type PageVisitCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    visitedAt?: SortOrder
    metadata?: SortOrder
  }

  export type PageVisitMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    visitedAt?: SortOrder
  }

  export type PageVisitMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    visitedAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    isGlobal?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    isGlobal?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    isGlobal?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SystemUpdateStepListRelationFilter = {
    every?: SystemUpdateStepWhereInput
    some?: SystemUpdateStepWhereInput
    none?: SystemUpdateStepWhereInput
  }

  export type SystemUpdateStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemUpdateCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    version?: SortOrder
    type?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type SystemUpdateAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type SystemUpdateMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    version?: SortOrder
    type?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type SystemUpdateMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    version?: SortOrder
    type?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type SystemUpdateSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type SystemUpdateScalarRelationFilter = {
    is?: SystemUpdateWhereInput
    isNot?: SystemUpdateWhereInput
  }

  export type SystemUpdateStepCountOrderByAggregateInput = {
    id?: SortOrder
    updateId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type SystemUpdateStepAvgOrderByAggregateInput = {
    progress?: SortOrder
    order?: SortOrder
  }

  export type SystemUpdateStepMaxOrderByAggregateInput = {
    id?: SortOrder
    updateId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type SystemUpdateStepMinOrderByAggregateInput = {
    id?: SortOrder
    updateId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type SystemUpdateStepSumOrderByAggregateInput = {
    progress?: SortOrder
    order?: SortOrder
  }

  export type PlatformCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    logoKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    logoKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    logoKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChangelogCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    version?: SortOrder
    type?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    releaseDate?: SortOrder
  }

  export type ChangelogMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    version?: SortOrder
    type?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    releaseDate?: SortOrder
  }

  export type ChangelogMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    version?: SortOrder
    type?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    releaseDate?: SortOrder
  }

  export type AdminAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    targetName?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
  }

  export type AdminAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    targetName?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
  }

  export type AdminAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    targetName?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
  }

  export type session_historyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    gameName?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    playtime?: SortOrder
    campaigns?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type session_historyAvgOrderByAggregateInput = {
    playtime?: SortOrder
  }

  export type session_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    gameName?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    playtime?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type session_historyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    gameName?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    playtime?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type session_historySumOrderByAggregateInput = {
    playtime?: SortOrder
  }

  export type user_librariesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    version?: SortOrder
    totalGames?: SortOrder
    totalPlaytime?: SortOrder
    lastUpdated?: SortOrder
  }

  export type user_librariesAvgOrderByAggregateInput = {
    totalGames?: SortOrder
    totalPlaytime?: SortOrder
  }

  export type user_librariesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    version?: SortOrder
    totalGames?: SortOrder
    totalPlaytime?: SortOrder
    lastUpdated?: SortOrder
  }

  export type user_librariesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    version?: SortOrder
    totalGames?: SortOrder
    totalPlaytime?: SortOrder
    lastUpdated?: SortOrder
  }

  export type user_librariesSumOrderByAggregateInput = {
    totalGames?: SortOrder
    totalPlaytime?: SortOrder
  }

  export type AdminAuditLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
  }

  export type ApiKeyCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type ChangelogCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ChangelogCreateWithoutAuthorInput, ChangelogUncheckedCreateWithoutAuthorInput> | ChangelogCreateWithoutAuthorInput[] | ChangelogUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ChangelogCreateOrConnectWithoutAuthorInput | ChangelogCreateOrConnectWithoutAuthorInput[]
    createMany?: ChangelogCreateManyAuthorInputEnvelope
    connect?: ChangelogWhereUniqueInput | ChangelogWhereUniqueInput[]
  }

  export type GameSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<GameSessionCreateWithoutUserInput, GameSessionUncheckedCreateWithoutUserInput> | GameSessionCreateWithoutUserInput[] | GameSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutUserInput | GameSessionCreateOrConnectWithoutUserInput[]
    createMany?: GameSessionCreateManyUserInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type LibraryEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<LibraryEntryCreateWithoutUserInput, LibraryEntryUncheckedCreateWithoutUserInput> | LibraryEntryCreateWithoutUserInput[] | LibraryEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LibraryEntryCreateOrConnectWithoutUserInput | LibraryEntryCreateOrConnectWithoutUserInput[]
    createMany?: LibraryEntryCreateManyUserInputEnvelope
    connect?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PageVisitCreateNestedManyWithoutUserInput = {
    create?: XOR<PageVisitCreateWithoutUserInput, PageVisitUncheckedCreateWithoutUserInput> | PageVisitCreateWithoutUserInput[] | PageVisitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PageVisitCreateOrConnectWithoutUserInput | PageVisitCreateOrConnectWithoutUserInput[]
    createMany?: PageVisitCreateManyUserInputEnvelope
    connect?: PageVisitWhereUniqueInput | PageVisitWhereUniqueInput[]
  }

  export type session_historyCreateNestedManyWithoutUsersInput = {
    create?: XOR<session_historyCreateWithoutUsersInput, session_historyUncheckedCreateWithoutUsersInput> | session_historyCreateWithoutUsersInput[] | session_historyUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: session_historyCreateOrConnectWithoutUsersInput | session_historyCreateOrConnectWithoutUsersInput[]
    createMany?: session_historyCreateManyUsersInputEnvelope
    connect?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
  }

  export type user_librariesCreateNestedOneWithoutUsersInput = {
    create?: XOR<user_librariesCreateWithoutUsersInput, user_librariesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_librariesCreateOrConnectWithoutUsersInput
    connect?: user_librariesWhereUniqueInput
  }

  export type UserPreferencesCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type UserStatsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStatsCreateOrConnectWithoutUserInput
    connect?: UserStatsWhereUniqueInput
  }

  export type AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type ChangelogUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ChangelogCreateWithoutAuthorInput, ChangelogUncheckedCreateWithoutAuthorInput> | ChangelogCreateWithoutAuthorInput[] | ChangelogUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ChangelogCreateOrConnectWithoutAuthorInput | ChangelogCreateOrConnectWithoutAuthorInput[]
    createMany?: ChangelogCreateManyAuthorInputEnvelope
    connect?: ChangelogWhereUniqueInput | ChangelogWhereUniqueInput[]
  }

  export type GameSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GameSessionCreateWithoutUserInput, GameSessionUncheckedCreateWithoutUserInput> | GameSessionCreateWithoutUserInput[] | GameSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutUserInput | GameSessionCreateOrConnectWithoutUserInput[]
    createMany?: GameSessionCreateManyUserInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type LibraryEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LibraryEntryCreateWithoutUserInput, LibraryEntryUncheckedCreateWithoutUserInput> | LibraryEntryCreateWithoutUserInput[] | LibraryEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LibraryEntryCreateOrConnectWithoutUserInput | LibraryEntryCreateOrConnectWithoutUserInput[]
    createMany?: LibraryEntryCreateManyUserInputEnvelope
    connect?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PageVisitUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PageVisitCreateWithoutUserInput, PageVisitUncheckedCreateWithoutUserInput> | PageVisitCreateWithoutUserInput[] | PageVisitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PageVisitCreateOrConnectWithoutUserInput | PageVisitCreateOrConnectWithoutUserInput[]
    createMany?: PageVisitCreateManyUserInputEnvelope
    connect?: PageVisitWhereUniqueInput | PageVisitWhereUniqueInput[]
  }

  export type session_historyUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<session_historyCreateWithoutUsersInput, session_historyUncheckedCreateWithoutUsersInput> | session_historyCreateWithoutUsersInput[] | session_historyUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: session_historyCreateOrConnectWithoutUsersInput | session_historyCreateOrConnectWithoutUsersInput[]
    createMany?: session_historyCreateManyUsersInputEnvelope
    connect?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
  }

  export type user_librariesUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<user_librariesCreateWithoutUsersInput, user_librariesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_librariesCreateOrConnectWithoutUsersInput
    connect?: user_librariesWhereUniqueInput
  }

  export type UserPreferencesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type UserStatsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStatsCreateOrConnectWithoutUserInput
    connect?: UserStatsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AdminAuditLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput | AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    set?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    disconnect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    delete?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    update?: AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput | AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuditLogUpdateManyWithWhereWithoutAdminInput | AdminAuditLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
  }

  export type ApiKeyUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type ChangelogUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ChangelogCreateWithoutAuthorInput, ChangelogUncheckedCreateWithoutAuthorInput> | ChangelogCreateWithoutAuthorInput[] | ChangelogUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ChangelogCreateOrConnectWithoutAuthorInput | ChangelogCreateOrConnectWithoutAuthorInput[]
    upsert?: ChangelogUpsertWithWhereUniqueWithoutAuthorInput | ChangelogUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ChangelogCreateManyAuthorInputEnvelope
    set?: ChangelogWhereUniqueInput | ChangelogWhereUniqueInput[]
    disconnect?: ChangelogWhereUniqueInput | ChangelogWhereUniqueInput[]
    delete?: ChangelogWhereUniqueInput | ChangelogWhereUniqueInput[]
    connect?: ChangelogWhereUniqueInput | ChangelogWhereUniqueInput[]
    update?: ChangelogUpdateWithWhereUniqueWithoutAuthorInput | ChangelogUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ChangelogUpdateManyWithWhereWithoutAuthorInput | ChangelogUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ChangelogScalarWhereInput | ChangelogScalarWhereInput[]
  }

  export type GameSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameSessionCreateWithoutUserInput, GameSessionUncheckedCreateWithoutUserInput> | GameSessionCreateWithoutUserInput[] | GameSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutUserInput | GameSessionCreateOrConnectWithoutUserInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutUserInput | GameSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameSessionCreateManyUserInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutUserInput | GameSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutUserInput | GameSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type LibraryEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<LibraryEntryCreateWithoutUserInput, LibraryEntryUncheckedCreateWithoutUserInput> | LibraryEntryCreateWithoutUserInput[] | LibraryEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LibraryEntryCreateOrConnectWithoutUserInput | LibraryEntryCreateOrConnectWithoutUserInput[]
    upsert?: LibraryEntryUpsertWithWhereUniqueWithoutUserInput | LibraryEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LibraryEntryCreateManyUserInputEnvelope
    set?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
    disconnect?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
    delete?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
    connect?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
    update?: LibraryEntryUpdateWithWhereUniqueWithoutUserInput | LibraryEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LibraryEntryUpdateManyWithWhereWithoutUserInput | LibraryEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LibraryEntryScalarWhereInput | LibraryEntryScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PageVisitUpdateManyWithoutUserNestedInput = {
    create?: XOR<PageVisitCreateWithoutUserInput, PageVisitUncheckedCreateWithoutUserInput> | PageVisitCreateWithoutUserInput[] | PageVisitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PageVisitCreateOrConnectWithoutUserInput | PageVisitCreateOrConnectWithoutUserInput[]
    upsert?: PageVisitUpsertWithWhereUniqueWithoutUserInput | PageVisitUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PageVisitCreateManyUserInputEnvelope
    set?: PageVisitWhereUniqueInput | PageVisitWhereUniqueInput[]
    disconnect?: PageVisitWhereUniqueInput | PageVisitWhereUniqueInput[]
    delete?: PageVisitWhereUniqueInput | PageVisitWhereUniqueInput[]
    connect?: PageVisitWhereUniqueInput | PageVisitWhereUniqueInput[]
    update?: PageVisitUpdateWithWhereUniqueWithoutUserInput | PageVisitUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PageVisitUpdateManyWithWhereWithoutUserInput | PageVisitUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PageVisitScalarWhereInput | PageVisitScalarWhereInput[]
  }

  export type session_historyUpdateManyWithoutUsersNestedInput = {
    create?: XOR<session_historyCreateWithoutUsersInput, session_historyUncheckedCreateWithoutUsersInput> | session_historyCreateWithoutUsersInput[] | session_historyUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: session_historyCreateOrConnectWithoutUsersInput | session_historyCreateOrConnectWithoutUsersInput[]
    upsert?: session_historyUpsertWithWhereUniqueWithoutUsersInput | session_historyUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: session_historyCreateManyUsersInputEnvelope
    set?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
    disconnect?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
    delete?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
    connect?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
    update?: session_historyUpdateWithWhereUniqueWithoutUsersInput | session_historyUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: session_historyUpdateManyWithWhereWithoutUsersInput | session_historyUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: session_historyScalarWhereInput | session_historyScalarWhereInput[]
  }

  export type user_librariesUpdateOneWithoutUsersNestedInput = {
    create?: XOR<user_librariesCreateWithoutUsersInput, user_librariesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_librariesCreateOrConnectWithoutUsersInput
    upsert?: user_librariesUpsertWithoutUsersInput
    disconnect?: user_librariesWhereInput | boolean
    delete?: user_librariesWhereInput | boolean
    connect?: user_librariesWhereUniqueInput
    update?: XOR<XOR<user_librariesUpdateToOneWithWhereWithoutUsersInput, user_librariesUpdateWithoutUsersInput>, user_librariesUncheckedUpdateWithoutUsersInput>
  }

  export type UserPreferencesUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserStatsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStatsCreateOrConnectWithoutUserInput
    upsert?: UserStatsUpsertWithoutUserInput
    disconnect?: UserStatsWhereInput | boolean
    delete?: UserStatsWhereInput | boolean
    connect?: UserStatsWhereUniqueInput
    update?: XOR<XOR<UserStatsUpdateToOneWithWhereWithoutUserInput, UserStatsUpdateWithoutUserInput>, UserStatsUncheckedUpdateWithoutUserInput>
  }

  export type AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput | AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    set?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    disconnect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    delete?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    update?: AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput | AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuditLogUpdateManyWithWhereWithoutAdminInput | AdminAuditLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type ChangelogUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ChangelogCreateWithoutAuthorInput, ChangelogUncheckedCreateWithoutAuthorInput> | ChangelogCreateWithoutAuthorInput[] | ChangelogUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ChangelogCreateOrConnectWithoutAuthorInput | ChangelogCreateOrConnectWithoutAuthorInput[]
    upsert?: ChangelogUpsertWithWhereUniqueWithoutAuthorInput | ChangelogUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ChangelogCreateManyAuthorInputEnvelope
    set?: ChangelogWhereUniqueInput | ChangelogWhereUniqueInput[]
    disconnect?: ChangelogWhereUniqueInput | ChangelogWhereUniqueInput[]
    delete?: ChangelogWhereUniqueInput | ChangelogWhereUniqueInput[]
    connect?: ChangelogWhereUniqueInput | ChangelogWhereUniqueInput[]
    update?: ChangelogUpdateWithWhereUniqueWithoutAuthorInput | ChangelogUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ChangelogUpdateManyWithWhereWithoutAuthorInput | ChangelogUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ChangelogScalarWhereInput | ChangelogScalarWhereInput[]
  }

  export type GameSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameSessionCreateWithoutUserInput, GameSessionUncheckedCreateWithoutUserInput> | GameSessionCreateWithoutUserInput[] | GameSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutUserInput | GameSessionCreateOrConnectWithoutUserInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutUserInput | GameSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameSessionCreateManyUserInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutUserInput | GameSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutUserInput | GameSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type LibraryEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LibraryEntryCreateWithoutUserInput, LibraryEntryUncheckedCreateWithoutUserInput> | LibraryEntryCreateWithoutUserInput[] | LibraryEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LibraryEntryCreateOrConnectWithoutUserInput | LibraryEntryCreateOrConnectWithoutUserInput[]
    upsert?: LibraryEntryUpsertWithWhereUniqueWithoutUserInput | LibraryEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LibraryEntryCreateManyUserInputEnvelope
    set?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
    disconnect?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
    delete?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
    connect?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
    update?: LibraryEntryUpdateWithWhereUniqueWithoutUserInput | LibraryEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LibraryEntryUpdateManyWithWhereWithoutUserInput | LibraryEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LibraryEntryScalarWhereInput | LibraryEntryScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PageVisitUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PageVisitCreateWithoutUserInput, PageVisitUncheckedCreateWithoutUserInput> | PageVisitCreateWithoutUserInput[] | PageVisitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PageVisitCreateOrConnectWithoutUserInput | PageVisitCreateOrConnectWithoutUserInput[]
    upsert?: PageVisitUpsertWithWhereUniqueWithoutUserInput | PageVisitUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PageVisitCreateManyUserInputEnvelope
    set?: PageVisitWhereUniqueInput | PageVisitWhereUniqueInput[]
    disconnect?: PageVisitWhereUniqueInput | PageVisitWhereUniqueInput[]
    delete?: PageVisitWhereUniqueInput | PageVisitWhereUniqueInput[]
    connect?: PageVisitWhereUniqueInput | PageVisitWhereUniqueInput[]
    update?: PageVisitUpdateWithWhereUniqueWithoutUserInput | PageVisitUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PageVisitUpdateManyWithWhereWithoutUserInput | PageVisitUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PageVisitScalarWhereInput | PageVisitScalarWhereInput[]
  }

  export type session_historyUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<session_historyCreateWithoutUsersInput, session_historyUncheckedCreateWithoutUsersInput> | session_historyCreateWithoutUsersInput[] | session_historyUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: session_historyCreateOrConnectWithoutUsersInput | session_historyCreateOrConnectWithoutUsersInput[]
    upsert?: session_historyUpsertWithWhereUniqueWithoutUsersInput | session_historyUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: session_historyCreateManyUsersInputEnvelope
    set?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
    disconnect?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
    delete?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
    connect?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
    update?: session_historyUpdateWithWhereUniqueWithoutUsersInput | session_historyUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: session_historyUpdateManyWithWhereWithoutUsersInput | session_historyUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: session_historyScalarWhereInput | session_historyScalarWhereInput[]
  }

  export type user_librariesUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<user_librariesCreateWithoutUsersInput, user_librariesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_librariesCreateOrConnectWithoutUsersInput
    upsert?: user_librariesUpsertWithoutUsersInput
    disconnect?: user_librariesWhereInput | boolean
    delete?: user_librariesWhereInput | boolean
    connect?: user_librariesWhereUniqueInput
    update?: XOR<XOR<user_librariesUpdateToOneWithWhereWithoutUsersInput, user_librariesUpdateWithoutUsersInput>, user_librariesUncheckedUpdateWithoutUsersInput>
  }

  export type UserPreferencesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserStatsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStatsCreateOrConnectWithoutUserInput
    upsert?: UserStatsUpsertWithoutUserInput
    disconnect?: UserStatsWhereInput | boolean
    delete?: UserStatsWhereInput | boolean
    connect?: UserStatsWhereUniqueInput
    update?: XOR<XOR<UserStatsUpdateToOneWithWhereWithoutUserInput, UserStatsUpdateWithoutUserInput>, UserStatsUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneWithoutApiKeysNestedInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    upsert?: UserUpsertWithoutApiKeysInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApiKeysInput, UserUpdateWithoutApiKeysInput>, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type CampaignCreateNestedManyWithoutGameInput = {
    create?: XOR<CampaignCreateWithoutGameInput, CampaignUncheckedCreateWithoutGameInput> | CampaignCreateWithoutGameInput[] | CampaignUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutGameInput | CampaignCreateOrConnectWithoutGameInput[]
    createMany?: CampaignCreateManyGameInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type GameSessionCreateNestedManyWithoutGameInput = {
    create?: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput> | GameSessionCreateWithoutGameInput[] | GameSessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutGameInput | GameSessionCreateOrConnectWithoutGameInput[]
    createMany?: GameSessionCreateManyGameInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type LibraryEntryCreateNestedManyWithoutGameInput = {
    create?: XOR<LibraryEntryCreateWithoutGameInput, LibraryEntryUncheckedCreateWithoutGameInput> | LibraryEntryCreateWithoutGameInput[] | LibraryEntryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LibraryEntryCreateOrConnectWithoutGameInput | LibraryEntryCreateOrConnectWithoutGameInput[]
    createMany?: LibraryEntryCreateManyGameInputEnvelope
    connect?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
  }

  export type session_historyCreateNestedManyWithoutGamesInput = {
    create?: XOR<session_historyCreateWithoutGamesInput, session_historyUncheckedCreateWithoutGamesInput> | session_historyCreateWithoutGamesInput[] | session_historyUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: session_historyCreateOrConnectWithoutGamesInput | session_historyCreateOrConnectWithoutGamesInput[]
    createMany?: session_historyCreateManyGamesInputEnvelope
    connect?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<CampaignCreateWithoutGameInput, CampaignUncheckedCreateWithoutGameInput> | CampaignCreateWithoutGameInput[] | CampaignUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutGameInput | CampaignCreateOrConnectWithoutGameInput[]
    createMany?: CampaignCreateManyGameInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type GameSessionUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput> | GameSessionCreateWithoutGameInput[] | GameSessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutGameInput | GameSessionCreateOrConnectWithoutGameInput[]
    createMany?: GameSessionCreateManyGameInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type LibraryEntryUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<LibraryEntryCreateWithoutGameInput, LibraryEntryUncheckedCreateWithoutGameInput> | LibraryEntryCreateWithoutGameInput[] | LibraryEntryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LibraryEntryCreateOrConnectWithoutGameInput | LibraryEntryCreateOrConnectWithoutGameInput[]
    createMany?: LibraryEntryCreateManyGameInputEnvelope
    connect?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
  }

  export type session_historyUncheckedCreateNestedManyWithoutGamesInput = {
    create?: XOR<session_historyCreateWithoutGamesInput, session_historyUncheckedCreateWithoutGamesInput> | session_historyCreateWithoutGamesInput[] | session_historyUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: session_historyCreateOrConnectWithoutGamesInput | session_historyCreateOrConnectWithoutGamesInput[]
    createMany?: session_historyCreateManyGamesInputEnvelope
    connect?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CampaignUpdateManyWithoutGameNestedInput = {
    create?: XOR<CampaignCreateWithoutGameInput, CampaignUncheckedCreateWithoutGameInput> | CampaignCreateWithoutGameInput[] | CampaignUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutGameInput | CampaignCreateOrConnectWithoutGameInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutGameInput | CampaignUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: CampaignCreateManyGameInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutGameInput | CampaignUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutGameInput | CampaignUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type GameSessionUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput> | GameSessionCreateWithoutGameInput[] | GameSessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutGameInput | GameSessionCreateOrConnectWithoutGameInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutGameInput | GameSessionUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameSessionCreateManyGameInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutGameInput | GameSessionUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutGameInput | GameSessionUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type LibraryEntryUpdateManyWithoutGameNestedInput = {
    create?: XOR<LibraryEntryCreateWithoutGameInput, LibraryEntryUncheckedCreateWithoutGameInput> | LibraryEntryCreateWithoutGameInput[] | LibraryEntryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LibraryEntryCreateOrConnectWithoutGameInput | LibraryEntryCreateOrConnectWithoutGameInput[]
    upsert?: LibraryEntryUpsertWithWhereUniqueWithoutGameInput | LibraryEntryUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LibraryEntryCreateManyGameInputEnvelope
    set?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
    disconnect?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
    delete?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
    connect?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
    update?: LibraryEntryUpdateWithWhereUniqueWithoutGameInput | LibraryEntryUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LibraryEntryUpdateManyWithWhereWithoutGameInput | LibraryEntryUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LibraryEntryScalarWhereInput | LibraryEntryScalarWhereInput[]
  }

  export type session_historyUpdateManyWithoutGamesNestedInput = {
    create?: XOR<session_historyCreateWithoutGamesInput, session_historyUncheckedCreateWithoutGamesInput> | session_historyCreateWithoutGamesInput[] | session_historyUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: session_historyCreateOrConnectWithoutGamesInput | session_historyCreateOrConnectWithoutGamesInput[]
    upsert?: session_historyUpsertWithWhereUniqueWithoutGamesInput | session_historyUpsertWithWhereUniqueWithoutGamesInput[]
    createMany?: session_historyCreateManyGamesInputEnvelope
    set?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
    disconnect?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
    delete?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
    connect?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
    update?: session_historyUpdateWithWhereUniqueWithoutGamesInput | session_historyUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: session_historyUpdateManyWithWhereWithoutGamesInput | session_historyUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: session_historyScalarWhereInput | session_historyScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<CampaignCreateWithoutGameInput, CampaignUncheckedCreateWithoutGameInput> | CampaignCreateWithoutGameInput[] | CampaignUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutGameInput | CampaignCreateOrConnectWithoutGameInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutGameInput | CampaignUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: CampaignCreateManyGameInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutGameInput | CampaignUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutGameInput | CampaignUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type GameSessionUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput> | GameSessionCreateWithoutGameInput[] | GameSessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutGameInput | GameSessionCreateOrConnectWithoutGameInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutGameInput | GameSessionUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameSessionCreateManyGameInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutGameInput | GameSessionUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutGameInput | GameSessionUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type LibraryEntryUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<LibraryEntryCreateWithoutGameInput, LibraryEntryUncheckedCreateWithoutGameInput> | LibraryEntryCreateWithoutGameInput[] | LibraryEntryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LibraryEntryCreateOrConnectWithoutGameInput | LibraryEntryCreateOrConnectWithoutGameInput[]
    upsert?: LibraryEntryUpsertWithWhereUniqueWithoutGameInput | LibraryEntryUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LibraryEntryCreateManyGameInputEnvelope
    set?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
    disconnect?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
    delete?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
    connect?: LibraryEntryWhereUniqueInput | LibraryEntryWhereUniqueInput[]
    update?: LibraryEntryUpdateWithWhereUniqueWithoutGameInput | LibraryEntryUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LibraryEntryUpdateManyWithWhereWithoutGameInput | LibraryEntryUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LibraryEntryScalarWhereInput | LibraryEntryScalarWhereInput[]
  }

  export type session_historyUncheckedUpdateManyWithoutGamesNestedInput = {
    create?: XOR<session_historyCreateWithoutGamesInput, session_historyUncheckedCreateWithoutGamesInput> | session_historyCreateWithoutGamesInput[] | session_historyUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: session_historyCreateOrConnectWithoutGamesInput | session_historyCreateOrConnectWithoutGamesInput[]
    upsert?: session_historyUpsertWithWhereUniqueWithoutGamesInput | session_historyUpsertWithWhereUniqueWithoutGamesInput[]
    createMany?: session_historyCreateManyGamesInputEnvelope
    set?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
    disconnect?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
    delete?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
    connect?: session_historyWhereUniqueInput | session_historyWhereUniqueInput[]
    update?: session_historyUpdateWithWhereUniqueWithoutGamesInput | session_historyUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: session_historyUpdateManyWithWhereWithoutGamesInput | session_historyUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: session_historyScalarWhereInput | session_historyScalarWhereInput[]
  }

  export type GameCreateNestedOneWithoutLibraryEntriesInput = {
    create?: XOR<GameCreateWithoutLibraryEntriesInput, GameUncheckedCreateWithoutLibraryEntriesInput>
    connectOrCreate?: GameCreateOrConnectWithoutLibraryEntriesInput
    connect?: GameWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLibraryEntriesInput = {
    create?: XOR<UserCreateWithoutLibraryEntriesInput, UserUncheckedCreateWithoutLibraryEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLibraryEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type GameUpdateOneRequiredWithoutLibraryEntriesNestedInput = {
    create?: XOR<GameCreateWithoutLibraryEntriesInput, GameUncheckedCreateWithoutLibraryEntriesInput>
    connectOrCreate?: GameCreateOrConnectWithoutLibraryEntriesInput
    upsert?: GameUpsertWithoutLibraryEntriesInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutLibraryEntriesInput, GameUpdateWithoutLibraryEntriesInput>, GameUncheckedUpdateWithoutLibraryEntriesInput>
  }

  export type UserUpdateOneRequiredWithoutLibraryEntriesNestedInput = {
    create?: XOR<UserCreateWithoutLibraryEntriesInput, UserUncheckedCreateWithoutLibraryEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLibraryEntriesInput
    upsert?: UserUpsertWithoutLibraryEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLibraryEntriesInput, UserUpdateWithoutLibraryEntriesInput>, UserUncheckedUpdateWithoutLibraryEntriesInput>
  }

  export type UserCreateNestedOneWithoutPreferencesInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    upsert?: UserUpsertWithoutPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPreferencesInput, UserUpdateWithoutPreferencesInput>, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type GameCreateNestedOneWithoutSessionsInput = {
    create?: XOR<GameCreateWithoutSessionsInput, GameUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: GameCreateOrConnectWithoutSessionsInput
    connect?: GameWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type GameUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<GameCreateWithoutSessionsInput, GameUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: GameCreateOrConnectWithoutSessionsInput
    upsert?: GameUpsertWithoutSessionsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutSessionsInput, GameUpdateWithoutSessionsInput>, GameUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutUserStatsInput = {
    create?: XOR<UserCreateWithoutUserStatsInput, UserUncheckedCreateWithoutUserStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserStatsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserStatsNestedInput = {
    create?: XOR<UserCreateWithoutUserStatsInput, UserUncheckedCreateWithoutUserStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserStatsInput
    upsert?: UserUpsertWithoutUserStatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserStatsInput, UserUpdateWithoutUserStatsInput>, UserUncheckedUpdateWithoutUserStatsInput>
  }

  export type GameCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<GameCreateWithoutCampaignsInput, GameUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: GameCreateOrConnectWithoutCampaignsInput
    connect?: GameWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CampaignCreateWithoutChildrenInput, CampaignUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutChildrenInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignCreateNestedManyWithoutParentInput = {
    create?: XOR<CampaignCreateWithoutParentInput, CampaignUncheckedCreateWithoutParentInput> | CampaignCreateWithoutParentInput[] | CampaignUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutParentInput | CampaignCreateOrConnectWithoutParentInput[]
    createMany?: CampaignCreateManyParentInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CampaignCreateWithoutParentInput, CampaignUncheckedCreateWithoutParentInput> | CampaignCreateWithoutParentInput[] | CampaignUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutParentInput | CampaignCreateOrConnectWithoutParentInput[]
    createMany?: CampaignCreateManyParentInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type GameUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<GameCreateWithoutCampaignsInput, GameUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: GameCreateOrConnectWithoutCampaignsInput
    upsert?: GameUpsertWithoutCampaignsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutCampaignsInput, GameUpdateWithoutCampaignsInput>, GameUncheckedUpdateWithoutCampaignsInput>
  }

  export type CampaignUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CampaignCreateWithoutChildrenInput, CampaignUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutChildrenInput
    upsert?: CampaignUpsertWithoutChildrenInput
    disconnect?: CampaignWhereInput | boolean
    delete?: CampaignWhereInput | boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutChildrenInput, CampaignUpdateWithoutChildrenInput>, CampaignUncheckedUpdateWithoutChildrenInput>
  }

  export type CampaignUpdateManyWithoutParentNestedInput = {
    create?: XOR<CampaignCreateWithoutParentInput, CampaignUncheckedCreateWithoutParentInput> | CampaignCreateWithoutParentInput[] | CampaignUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutParentInput | CampaignCreateOrConnectWithoutParentInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutParentInput | CampaignUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CampaignCreateManyParentInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutParentInput | CampaignUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutParentInput | CampaignUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CampaignCreateWithoutParentInput, CampaignUncheckedCreateWithoutParentInput> | CampaignCreateWithoutParentInput[] | CampaignUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutParentInput | CampaignCreateOrConnectWithoutParentInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutParentInput | CampaignUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CampaignCreateManyParentInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutParentInput | CampaignUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutParentInput | CampaignUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPageVisitsInput = {
    create?: XOR<UserCreateWithoutPageVisitsInput, UserUncheckedCreateWithoutPageVisitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPageVisitsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPageVisitsNestedInput = {
    create?: XOR<UserCreateWithoutPageVisitsInput, UserUncheckedCreateWithoutPageVisitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPageVisitsInput
    upsert?: UserUpsertWithoutPageVisitsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPageVisitsInput, UserUpdateWithoutPageVisitsInput>, UserUncheckedUpdateWithoutPageVisitsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type SystemUpdateStepCreateNestedManyWithoutUpdateInput = {
    create?: XOR<SystemUpdateStepCreateWithoutUpdateInput, SystemUpdateStepUncheckedCreateWithoutUpdateInput> | SystemUpdateStepCreateWithoutUpdateInput[] | SystemUpdateStepUncheckedCreateWithoutUpdateInput[]
    connectOrCreate?: SystemUpdateStepCreateOrConnectWithoutUpdateInput | SystemUpdateStepCreateOrConnectWithoutUpdateInput[]
    createMany?: SystemUpdateStepCreateManyUpdateInputEnvelope
    connect?: SystemUpdateStepWhereUniqueInput | SystemUpdateStepWhereUniqueInput[]
  }

  export type SystemUpdateStepUncheckedCreateNestedManyWithoutUpdateInput = {
    create?: XOR<SystemUpdateStepCreateWithoutUpdateInput, SystemUpdateStepUncheckedCreateWithoutUpdateInput> | SystemUpdateStepCreateWithoutUpdateInput[] | SystemUpdateStepUncheckedCreateWithoutUpdateInput[]
    connectOrCreate?: SystemUpdateStepCreateOrConnectWithoutUpdateInput | SystemUpdateStepCreateOrConnectWithoutUpdateInput[]
    createMany?: SystemUpdateStepCreateManyUpdateInputEnvelope
    connect?: SystemUpdateStepWhereUniqueInput | SystemUpdateStepWhereUniqueInput[]
  }

  export type SystemUpdateStepUpdateManyWithoutUpdateNestedInput = {
    create?: XOR<SystemUpdateStepCreateWithoutUpdateInput, SystemUpdateStepUncheckedCreateWithoutUpdateInput> | SystemUpdateStepCreateWithoutUpdateInput[] | SystemUpdateStepUncheckedCreateWithoutUpdateInput[]
    connectOrCreate?: SystemUpdateStepCreateOrConnectWithoutUpdateInput | SystemUpdateStepCreateOrConnectWithoutUpdateInput[]
    upsert?: SystemUpdateStepUpsertWithWhereUniqueWithoutUpdateInput | SystemUpdateStepUpsertWithWhereUniqueWithoutUpdateInput[]
    createMany?: SystemUpdateStepCreateManyUpdateInputEnvelope
    set?: SystemUpdateStepWhereUniqueInput | SystemUpdateStepWhereUniqueInput[]
    disconnect?: SystemUpdateStepWhereUniqueInput | SystemUpdateStepWhereUniqueInput[]
    delete?: SystemUpdateStepWhereUniqueInput | SystemUpdateStepWhereUniqueInput[]
    connect?: SystemUpdateStepWhereUniqueInput | SystemUpdateStepWhereUniqueInput[]
    update?: SystemUpdateStepUpdateWithWhereUniqueWithoutUpdateInput | SystemUpdateStepUpdateWithWhereUniqueWithoutUpdateInput[]
    updateMany?: SystemUpdateStepUpdateManyWithWhereWithoutUpdateInput | SystemUpdateStepUpdateManyWithWhereWithoutUpdateInput[]
    deleteMany?: SystemUpdateStepScalarWhereInput | SystemUpdateStepScalarWhereInput[]
  }

  export type SystemUpdateStepUncheckedUpdateManyWithoutUpdateNestedInput = {
    create?: XOR<SystemUpdateStepCreateWithoutUpdateInput, SystemUpdateStepUncheckedCreateWithoutUpdateInput> | SystemUpdateStepCreateWithoutUpdateInput[] | SystemUpdateStepUncheckedCreateWithoutUpdateInput[]
    connectOrCreate?: SystemUpdateStepCreateOrConnectWithoutUpdateInput | SystemUpdateStepCreateOrConnectWithoutUpdateInput[]
    upsert?: SystemUpdateStepUpsertWithWhereUniqueWithoutUpdateInput | SystemUpdateStepUpsertWithWhereUniqueWithoutUpdateInput[]
    createMany?: SystemUpdateStepCreateManyUpdateInputEnvelope
    set?: SystemUpdateStepWhereUniqueInput | SystemUpdateStepWhereUniqueInput[]
    disconnect?: SystemUpdateStepWhereUniqueInput | SystemUpdateStepWhereUniqueInput[]
    delete?: SystemUpdateStepWhereUniqueInput | SystemUpdateStepWhereUniqueInput[]
    connect?: SystemUpdateStepWhereUniqueInput | SystemUpdateStepWhereUniqueInput[]
    update?: SystemUpdateStepUpdateWithWhereUniqueWithoutUpdateInput | SystemUpdateStepUpdateWithWhereUniqueWithoutUpdateInput[]
    updateMany?: SystemUpdateStepUpdateManyWithWhereWithoutUpdateInput | SystemUpdateStepUpdateManyWithWhereWithoutUpdateInput[]
    deleteMany?: SystemUpdateStepScalarWhereInput | SystemUpdateStepScalarWhereInput[]
  }

  export type SystemUpdateCreateNestedOneWithoutSubstepsInput = {
    create?: XOR<SystemUpdateCreateWithoutSubstepsInput, SystemUpdateUncheckedCreateWithoutSubstepsInput>
    connectOrCreate?: SystemUpdateCreateOrConnectWithoutSubstepsInput
    connect?: SystemUpdateWhereUniqueInput
  }

  export type SystemUpdateUpdateOneRequiredWithoutSubstepsNestedInput = {
    create?: XOR<SystemUpdateCreateWithoutSubstepsInput, SystemUpdateUncheckedCreateWithoutSubstepsInput>
    connectOrCreate?: SystemUpdateCreateOrConnectWithoutSubstepsInput
    upsert?: SystemUpdateUpsertWithoutSubstepsInput
    connect?: SystemUpdateWhereUniqueInput
    update?: XOR<XOR<SystemUpdateUpdateToOneWithWhereWithoutSubstepsInput, SystemUpdateUpdateWithoutSubstepsInput>, SystemUpdateUncheckedUpdateWithoutSubstepsInput>
  }

  export type UserCreateNestedOneWithoutChangelogsInput = {
    create?: XOR<UserCreateWithoutChangelogsInput, UserUncheckedCreateWithoutChangelogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChangelogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChangelogsNestedInput = {
    create?: XOR<UserCreateWithoutChangelogsInput, UserUncheckedCreateWithoutChangelogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChangelogsInput
    upsert?: UserUpsertWithoutChangelogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChangelogsInput, UserUpdateWithoutChangelogsInput>, UserUncheckedUpdateWithoutChangelogsInput>
  }

  export type UserCreateNestedOneWithoutAdminAuditLogsInput = {
    create?: XOR<UserCreateWithoutAdminAuditLogsInput, UserUncheckedCreateWithoutAdminAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAdminAuditLogsInput, UserUncheckedCreateWithoutAdminAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminAuditLogsInput
    upsert?: UserUpsertWithoutAdminAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminAuditLogsInput, UserUpdateWithoutAdminAuditLogsInput>, UserUncheckedUpdateWithoutAdminAuditLogsInput>
  }

  export type GameCreateNestedOneWithoutSession_historyInput = {
    create?: XOR<GameCreateWithoutSession_historyInput, GameUncheckedCreateWithoutSession_historyInput>
    connectOrCreate?: GameCreateOrConnectWithoutSession_historyInput
    connect?: GameWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSession_historyInput = {
    create?: XOR<UserCreateWithoutSession_historyInput, UserUncheckedCreateWithoutSession_historyInput>
    connectOrCreate?: UserCreateOrConnectWithoutSession_historyInput
    connect?: UserWhereUniqueInput
  }

  export type GameUpdateOneRequiredWithoutSession_historyNestedInput = {
    create?: XOR<GameCreateWithoutSession_historyInput, GameUncheckedCreateWithoutSession_historyInput>
    connectOrCreate?: GameCreateOrConnectWithoutSession_historyInput
    upsert?: GameUpsertWithoutSession_historyInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutSession_historyInput, GameUpdateWithoutSession_historyInput>, GameUncheckedUpdateWithoutSession_historyInput>
  }

  export type UserUpdateOneRequiredWithoutSession_historyNestedInput = {
    create?: XOR<UserCreateWithoutSession_historyInput, UserUncheckedCreateWithoutSession_historyInput>
    connectOrCreate?: UserCreateOrConnectWithoutSession_historyInput
    upsert?: UserUpsertWithoutSession_historyInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSession_historyInput, UserUpdateWithoutSession_historyInput>, UserUncheckedUpdateWithoutSession_historyInput>
  }

  export type UserCreateNestedOneWithoutUser_librariesInput = {
    create?: XOR<UserCreateWithoutUser_librariesInput, UserUncheckedCreateWithoutUser_librariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_librariesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUser_librariesNestedInput = {
    create?: XOR<UserCreateWithoutUser_librariesInput, UserUncheckedCreateWithoutUser_librariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_librariesInput
    upsert?: UserUpsertWithoutUser_librariesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_librariesInput, UserUpdateWithoutUser_librariesInput>, UserUncheckedUpdateWithoutUser_librariesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AdminAuditLogCreateWithoutAdminInput = {
    id?: string
    action: string
    targetType: string
    targetId?: string | null
    targetName?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUncheckedCreateWithoutAdminInput = {
    id?: string
    action: string
    targetType: string
    targetId?: string | null
    targetName?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AdminAuditLogCreateOrConnectWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    create: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuditLogCreateManyAdminInputEnvelope = {
    data: AdminAuditLogCreateManyAdminInput | AdminAuditLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyCreateWithoutUserInput = {
    id?: string
    serviceName: string
    keyName: string
    keyValue: string
    isActive?: boolean
    isGlobal?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsed?: Date | string | null
  }

  export type ApiKeyUncheckedCreateWithoutUserInput = {
    id?: string
    serviceName: string
    keyName: string
    keyValue: string
    isActive?: boolean
    isGlobal?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsed?: Date | string | null
  }

  export type ApiKeyCreateOrConnectWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyCreateManyUserInputEnvelope = {
    data: ApiKeyCreateManyUserInput | ApiKeyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChangelogCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    version?: string | null
    type?: string
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    releaseDate?: Date | string | null
  }

  export type ChangelogUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    version?: string | null
    type?: string
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    releaseDate?: Date | string | null
  }

  export type ChangelogCreateOrConnectWithoutAuthorInput = {
    where: ChangelogWhereUniqueInput
    create: XOR<ChangelogCreateWithoutAuthorInput, ChangelogUncheckedCreateWithoutAuthorInput>
  }

  export type ChangelogCreateManyAuthorInputEnvelope = {
    data: ChangelogCreateManyAuthorInput | ChangelogCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type GameSessionCreateWithoutUserInput = {
    id?: string
    gameName: string
    startTime?: Date | string
    endTime?: Date | string | null
    playtime?: number
    isActive?: boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
    game: GameCreateNestedOneWithoutSessionsInput
  }

  export type GameSessionUncheckedCreateWithoutUserInput = {
    id?: string
    gameId: string
    gameName: string
    startTime?: Date | string
    endTime?: Date | string | null
    playtime?: number
    isActive?: boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
  }

  export type GameSessionCreateOrConnectWithoutUserInput = {
    where: GameSessionWhereUniqueInput
    create: XOR<GameSessionCreateWithoutUserInput, GameSessionUncheckedCreateWithoutUserInput>
  }

  export type GameSessionCreateManyUserInputEnvelope = {
    data: GameSessionCreateManyUserInput | GameSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LibraryEntryCreateWithoutUserInput = {
    id?: string
    category?: string
    playtime?: number
    rating?: number | null
    notes?: string | null
    lastPlayed?: Date | string | null
    progress?: number
    addedAt?: Date | string
    isPublic?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    priority?: number
    game: GameCreateNestedOneWithoutLibraryEntriesInput
  }

  export type LibraryEntryUncheckedCreateWithoutUserInput = {
    id?: string
    gameId: string
    category?: string
    playtime?: number
    rating?: number | null
    notes?: string | null
    lastPlayed?: Date | string | null
    progress?: number
    addedAt?: Date | string
    isPublic?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    priority?: number
  }

  export type LibraryEntryCreateOrConnectWithoutUserInput = {
    where: LibraryEntryWhereUniqueInput
    create: XOR<LibraryEntryCreateWithoutUserInput, LibraryEntryUncheckedCreateWithoutUserInput>
  }

  export type LibraryEntryCreateManyUserInputEnvelope = {
    data: LibraryEntryCreateManyUserInput | LibraryEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type?: string
    isRead?: boolean
    isGlobal?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type?: string
    isRead?: boolean
    isGlobal?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PageVisitCreateWithoutUserInput = {
    id?: string
    page: string
    visitedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PageVisitUncheckedCreateWithoutUserInput = {
    id?: string
    page: string
    visitedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PageVisitCreateOrConnectWithoutUserInput = {
    where: PageVisitWhereUniqueInput
    create: XOR<PageVisitCreateWithoutUserInput, PageVisitUncheckedCreateWithoutUserInput>
  }

  export type PageVisitCreateManyUserInputEnvelope = {
    data: PageVisitCreateManyUserInput | PageVisitCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type session_historyCreateWithoutUsersInput = {
    id: string
    gameName: string
    startTime: Date | string
    endTime: Date | string
    playtime: number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
    createdAt?: Date | string
    games: GameCreateNestedOneWithoutSession_historyInput
  }

  export type session_historyUncheckedCreateWithoutUsersInput = {
    id: string
    gameId: string
    gameName: string
    startTime: Date | string
    endTime: Date | string
    playtime: number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type session_historyCreateOrConnectWithoutUsersInput = {
    where: session_historyWhereUniqueInput
    create: XOR<session_historyCreateWithoutUsersInput, session_historyUncheckedCreateWithoutUsersInput>
  }

  export type session_historyCreateManyUsersInputEnvelope = {
    data: session_historyCreateManyUsersInput | session_historyCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_librariesCreateWithoutUsersInput = {
    id: string
    version?: string
    totalGames?: number
    totalPlaytime?: number
    lastUpdated?: Date | string
  }

  export type user_librariesUncheckedCreateWithoutUsersInput = {
    id: string
    version?: string
    totalGames?: number
    totalPlaytime?: number
    lastUpdated?: Date | string
  }

  export type user_librariesCreateOrConnectWithoutUsersInput = {
    where: user_librariesWhereUniqueInput
    create: XOR<user_librariesCreateWithoutUsersInput, user_librariesUncheckedCreateWithoutUsersInput>
  }

  export type UserPreferencesCreateWithoutUserInput = {
    id?: string
    preferredPlatform?: string | null
    preferredStatus?: string
    includeDLCs?: boolean
    selectedDLCs?: NullableJsonNullValueInput | InputJsonValue
    selectedCampaigns?: NullableJsonNullValueInput | InputJsonValue
    preferredVersion?: string | null
    gameSpecificPrefs?: NullableJsonNullValueInput | InputJsonValue
    autoLoadHLTB?: boolean
    autoLoadMetacritic?: boolean
    autoGenerateCampaigns?: boolean
  }

  export type UserPreferencesUncheckedCreateWithoutUserInput = {
    id?: string
    preferredPlatform?: string | null
    preferredStatus?: string
    includeDLCs?: boolean
    selectedDLCs?: NullableJsonNullValueInput | InputJsonValue
    selectedCampaigns?: NullableJsonNullValueInput | InputJsonValue
    preferredVersion?: string | null
    gameSpecificPrefs?: NullableJsonNullValueInput | InputJsonValue
    autoLoadHLTB?: boolean
    autoLoadMetacritic?: boolean
    autoGenerateCampaigns?: boolean
  }

  export type UserPreferencesCreateOrConnectWithoutUserInput = {
    where: UserPreferencesWhereUniqueInput
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
  }

  export type UserStatsCreateWithoutUserInput = {
    id?: string
    totalPlayTime?: number
    totalSessions?: number
    gamesPlayed?: number
    gamesCompleted?: number
    lastPlayedGame?: string | null
    lastPlayedAt?: Date | string | null
    weeklyStats?: NullableJsonNullValueInput | InputJsonValue
    monthlyStats?: NullableJsonNullValueInput | InputJsonValue
    achievements?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserStatsUncheckedCreateWithoutUserInput = {
    id?: string
    totalPlayTime?: number
    totalSessions?: number
    gamesPlayed?: number
    gamesCompleted?: number
    lastPlayedGame?: string | null
    lastPlayedAt?: Date | string | null
    weeklyStats?: NullableJsonNullValueInput | InputJsonValue
    monthlyStats?: NullableJsonNullValueInput | InputJsonValue
    achievements?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserStatsCreateOrConnectWithoutUserInput = {
    where: UserStatsWhereUniqueInput
    create: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
  }

  export type AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    update: XOR<AdminAuditLogUpdateWithoutAdminInput, AdminAuditLogUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    data: XOR<AdminAuditLogUpdateWithoutAdminInput, AdminAuditLogUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAuditLogUpdateManyWithWhereWithoutAdminInput = {
    where: AdminAuditLogScalarWhereInput
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminAuditLogScalarWhereInput = {
    AND?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
    OR?: AdminAuditLogScalarWhereInput[]
    NOT?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
    id?: StringFilter<"AdminAuditLog"> | string
    action?: StringFilter<"AdminAuditLog"> | string
    targetType?: StringFilter<"AdminAuditLog"> | string
    targetId?: StringNullableFilter<"AdminAuditLog"> | string | null
    targetName?: StringNullableFilter<"AdminAuditLog"> | string | null
    details?: JsonNullableFilter<"AdminAuditLog">
    ipAddress?: StringNullableFilter<"AdminAuditLog"> | string | null
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    success?: BoolFilter<"AdminAuditLog"> | boolean
    errorMessage?: StringNullableFilter<"AdminAuditLog"> | string | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
    adminId?: StringFilter<"AdminAuditLog"> | string
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutUserInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutUserInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    userId?: StringNullableFilter<"ApiKey"> | string | null
    serviceName?: StringFilter<"ApiKey"> | string
    keyName?: StringFilter<"ApiKey"> | string
    keyValue?: StringFilter<"ApiKey"> | string
    isActive?: BoolFilter<"ApiKey"> | boolean
    isGlobal?: BoolFilter<"ApiKey"> | boolean
    metadata?: JsonNullableFilter<"ApiKey">
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    lastUsed?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
  }

  export type ChangelogUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ChangelogWhereUniqueInput
    update: XOR<ChangelogUpdateWithoutAuthorInput, ChangelogUncheckedUpdateWithoutAuthorInput>
    create: XOR<ChangelogCreateWithoutAuthorInput, ChangelogUncheckedCreateWithoutAuthorInput>
  }

  export type ChangelogUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ChangelogWhereUniqueInput
    data: XOR<ChangelogUpdateWithoutAuthorInput, ChangelogUncheckedUpdateWithoutAuthorInput>
  }

  export type ChangelogUpdateManyWithWhereWithoutAuthorInput = {
    where: ChangelogScalarWhereInput
    data: XOR<ChangelogUpdateManyMutationInput, ChangelogUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ChangelogScalarWhereInput = {
    AND?: ChangelogScalarWhereInput | ChangelogScalarWhereInput[]
    OR?: ChangelogScalarWhereInput[]
    NOT?: ChangelogScalarWhereInput | ChangelogScalarWhereInput[]
    id?: StringFilter<"Changelog"> | string
    title?: StringFilter<"Changelog"> | string
    content?: StringFilter<"Changelog"> | string
    version?: StringNullableFilter<"Changelog"> | string | null
    type?: StringFilter<"Changelog"> | string
    isPublished?: BoolFilter<"Changelog"> | boolean
    publishedAt?: DateTimeNullableFilter<"Changelog"> | Date | string | null
    createdAt?: DateTimeFilter<"Changelog"> | Date | string
    updatedAt?: DateTimeFilter<"Changelog"> | Date | string
    authorId?: StringFilter<"Changelog"> | string
    releaseDate?: DateTimeNullableFilter<"Changelog"> | Date | string | null
  }

  export type GameSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: GameSessionWhereUniqueInput
    update: XOR<GameSessionUpdateWithoutUserInput, GameSessionUncheckedUpdateWithoutUserInput>
    create: XOR<GameSessionCreateWithoutUserInput, GameSessionUncheckedCreateWithoutUserInput>
  }

  export type GameSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: GameSessionWhereUniqueInput
    data: XOR<GameSessionUpdateWithoutUserInput, GameSessionUncheckedUpdateWithoutUserInput>
  }

  export type GameSessionUpdateManyWithWhereWithoutUserInput = {
    where: GameSessionScalarWhereInput
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type GameSessionScalarWhereInput = {
    AND?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
    OR?: GameSessionScalarWhereInput[]
    NOT?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
    id?: StringFilter<"GameSession"> | string
    userId?: StringFilter<"GameSession"> | string
    gameId?: StringFilter<"GameSession"> | string
    gameName?: StringFilter<"GameSession"> | string
    startTime?: DateTimeFilter<"GameSession"> | Date | string
    endTime?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    playtime?: IntFilter<"GameSession"> | number
    isActive?: BoolFilter<"GameSession"> | boolean
    campaigns?: JsonNullableFilter<"GameSession">
    platform?: StringNullableFilter<"GameSession"> | string | null
    status?: StringNullableFilter<"GameSession"> | string | null
  }

  export type LibraryEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: LibraryEntryWhereUniqueInput
    update: XOR<LibraryEntryUpdateWithoutUserInput, LibraryEntryUncheckedUpdateWithoutUserInput>
    create: XOR<LibraryEntryCreateWithoutUserInput, LibraryEntryUncheckedCreateWithoutUserInput>
  }

  export type LibraryEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: LibraryEntryWhereUniqueInput
    data: XOR<LibraryEntryUpdateWithoutUserInput, LibraryEntryUncheckedUpdateWithoutUserInput>
  }

  export type LibraryEntryUpdateManyWithWhereWithoutUserInput = {
    where: LibraryEntryScalarWhereInput
    data: XOR<LibraryEntryUpdateManyMutationInput, LibraryEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type LibraryEntryScalarWhereInput = {
    AND?: LibraryEntryScalarWhereInput | LibraryEntryScalarWhereInput[]
    OR?: LibraryEntryScalarWhereInput[]
    NOT?: LibraryEntryScalarWhereInput | LibraryEntryScalarWhereInput[]
    id?: StringFilter<"LibraryEntry"> | string
    gameId?: StringFilter<"LibraryEntry"> | string
    category?: StringFilter<"LibraryEntry"> | string
    playtime?: IntFilter<"LibraryEntry"> | number
    rating?: FloatNullableFilter<"LibraryEntry"> | number | null
    notes?: StringNullableFilter<"LibraryEntry"> | string | null
    lastPlayed?: DateTimeNullableFilter<"LibraryEntry"> | Date | string | null
    progress?: IntFilter<"LibraryEntry"> | number
    addedAt?: DateTimeFilter<"LibraryEntry"> | Date | string
    isPublic?: BoolFilter<"LibraryEntry"> | boolean
    tags?: JsonNullableFilter<"LibraryEntry">
    updatedAt?: DateTimeFilter<"LibraryEntry"> | Date | string
    userId?: StringFilter<"LibraryEntry"> | string
    priority?: IntFilter<"LibraryEntry"> | number
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    isGlobal?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type PageVisitUpsertWithWhereUniqueWithoutUserInput = {
    where: PageVisitWhereUniqueInput
    update: XOR<PageVisitUpdateWithoutUserInput, PageVisitUncheckedUpdateWithoutUserInput>
    create: XOR<PageVisitCreateWithoutUserInput, PageVisitUncheckedCreateWithoutUserInput>
  }

  export type PageVisitUpdateWithWhereUniqueWithoutUserInput = {
    where: PageVisitWhereUniqueInput
    data: XOR<PageVisitUpdateWithoutUserInput, PageVisitUncheckedUpdateWithoutUserInput>
  }

  export type PageVisitUpdateManyWithWhereWithoutUserInput = {
    where: PageVisitScalarWhereInput
    data: XOR<PageVisitUpdateManyMutationInput, PageVisitUncheckedUpdateManyWithoutUserInput>
  }

  export type PageVisitScalarWhereInput = {
    AND?: PageVisitScalarWhereInput | PageVisitScalarWhereInput[]
    OR?: PageVisitScalarWhereInput[]
    NOT?: PageVisitScalarWhereInput | PageVisitScalarWhereInput[]
    id?: StringFilter<"PageVisit"> | string
    userId?: StringFilter<"PageVisit"> | string
    page?: StringFilter<"PageVisit"> | string
    visitedAt?: DateTimeFilter<"PageVisit"> | Date | string
    metadata?: JsonNullableFilter<"PageVisit">
  }

  export type session_historyUpsertWithWhereUniqueWithoutUsersInput = {
    where: session_historyWhereUniqueInput
    update: XOR<session_historyUpdateWithoutUsersInput, session_historyUncheckedUpdateWithoutUsersInput>
    create: XOR<session_historyCreateWithoutUsersInput, session_historyUncheckedCreateWithoutUsersInput>
  }

  export type session_historyUpdateWithWhereUniqueWithoutUsersInput = {
    where: session_historyWhereUniqueInput
    data: XOR<session_historyUpdateWithoutUsersInput, session_historyUncheckedUpdateWithoutUsersInput>
  }

  export type session_historyUpdateManyWithWhereWithoutUsersInput = {
    where: session_historyScalarWhereInput
    data: XOR<session_historyUpdateManyMutationInput, session_historyUncheckedUpdateManyWithoutUsersInput>
  }

  export type session_historyScalarWhereInput = {
    AND?: session_historyScalarWhereInput | session_historyScalarWhereInput[]
    OR?: session_historyScalarWhereInput[]
    NOT?: session_historyScalarWhereInput | session_historyScalarWhereInput[]
    id?: StringFilter<"session_history"> | string
    userId?: StringFilter<"session_history"> | string
    gameId?: StringFilter<"session_history"> | string
    gameName?: StringFilter<"session_history"> | string
    startTime?: DateTimeFilter<"session_history"> | Date | string
    endTime?: DateTimeFilter<"session_history"> | Date | string
    playtime?: IntFilter<"session_history"> | number
    campaigns?: JsonNullableFilter<"session_history">
    platform?: StringNullableFilter<"session_history"> | string | null
    status?: StringNullableFilter<"session_history"> | string | null
    createdAt?: DateTimeFilter<"session_history"> | Date | string
  }

  export type user_librariesUpsertWithoutUsersInput = {
    update: XOR<user_librariesUpdateWithoutUsersInput, user_librariesUncheckedUpdateWithoutUsersInput>
    create: XOR<user_librariesCreateWithoutUsersInput, user_librariesUncheckedCreateWithoutUsersInput>
    where?: user_librariesWhereInput
  }

  export type user_librariesUpdateToOneWithWhereWithoutUsersInput = {
    where?: user_librariesWhereInput
    data: XOR<user_librariesUpdateWithoutUsersInput, user_librariesUncheckedUpdateWithoutUsersInput>
  }

  export type user_librariesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    totalGames?: IntFieldUpdateOperationsInput | number
    totalPlaytime?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_librariesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    totalGames?: IntFieldUpdateOperationsInput | number
    totalPlaytime?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesUpsertWithoutUserInput = {
    update: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    where?: UserPreferencesWhereInput
  }

  export type UserPreferencesUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPreferencesWhereInput
    data: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferencesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferredPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStatus?: StringFieldUpdateOperationsInput | string
    includeDLCs?: BoolFieldUpdateOperationsInput | boolean
    selectedDLCs?: NullableJsonNullValueInput | InputJsonValue
    selectedCampaigns?: NullableJsonNullValueInput | InputJsonValue
    preferredVersion?: NullableStringFieldUpdateOperationsInput | string | null
    gameSpecificPrefs?: NullableJsonNullValueInput | InputJsonValue
    autoLoadHLTB?: BoolFieldUpdateOperationsInput | boolean
    autoLoadMetacritic?: BoolFieldUpdateOperationsInput | boolean
    autoGenerateCampaigns?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserPreferencesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferredPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStatus?: StringFieldUpdateOperationsInput | string
    includeDLCs?: BoolFieldUpdateOperationsInput | boolean
    selectedDLCs?: NullableJsonNullValueInput | InputJsonValue
    selectedCampaigns?: NullableJsonNullValueInput | InputJsonValue
    preferredVersion?: NullableStringFieldUpdateOperationsInput | string | null
    gameSpecificPrefs?: NullableJsonNullValueInput | InputJsonValue
    autoLoadHLTB?: BoolFieldUpdateOperationsInput | boolean
    autoLoadMetacritic?: BoolFieldUpdateOperationsInput | boolean
    autoGenerateCampaigns?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserStatsUpsertWithoutUserInput = {
    update: XOR<UserStatsUpdateWithoutUserInput, UserStatsUncheckedUpdateWithoutUserInput>
    create: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    where?: UserStatsWhereInput
  }

  export type UserStatsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserStatsWhereInput
    data: XOR<UserStatsUpdateWithoutUserInput, UserStatsUncheckedUpdateWithoutUserInput>
  }

  export type UserStatsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPlayTime?: IntFieldUpdateOperationsInput | number
    totalSessions?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesCompleted?: IntFieldUpdateOperationsInput | number
    lastPlayedGame?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weeklyStats?: NullableJsonNullValueInput | InputJsonValue
    monthlyStats?: NullableJsonNullValueInput | InputJsonValue
    achievements?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserStatsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPlayTime?: IntFieldUpdateOperationsInput | number
    totalSessions?: IntFieldUpdateOperationsInput | number
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    gamesCompleted?: IntFieldUpdateOperationsInput | number
    lastPlayedGame?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weeklyStats?: NullableJsonNullValueInput | InputJsonValue
    monthlyStats?: NullableJsonNullValueInput | InputJsonValue
    achievements?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserCreateWithoutApiKeysInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    changelogs?: ChangelogCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitCreateNestedManyWithoutUserInput
    session_history?: session_historyCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApiKeysInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    changelogs?: ChangelogUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitUncheckedCreateNestedManyWithoutUserInput
    session_history?: session_historyUncheckedCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesUncheckedCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApiKeysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
  }

  export type UserUpsertWithoutApiKeysInput = {
    update: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    changelogs?: ChangelogUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUpdateManyWithoutUserNestedInput
    session_history?: session_historyUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    changelogs?: ChangelogUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUncheckedUpdateManyWithoutUserNestedInput
    session_history?: session_historyUncheckedUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUncheckedUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CampaignCreateWithoutGameInput = {
    id?: string
    name: string
    description?: string | null
    averageDuration?: string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    isAutoGenerated?: boolean
    isMainCampaign?: boolean
    difficulty?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    parent?: CampaignCreateNestedOneWithoutChildrenInput
    children?: CampaignCreateNestedManyWithoutParentInput
  }

  export type CampaignUncheckedCreateWithoutGameInput = {
    id?: string
    name: string
    description?: string | null
    averageDuration?: string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    parentId?: string | null
    isAutoGenerated?: boolean
    isMainCampaign?: boolean
    difficulty?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    children?: CampaignUncheckedCreateNestedManyWithoutParentInput
  }

  export type CampaignCreateOrConnectWithoutGameInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutGameInput, CampaignUncheckedCreateWithoutGameInput>
  }

  export type CampaignCreateManyGameInputEnvelope = {
    data: CampaignCreateManyGameInput | CampaignCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type GameSessionCreateWithoutGameInput = {
    id?: string
    gameName: string
    startTime?: Date | string
    endTime?: Date | string | null
    playtime?: number
    isActive?: boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type GameSessionUncheckedCreateWithoutGameInput = {
    id?: string
    userId: string
    gameName: string
    startTime?: Date | string
    endTime?: Date | string | null
    playtime?: number
    isActive?: boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
  }

  export type GameSessionCreateOrConnectWithoutGameInput = {
    where: GameSessionWhereUniqueInput
    create: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput>
  }

  export type GameSessionCreateManyGameInputEnvelope = {
    data: GameSessionCreateManyGameInput | GameSessionCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type LibraryEntryCreateWithoutGameInput = {
    id?: string
    category?: string
    playtime?: number
    rating?: number | null
    notes?: string | null
    lastPlayed?: Date | string | null
    progress?: number
    addedAt?: Date | string
    isPublic?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    priority?: number
    user: UserCreateNestedOneWithoutLibraryEntriesInput
  }

  export type LibraryEntryUncheckedCreateWithoutGameInput = {
    id?: string
    category?: string
    playtime?: number
    rating?: number | null
    notes?: string | null
    lastPlayed?: Date | string | null
    progress?: number
    addedAt?: Date | string
    isPublic?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    userId: string
    priority?: number
  }

  export type LibraryEntryCreateOrConnectWithoutGameInput = {
    where: LibraryEntryWhereUniqueInput
    create: XOR<LibraryEntryCreateWithoutGameInput, LibraryEntryUncheckedCreateWithoutGameInput>
  }

  export type LibraryEntryCreateManyGameInputEnvelope = {
    data: LibraryEntryCreateManyGameInput | LibraryEntryCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type session_historyCreateWithoutGamesInput = {
    id: string
    gameName: string
    startTime: Date | string
    endTime: Date | string
    playtime: number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
    createdAt?: Date | string
    users: UserCreateNestedOneWithoutSession_historyInput
  }

  export type session_historyUncheckedCreateWithoutGamesInput = {
    id: string
    userId: string
    gameName: string
    startTime: Date | string
    endTime: Date | string
    playtime: number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type session_historyCreateOrConnectWithoutGamesInput = {
    where: session_historyWhereUniqueInput
    create: XOR<session_historyCreateWithoutGamesInput, session_historyUncheckedCreateWithoutGamesInput>
  }

  export type session_historyCreateManyGamesInputEnvelope = {
    data: session_historyCreateManyGamesInput | session_historyCreateManyGamesInput[]
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithWhereUniqueWithoutGameInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutGameInput, CampaignUncheckedUpdateWithoutGameInput>
    create: XOR<CampaignCreateWithoutGameInput, CampaignUncheckedCreateWithoutGameInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutGameInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutGameInput, CampaignUncheckedUpdateWithoutGameInput>
  }

  export type CampaignUpdateManyWithWhereWithoutGameInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutGameInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    gameId?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    averageDuration?: StringNullableFilter<"Campaign"> | string | null
    customProperties?: JsonNullableFilter<"Campaign">
    parentId?: StringNullableFilter<"Campaign"> | string | null
    isAutoGenerated?: BoolFilter<"Campaign"> | boolean
    isMainCampaign?: BoolFilter<"Campaign"> | boolean
    difficulty?: StringNullableFilter<"Campaign"> | string | null
    features?: JsonNullableFilter<"Campaign">
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
  }

  export type GameSessionUpsertWithWhereUniqueWithoutGameInput = {
    where: GameSessionWhereUniqueInput
    update: XOR<GameSessionUpdateWithoutGameInput, GameSessionUncheckedUpdateWithoutGameInput>
    create: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput>
  }

  export type GameSessionUpdateWithWhereUniqueWithoutGameInput = {
    where: GameSessionWhereUniqueInput
    data: XOR<GameSessionUpdateWithoutGameInput, GameSessionUncheckedUpdateWithoutGameInput>
  }

  export type GameSessionUpdateManyWithWhereWithoutGameInput = {
    where: GameSessionScalarWhereInput
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyWithoutGameInput>
  }

  export type LibraryEntryUpsertWithWhereUniqueWithoutGameInput = {
    where: LibraryEntryWhereUniqueInput
    update: XOR<LibraryEntryUpdateWithoutGameInput, LibraryEntryUncheckedUpdateWithoutGameInput>
    create: XOR<LibraryEntryCreateWithoutGameInput, LibraryEntryUncheckedCreateWithoutGameInput>
  }

  export type LibraryEntryUpdateWithWhereUniqueWithoutGameInput = {
    where: LibraryEntryWhereUniqueInput
    data: XOR<LibraryEntryUpdateWithoutGameInput, LibraryEntryUncheckedUpdateWithoutGameInput>
  }

  export type LibraryEntryUpdateManyWithWhereWithoutGameInput = {
    where: LibraryEntryScalarWhereInput
    data: XOR<LibraryEntryUpdateManyMutationInput, LibraryEntryUncheckedUpdateManyWithoutGameInput>
  }

  export type session_historyUpsertWithWhereUniqueWithoutGamesInput = {
    where: session_historyWhereUniqueInput
    update: XOR<session_historyUpdateWithoutGamesInput, session_historyUncheckedUpdateWithoutGamesInput>
    create: XOR<session_historyCreateWithoutGamesInput, session_historyUncheckedCreateWithoutGamesInput>
  }

  export type session_historyUpdateWithWhereUniqueWithoutGamesInput = {
    where: session_historyWhereUniqueInput
    data: XOR<session_historyUpdateWithoutGamesInput, session_historyUncheckedUpdateWithoutGamesInput>
  }

  export type session_historyUpdateManyWithWhereWithoutGamesInput = {
    where: session_historyScalarWhereInput
    data: XOR<session_historyUpdateManyMutationInput, session_historyUncheckedUpdateManyWithoutGamesInput>
  }

  export type GameCreateWithoutLibraryEntriesInput = {
    id: string
    name: string
    cover?: string | null
    firstReleaseDate?: Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: string | null
    rating?: number | null
    developer?: string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: Date | string
    lastAccessed?: Date | string
    accessCount?: number
    coverKey?: string | null
    campaigns?: CampaignCreateNestedManyWithoutGameInput
    sessions?: GameSessionCreateNestedManyWithoutGameInput
    session_history?: session_historyCreateNestedManyWithoutGamesInput
  }

  export type GameUncheckedCreateWithoutLibraryEntriesInput = {
    id: string
    name: string
    cover?: string | null
    firstReleaseDate?: Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: string | null
    rating?: number | null
    developer?: string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: Date | string
    lastAccessed?: Date | string
    accessCount?: number
    coverKey?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutGameInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    session_history?: session_historyUncheckedCreateNestedManyWithoutGamesInput
  }

  export type GameCreateOrConnectWithoutLibraryEntriesInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutLibraryEntriesInput, GameUncheckedCreateWithoutLibraryEntriesInput>
  }

  export type UserCreateWithoutLibraryEntriesInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    changelogs?: ChangelogCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitCreateNestedManyWithoutUserInput
    session_history?: session_historyCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLibraryEntriesInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    changelogs?: ChangelogUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitUncheckedCreateNestedManyWithoutUserInput
    session_history?: session_historyUncheckedCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesUncheckedCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLibraryEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLibraryEntriesInput, UserUncheckedCreateWithoutLibraryEntriesInput>
  }

  export type GameUpsertWithoutLibraryEntriesInput = {
    update: XOR<GameUpdateWithoutLibraryEntriesInput, GameUncheckedUpdateWithoutLibraryEntriesInput>
    create: XOR<GameCreateWithoutLibraryEntriesInput, GameUncheckedCreateWithoutLibraryEntriesInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutLibraryEntriesInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutLibraryEntriesInput, GameUncheckedUpdateWithoutLibraryEntriesInput>
  }

  export type GameUpdateWithoutLibraryEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    firstReleaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCount?: IntFieldUpdateOperationsInput | number
    coverKey?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUpdateManyWithoutGameNestedInput
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
    session_history?: session_historyUpdateManyWithoutGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutLibraryEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    firstReleaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCount?: IntFieldUpdateOperationsInput | number
    coverKey?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutGameNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    session_history?: session_historyUncheckedUpdateManyWithoutGamesNestedInput
  }

  export type UserUpsertWithoutLibraryEntriesInput = {
    update: XOR<UserUpdateWithoutLibraryEntriesInput, UserUncheckedUpdateWithoutLibraryEntriesInput>
    create: XOR<UserCreateWithoutLibraryEntriesInput, UserUncheckedCreateWithoutLibraryEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLibraryEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLibraryEntriesInput, UserUncheckedUpdateWithoutLibraryEntriesInput>
  }

  export type UserUpdateWithoutLibraryEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUpdateManyWithoutUserNestedInput
    session_history?: session_historyUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLibraryEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUncheckedUpdateManyWithoutUserNestedInput
    session_history?: session_historyUncheckedUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUncheckedUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutPreferencesInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    changelogs?: ChangelogCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitCreateNestedManyWithoutUserInput
    session_history?: session_historyCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesCreateNestedOneWithoutUsersInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPreferencesInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    changelogs?: ChangelogUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitUncheckedCreateNestedManyWithoutUserInput
    session_history?: session_historyUncheckedCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesUncheckedCreateNestedOneWithoutUsersInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
  }

  export type UserUpsertWithoutPreferencesInput = {
    update: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUpdateManyWithoutUserNestedInput
    session_history?: session_historyUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUpdateOneWithoutUsersNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUncheckedUpdateManyWithoutUserNestedInput
    session_history?: session_historyUncheckedUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUncheckedUpdateOneWithoutUsersNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type GameCreateWithoutSessionsInput = {
    id: string
    name: string
    cover?: string | null
    firstReleaseDate?: Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: string | null
    rating?: number | null
    developer?: string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: Date | string
    lastAccessed?: Date | string
    accessCount?: number
    coverKey?: string | null
    campaigns?: CampaignCreateNestedManyWithoutGameInput
    libraryEntries?: LibraryEntryCreateNestedManyWithoutGameInput
    session_history?: session_historyCreateNestedManyWithoutGamesInput
  }

  export type GameUncheckedCreateWithoutSessionsInput = {
    id: string
    name: string
    cover?: string | null
    firstReleaseDate?: Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: string | null
    rating?: number | null
    developer?: string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: Date | string
    lastAccessed?: Date | string
    accessCount?: number
    coverKey?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutGameInput
    libraryEntries?: LibraryEntryUncheckedCreateNestedManyWithoutGameInput
    session_history?: session_historyUncheckedCreateNestedManyWithoutGamesInput
  }

  export type GameCreateOrConnectWithoutSessionsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutSessionsInput, GameUncheckedCreateWithoutSessionsInput>
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    changelogs?: ChangelogCreateNestedManyWithoutAuthorInput
    libraryEntries?: LibraryEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitCreateNestedManyWithoutUserInput
    session_history?: session_historyCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    changelogs?: ChangelogUncheckedCreateNestedManyWithoutAuthorInput
    libraryEntries?: LibraryEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitUncheckedCreateNestedManyWithoutUserInput
    session_history?: session_historyUncheckedCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesUncheckedCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type GameUpsertWithoutSessionsInput = {
    update: XOR<GameUpdateWithoutSessionsInput, GameUncheckedUpdateWithoutSessionsInput>
    create: XOR<GameCreateWithoutSessionsInput, GameUncheckedCreateWithoutSessionsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutSessionsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutSessionsInput, GameUncheckedUpdateWithoutSessionsInput>
  }

  export type GameUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    firstReleaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCount?: IntFieldUpdateOperationsInput | number
    coverKey?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUpdateManyWithoutGameNestedInput
    libraryEntries?: LibraryEntryUpdateManyWithoutGameNestedInput
    session_history?: session_historyUpdateManyWithoutGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    firstReleaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCount?: IntFieldUpdateOperationsInput | number
    coverKey?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutGameNestedInput
    libraryEntries?: LibraryEntryUncheckedUpdateManyWithoutGameNestedInput
    session_history?: session_historyUncheckedUpdateManyWithoutGamesNestedInput
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUpdateManyWithoutAuthorNestedInput
    libraryEntries?: LibraryEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUpdateManyWithoutUserNestedInput
    session_history?: session_historyUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUncheckedUpdateManyWithoutAuthorNestedInput
    libraryEntries?: LibraryEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUncheckedUpdateManyWithoutUserNestedInput
    session_history?: session_historyUncheckedUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUncheckedUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutUserStatsInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    changelogs?: ChangelogCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitCreateNestedManyWithoutUserInput
    session_history?: session_historyCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserStatsInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    changelogs?: ChangelogUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitUncheckedCreateNestedManyWithoutUserInput
    session_history?: session_historyUncheckedCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesUncheckedCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserStatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserStatsInput, UserUncheckedCreateWithoutUserStatsInput>
  }

  export type UserUpsertWithoutUserStatsInput = {
    update: XOR<UserUpdateWithoutUserStatsInput, UserUncheckedUpdateWithoutUserStatsInput>
    create: XOR<UserCreateWithoutUserStatsInput, UserUncheckedCreateWithoutUserStatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserStatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserStatsInput, UserUncheckedUpdateWithoutUserStatsInput>
  }

  export type UserUpdateWithoutUserStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUpdateManyWithoutUserNestedInput
    session_history?: session_historyUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUncheckedUpdateManyWithoutUserNestedInput
    session_history?: session_historyUncheckedUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUncheckedUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
  }

  export type GameCreateWithoutCampaignsInput = {
    id: string
    name: string
    cover?: string | null
    firstReleaseDate?: Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: string | null
    rating?: number | null
    developer?: string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: Date | string
    lastAccessed?: Date | string
    accessCount?: number
    coverKey?: string | null
    sessions?: GameSessionCreateNestedManyWithoutGameInput
    libraryEntries?: LibraryEntryCreateNestedManyWithoutGameInput
    session_history?: session_historyCreateNestedManyWithoutGamesInput
  }

  export type GameUncheckedCreateWithoutCampaignsInput = {
    id: string
    name: string
    cover?: string | null
    firstReleaseDate?: Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: string | null
    rating?: number | null
    developer?: string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: Date | string
    lastAccessed?: Date | string
    accessCount?: number
    coverKey?: string | null
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    libraryEntries?: LibraryEntryUncheckedCreateNestedManyWithoutGameInput
    session_history?: session_historyUncheckedCreateNestedManyWithoutGamesInput
  }

  export type GameCreateOrConnectWithoutCampaignsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutCampaignsInput, GameUncheckedCreateWithoutCampaignsInput>
  }

  export type CampaignCreateWithoutChildrenInput = {
    id?: string
    name: string
    description?: string | null
    averageDuration?: string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    isAutoGenerated?: boolean
    isMainCampaign?: boolean
    difficulty?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    game: GameCreateNestedOneWithoutCampaignsInput
    parent?: CampaignCreateNestedOneWithoutChildrenInput
  }

  export type CampaignUncheckedCreateWithoutChildrenInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    averageDuration?: string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    parentId?: string | null
    isAutoGenerated?: boolean
    isMainCampaign?: boolean
    difficulty?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CampaignCreateOrConnectWithoutChildrenInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutChildrenInput, CampaignUncheckedCreateWithoutChildrenInput>
  }

  export type CampaignCreateWithoutParentInput = {
    id?: string
    name: string
    description?: string | null
    averageDuration?: string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    isAutoGenerated?: boolean
    isMainCampaign?: boolean
    difficulty?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    game: GameCreateNestedOneWithoutCampaignsInput
    children?: CampaignCreateNestedManyWithoutParentInput
  }

  export type CampaignUncheckedCreateWithoutParentInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    averageDuration?: string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    isAutoGenerated?: boolean
    isMainCampaign?: boolean
    difficulty?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    children?: CampaignUncheckedCreateNestedManyWithoutParentInput
  }

  export type CampaignCreateOrConnectWithoutParentInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutParentInput, CampaignUncheckedCreateWithoutParentInput>
  }

  export type CampaignCreateManyParentInputEnvelope = {
    data: CampaignCreateManyParentInput | CampaignCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type GameUpsertWithoutCampaignsInput = {
    update: XOR<GameUpdateWithoutCampaignsInput, GameUncheckedUpdateWithoutCampaignsInput>
    create: XOR<GameCreateWithoutCampaignsInput, GameUncheckedCreateWithoutCampaignsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutCampaignsInput, GameUncheckedUpdateWithoutCampaignsInput>
  }

  export type GameUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    firstReleaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCount?: IntFieldUpdateOperationsInput | number
    coverKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
    libraryEntries?: LibraryEntryUpdateManyWithoutGameNestedInput
    session_history?: session_historyUpdateManyWithoutGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    firstReleaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCount?: IntFieldUpdateOperationsInput | number
    coverKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    libraryEntries?: LibraryEntryUncheckedUpdateManyWithoutGameNestedInput
    session_history?: session_historyUncheckedUpdateManyWithoutGamesNestedInput
  }

  export type CampaignUpsertWithoutChildrenInput = {
    update: XOR<CampaignUpdateWithoutChildrenInput, CampaignUncheckedUpdateWithoutChildrenInput>
    create: XOR<CampaignCreateWithoutChildrenInput, CampaignUncheckedCreateWithoutChildrenInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutChildrenInput, CampaignUncheckedUpdateWithoutChildrenInput>
  }

  export type CampaignUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    averageDuration?: NullableStringFieldUpdateOperationsInput | string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    isMainCampaign?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutCampaignsNestedInput
    parent?: CampaignUpdateOneWithoutChildrenNestedInput
  }

  export type CampaignUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    averageDuration?: NullableStringFieldUpdateOperationsInput | string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    isMainCampaign?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpsertWithWhereUniqueWithoutParentInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutParentInput, CampaignUncheckedUpdateWithoutParentInput>
    create: XOR<CampaignCreateWithoutParentInput, CampaignUncheckedCreateWithoutParentInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutParentInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutParentInput, CampaignUncheckedUpdateWithoutParentInput>
  }

  export type CampaignUpdateManyWithWhereWithoutParentInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutParentInput>
  }

  export type UserCreateWithoutPageVisitsInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    changelogs?: ChangelogCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    session_history?: session_historyCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPageVisitsInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    changelogs?: ChangelogUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    session_history?: session_historyUncheckedCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesUncheckedCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPageVisitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPageVisitsInput, UserUncheckedCreateWithoutPageVisitsInput>
  }

  export type UserUpsertWithoutPageVisitsInput = {
    update: XOR<UserUpdateWithoutPageVisitsInput, UserUncheckedUpdateWithoutPageVisitsInput>
    create: XOR<UserCreateWithoutPageVisitsInput, UserUncheckedCreateWithoutPageVisitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPageVisitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPageVisitsInput, UserUncheckedUpdateWithoutPageVisitsInput>
  }

  export type UserUpdateWithoutPageVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    session_history?: session_historyUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPageVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    session_history?: session_historyUncheckedUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUncheckedUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    changelogs?: ChangelogCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitCreateNestedManyWithoutUserInput
    session_history?: session_historyCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    changelogs?: ChangelogUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryUncheckedCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitUncheckedCreateNestedManyWithoutUserInput
    session_history?: session_historyUncheckedCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesUncheckedCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUpdateManyWithoutUserNestedInput
    session_history?: session_historyUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUncheckedUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUncheckedUpdateManyWithoutUserNestedInput
    session_history?: session_historyUncheckedUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUncheckedUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SystemUpdateStepCreateWithoutUpdateInput = {
    id?: string
    title: string
    description?: string | null
    progress?: number
    status?: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemUpdateStepUncheckedCreateWithoutUpdateInput = {
    id?: string
    title: string
    description?: string | null
    progress?: number
    status?: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemUpdateStepCreateOrConnectWithoutUpdateInput = {
    where: SystemUpdateStepWhereUniqueInput
    create: XOR<SystemUpdateStepCreateWithoutUpdateInput, SystemUpdateStepUncheckedCreateWithoutUpdateInput>
  }

  export type SystemUpdateStepCreateManyUpdateInputEnvelope = {
    data: SystemUpdateStepCreateManyUpdateInput | SystemUpdateStepCreateManyUpdateInput[]
    skipDuplicates?: boolean
  }

  export type SystemUpdateStepUpsertWithWhereUniqueWithoutUpdateInput = {
    where: SystemUpdateStepWhereUniqueInput
    update: XOR<SystemUpdateStepUpdateWithoutUpdateInput, SystemUpdateStepUncheckedUpdateWithoutUpdateInput>
    create: XOR<SystemUpdateStepCreateWithoutUpdateInput, SystemUpdateStepUncheckedCreateWithoutUpdateInput>
  }

  export type SystemUpdateStepUpdateWithWhereUniqueWithoutUpdateInput = {
    where: SystemUpdateStepWhereUniqueInput
    data: XOR<SystemUpdateStepUpdateWithoutUpdateInput, SystemUpdateStepUncheckedUpdateWithoutUpdateInput>
  }

  export type SystemUpdateStepUpdateManyWithWhereWithoutUpdateInput = {
    where: SystemUpdateStepScalarWhereInput
    data: XOR<SystemUpdateStepUpdateManyMutationInput, SystemUpdateStepUncheckedUpdateManyWithoutUpdateInput>
  }

  export type SystemUpdateStepScalarWhereInput = {
    AND?: SystemUpdateStepScalarWhereInput | SystemUpdateStepScalarWhereInput[]
    OR?: SystemUpdateStepScalarWhereInput[]
    NOT?: SystemUpdateStepScalarWhereInput | SystemUpdateStepScalarWhereInput[]
    id?: StringFilter<"SystemUpdateStep"> | string
    updateId?: StringFilter<"SystemUpdateStep"> | string
    title?: StringFilter<"SystemUpdateStep"> | string
    description?: StringNullableFilter<"SystemUpdateStep"> | string | null
    progress?: IntFilter<"SystemUpdateStep"> | number
    status?: StringFilter<"SystemUpdateStep"> | string
    order?: IntFilter<"SystemUpdateStep"> | number
    createdAt?: DateTimeFilter<"SystemUpdateStep"> | Date | string
    updatedAt?: DateTimeFilter<"SystemUpdateStep"> | Date | string
    completedAt?: DateTimeNullableFilter<"SystemUpdateStep"> | Date | string | null
  }

  export type SystemUpdateCreateWithoutSubstepsInput = {
    id?: string
    title: string
    description: string
    version?: string | null
    type?: string
    status?: string
    progress?: number
    priority?: string
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemUpdateUncheckedCreateWithoutSubstepsInput = {
    id?: string
    title: string
    description: string
    version?: string | null
    type?: string
    status?: string
    progress?: number
    priority?: string
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemUpdateCreateOrConnectWithoutSubstepsInput = {
    where: SystemUpdateWhereUniqueInput
    create: XOR<SystemUpdateCreateWithoutSubstepsInput, SystemUpdateUncheckedCreateWithoutSubstepsInput>
  }

  export type SystemUpdateUpsertWithoutSubstepsInput = {
    update: XOR<SystemUpdateUpdateWithoutSubstepsInput, SystemUpdateUncheckedUpdateWithoutSubstepsInput>
    create: XOR<SystemUpdateCreateWithoutSubstepsInput, SystemUpdateUncheckedCreateWithoutSubstepsInput>
    where?: SystemUpdateWhereInput
  }

  export type SystemUpdateUpdateToOneWithWhereWithoutSubstepsInput = {
    where?: SystemUpdateWhereInput
    data: XOR<SystemUpdateUpdateWithoutSubstepsInput, SystemUpdateUncheckedUpdateWithoutSubstepsInput>
  }

  export type SystemUpdateUpdateWithoutSubstepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemUpdateUncheckedUpdateWithoutSubstepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutChangelogsInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    sessions?: GameSessionCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitCreateNestedManyWithoutUserInput
    session_history?: session_historyCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChangelogsInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitUncheckedCreateNestedManyWithoutUserInput
    session_history?: session_historyUncheckedCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesUncheckedCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChangelogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChangelogsInput, UserUncheckedCreateWithoutChangelogsInput>
  }

  export type UserUpsertWithoutChangelogsInput = {
    update: XOR<UserUpdateWithoutChangelogsInput, UserUncheckedUpdateWithoutChangelogsInput>
    create: XOR<UserCreateWithoutChangelogsInput, UserUncheckedCreateWithoutChangelogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChangelogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChangelogsInput, UserUncheckedUpdateWithoutChangelogsInput>
  }

  export type UserUpdateWithoutChangelogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    sessions?: GameSessionUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUpdateManyWithoutUserNestedInput
    session_history?: session_historyUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChangelogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUncheckedUpdateManyWithoutUserNestedInput
    session_history?: session_historyUncheckedUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUncheckedUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAdminAuditLogsInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    changelogs?: ChangelogCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitCreateNestedManyWithoutUserInput
    session_history?: session_historyCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminAuditLogsInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    changelogs?: ChangelogUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitUncheckedCreateNestedManyWithoutUserInput
    session_history?: session_historyUncheckedCreateNestedManyWithoutUsersInput
    user_libraries?: user_librariesUncheckedCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminAuditLogsInput, UserUncheckedCreateWithoutAdminAuditLogsInput>
  }

  export type UserUpsertWithoutAdminAuditLogsInput = {
    update: XOR<UserUpdateWithoutAdminAuditLogsInput, UserUncheckedUpdateWithoutAdminAuditLogsInput>
    create: XOR<UserCreateWithoutAdminAuditLogsInput, UserUncheckedCreateWithoutAdminAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminAuditLogsInput, UserUncheckedUpdateWithoutAdminAuditLogsInput>
  }

  export type UserUpdateWithoutAdminAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUpdateManyWithoutUserNestedInput
    session_history?: session_historyUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUncheckedUpdateManyWithoutUserNestedInput
    session_history?: session_historyUncheckedUpdateManyWithoutUsersNestedInput
    user_libraries?: user_librariesUncheckedUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type GameCreateWithoutSession_historyInput = {
    id: string
    name: string
    cover?: string | null
    firstReleaseDate?: Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: string | null
    rating?: number | null
    developer?: string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: Date | string
    lastAccessed?: Date | string
    accessCount?: number
    coverKey?: string | null
    campaigns?: CampaignCreateNestedManyWithoutGameInput
    sessions?: GameSessionCreateNestedManyWithoutGameInput
    libraryEntries?: LibraryEntryCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutSession_historyInput = {
    id: string
    name: string
    cover?: string | null
    firstReleaseDate?: Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: string | null
    rating?: number | null
    developer?: string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: Date | string
    lastAccessed?: Date | string
    accessCount?: number
    coverKey?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutGameInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    libraryEntries?: LibraryEntryUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutSession_historyInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutSession_historyInput, GameUncheckedCreateWithoutSession_historyInput>
  }

  export type UserCreateWithoutSession_historyInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    changelogs?: ChangelogCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitCreateNestedManyWithoutUserInput
    user_libraries?: user_librariesCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSession_historyInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    changelogs?: ChangelogUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitUncheckedCreateNestedManyWithoutUserInput
    user_libraries?: user_librariesUncheckedCreateNestedOneWithoutUsersInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSession_historyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSession_historyInput, UserUncheckedCreateWithoutSession_historyInput>
  }

  export type GameUpsertWithoutSession_historyInput = {
    update: XOR<GameUpdateWithoutSession_historyInput, GameUncheckedUpdateWithoutSession_historyInput>
    create: XOR<GameCreateWithoutSession_historyInput, GameUncheckedCreateWithoutSession_historyInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutSession_historyInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutSession_historyInput, GameUncheckedUpdateWithoutSession_historyInput>
  }

  export type GameUpdateWithoutSession_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    firstReleaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCount?: IntFieldUpdateOperationsInput | number
    coverKey?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUpdateManyWithoutGameNestedInput
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
    libraryEntries?: LibraryEntryUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutSession_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    firstReleaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genres?: NullableJsonNullValueInput | InputJsonValue
    platforms?: NullableJsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developers?: NullableJsonNullValueInput | InputJsonValue
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishers?: NullableJsonNullValueInput | InputJsonValue
    steamData?: NullableJsonNullValueInput | InputJsonValue
    igdbData?: NullableJsonNullValueInput | InputJsonValue
    hltbData?: NullableJsonNullValueInput | InputJsonValue
    metacriticData?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCount?: IntFieldUpdateOperationsInput | number
    coverKey?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutGameNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    libraryEntries?: LibraryEntryUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserUpsertWithoutSession_historyInput = {
    update: XOR<UserUpdateWithoutSession_historyInput, UserUncheckedUpdateWithoutSession_historyInput>
    create: XOR<UserCreateWithoutSession_historyInput, UserUncheckedCreateWithoutSession_historyInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSession_historyInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSession_historyInput, UserUncheckedUpdateWithoutSession_historyInput>
  }

  export type UserUpdateWithoutSession_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUpdateManyWithoutUserNestedInput
    user_libraries?: user_librariesUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSession_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUncheckedUpdateManyWithoutUserNestedInput
    user_libraries?: user_librariesUncheckedUpdateOneWithoutUsersNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutUser_librariesInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    changelogs?: ChangelogCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitCreateNestedManyWithoutUserInput
    session_history?: session_historyCreateNestedManyWithoutUsersInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_librariesInput = {
    id?: string
    name: string
    email?: string | null
    username?: string | null
    createdAt?: Date | string
    lastActive?: Date | string
    role?: string
    updatedAt?: Date | string
    password?: string | null
    profileImage?: string | null
    profileImageKey?: string | null
    status?: string
    adminAuditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    changelogs?: ChangelogUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: GameSessionUncheckedCreateNestedManyWithoutUserInput
    libraryEntries?: LibraryEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pageVisits?: PageVisitUncheckedCreateNestedManyWithoutUserInput
    session_history?: session_historyUncheckedCreateNestedManyWithoutUsersInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_librariesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_librariesInput, UserUncheckedCreateWithoutUser_librariesInput>
  }

  export type UserUpsertWithoutUser_librariesInput = {
    update: XOR<UserUpdateWithoutUser_librariesInput, UserUncheckedUpdateWithoutUser_librariesInput>
    create: XOR<UserCreateWithoutUser_librariesInput, UserUncheckedCreateWithoutUser_librariesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_librariesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_librariesInput, UserUncheckedUpdateWithoutUser_librariesInput>
  }

  export type UserUpdateWithoutUser_librariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUpdateManyWithoutUserNestedInput
    session_history?: session_historyUpdateManyWithoutUsersNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_librariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminAuditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    changelogs?: ChangelogUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: GameSessionUncheckedUpdateManyWithoutUserNestedInput
    libraryEntries?: LibraryEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pageVisits?: PageVisitUncheckedUpdateManyWithoutUserNestedInput
    session_history?: session_historyUncheckedUpdateManyWithoutUsersNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AdminAuditLogCreateManyAdminInput = {
    id?: string
    action: string
    targetType: string
    targetId?: string | null
    targetName?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type ApiKeyCreateManyUserInput = {
    id?: string
    serviceName: string
    keyName: string
    keyValue: string
    isActive?: boolean
    isGlobal?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsed?: Date | string | null
  }

  export type ChangelogCreateManyAuthorInput = {
    id?: string
    title: string
    content: string
    version?: string | null
    type?: string
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    releaseDate?: Date | string | null
  }

  export type GameSessionCreateManyUserInput = {
    id?: string
    gameId: string
    gameName: string
    startTime?: Date | string
    endTime?: Date | string | null
    playtime?: number
    isActive?: boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
  }

  export type LibraryEntryCreateManyUserInput = {
    id?: string
    gameId: string
    category?: string
    playtime?: number
    rating?: number | null
    notes?: string | null
    lastPlayed?: Date | string | null
    progress?: number
    addedAt?: Date | string
    isPublic?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    priority?: number
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type?: string
    isRead?: boolean
    isGlobal?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PageVisitCreateManyUserInput = {
    id?: string
    page: string
    visitedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type session_historyCreateManyUsersInput = {
    id: string
    gameId: string
    gameName: string
    startTime: Date | string
    endTime: Date | string
    playtime: number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    keyValue?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    keyValue?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    keyValue?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangelogUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangelogUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangelogUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playtime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    game?: GameUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type GameSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playtime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GameSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playtime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LibraryEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    playtime?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: IntFieldUpdateOperationsInput | number
    game?: GameUpdateOneRequiredWithoutLibraryEntriesNestedInput
  }

  export type LibraryEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    playtime?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    playtime?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PageVisitUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PageVisitUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PageVisitUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type session_historyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    playtime?: IntFieldUpdateOperationsInput | number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameUpdateOneRequiredWithoutSession_historyNestedInput
  }

  export type session_historyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    playtime?: IntFieldUpdateOperationsInput | number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type session_historyUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    playtime?: IntFieldUpdateOperationsInput | number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManyGameInput = {
    id?: string
    name: string
    description?: string | null
    averageDuration?: string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    parentId?: string | null
    isAutoGenerated?: boolean
    isMainCampaign?: boolean
    difficulty?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GameSessionCreateManyGameInput = {
    id?: string
    userId: string
    gameName: string
    startTime?: Date | string
    endTime?: Date | string | null
    playtime?: number
    isActive?: boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
  }

  export type LibraryEntryCreateManyGameInput = {
    id?: string
    category?: string
    playtime?: number
    rating?: number | null
    notes?: string | null
    lastPlayed?: Date | string | null
    progress?: number
    addedAt?: Date | string
    isPublic?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    userId: string
    priority?: number
  }

  export type session_historyCreateManyGamesInput = {
    id: string
    userId: string
    gameName: string
    startTime: Date | string
    endTime: Date | string
    playtime: number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type CampaignUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    averageDuration?: NullableStringFieldUpdateOperationsInput | string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    isMainCampaign?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CampaignUpdateOneWithoutChildrenNestedInput
    children?: CampaignUpdateManyWithoutParentNestedInput
  }

  export type CampaignUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    averageDuration?: NullableStringFieldUpdateOperationsInput | string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    isMainCampaign?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CampaignUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    averageDuration?: NullableStringFieldUpdateOperationsInput | string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    isMainCampaign?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playtime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type GameSessionUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playtime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GameSessionUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playtime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LibraryEntryUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    playtime?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutLibraryEntriesNestedInput
  }

  export type LibraryEntryUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    playtime?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryEntryUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    playtime?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type session_historyUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    playtime?: IntFieldUpdateOperationsInput | number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneRequiredWithoutSession_historyNestedInput
  }

  export type session_historyUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    playtime?: IntFieldUpdateOperationsInput | number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type session_historyUncheckedUpdateManyWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameName?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    playtime?: IntFieldUpdateOperationsInput | number
    campaigns?: NullableJsonNullValueInput | InputJsonValue
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManyParentInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    averageDuration?: string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    isAutoGenerated?: boolean
    isMainCampaign?: boolean
    difficulty?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CampaignUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    averageDuration?: NullableStringFieldUpdateOperationsInput | string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    isMainCampaign?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutCampaignsNestedInput
    children?: CampaignUpdateManyWithoutParentNestedInput
  }

  export type CampaignUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    averageDuration?: NullableStringFieldUpdateOperationsInput | string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    isMainCampaign?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CampaignUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    averageDuration?: NullableStringFieldUpdateOperationsInput | string | null
    customProperties?: NullableJsonNullValueInput | InputJsonValue
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    isMainCampaign?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemUpdateStepCreateManyUpdateInput = {
    id?: string
    title: string
    description?: string | null
    progress?: number
    status?: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemUpdateStepUpdateWithoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemUpdateStepUncheckedUpdateWithoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemUpdateStepUncheckedUpdateManyWithoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}